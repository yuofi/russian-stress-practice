This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
.lintstagedrc.yml
backend/.gitignore
backend/.lintstagedrc.yml
backend/eslint.config.mjs
backend/jest.config.cjs
backend/package.json
backend/src/data/paronyms.js
backend/src/data/words.js
backend/src/index.ts
backend/src/lib/ctx.ts
backend/src/lib/passport.ts
backend/src/lib/prisma.ts
backend/src/lib/trpc.ts
backend/src/prisma/migrations/migration_lock.toml
backend/src/prisma/schema.prisma
backend/src/router/auth/GetAuth/index.ts
backend/src/router/auth/GetAuth/input.ts
backend/src/router/auth/GetMe/index.ts
backend/src/router/Dictionary/CheckPersonalItem/index.ts
backend/src/router/Dictionary/CheckPersonalItem/input.ts
backend/src/router/Dictionary/GetPersonalDictionary/index.ts
backend/src/router/Dictionary/GetPersonalDictionary/input.ts
backend/src/router/Dictionary/TogglePersonalParonym/index.ts
backend/src/router/Dictionary/TogglePersonalParonym/input.ts
backend/src/router/Dictionary/TogglePersonalWord/index.ts
backend/src/router/Dictionary/TogglePersonalWord/input.ts
backend/src/router/index.ts
backend/src/router/Practice/GetParonyms/index.ts
backend/src/router/Practice/GetPracticeWords/index.ts
backend/src/router/Practice/GetPracticeWords/input.ts
backend/src/router/Practice/GetUserStats/index.ts
backend/src/router/Practice/GetUserStats/input.ts
backend/src/router/Practice/RecordPractice/index.ts
backend/src/router/Practice/RecordPractice/input.ts
backend/src/scripts/importParonyms.ts
backend/src/scripts/presetDB.ts
backend/src/utils/deepMap.ts
backend/src/utils/env.ts
backend/src/utils/error.ts
backend/src/utils/logger.ts
backend/src/utils/models.ts
backend/src/utils/types.ts
backend/tsconfig.build.json
backend/tsconfig.json
docker-compose.yml
Dockerfile
eslint.config.mjs
frontend/.env.production
frontend/.envrc
frontend/.github/workflows/deploy.yml
frontend/.gitignore
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/public/index.js
frontend/public/vite.svg
frontend/README.md
frontend/src/App.tsx
frontend/src/components/Loader/index.tsx
frontend/src/components/Login/index.tsx
frontend/src/components/Navigation.tsx
frontend/src/components/PersonalDictionaryButton/index.tsx
frontend/src/components/PracticeStats/index.tsx
frontend/src/components/svg/svgNative.tsx
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/LogOutPage/index.tsx
frontend/src/pages/ParonymsPage/index.tsx
frontend/src/pages/ParonymsPage/ParonymsInterface.tsx
frontend/src/pages/PersonalDictionaryPage/index.tsx
frontend/src/pages/StressPracticePage/index.tsx
frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx
frontend/src/types/nodes.ts
frontend/src/types/practice.ts
frontend/src/types/types.d.ts
frontend/src/utils.test.js
frontend/src/utils/ctx.tsx
frontend/src/utils/env.ts
frontend/src/utils/googleAuth.ts
frontend/src/utils/pumpGetRoute.ts
frontend/src/utils/routes.ts
frontend/src/utils/statsContext.tsx
frontend/src/utils/trpc.tsx
frontend/src/utils/utils.ts
frontend/tailwind.config.js
frontend/tsconfig.json
frontend/vite.config.ts
jest.config.cjs
package.json
pnpm-workspace.yaml
shared/.lintstagedrc.yml
shared/jest.config.js
shared/package.json
shared/src/getKeysAsArray.ts
shared/src/omit.ts
shared/src/pick.ts
shared/src/tryCatch.ts
shared/src/zod.ts
shared/tsconfig.json
tmep
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
node_modules
dist
.env*
*.env
frontend/.env*
backend/.env*
**/.turbo
**/.next
**/.cache
**/pnpm-debug.log
</file>

<file path="backend/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["**/test/**/*", "**/*.test.ts"]
}
</file>

<file path="docker-compose.yml">
version: '3.9'

services:
  db:
    image: postgres:15
    restart: unless-stopped
    container_name: postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: rupractice
      POSTGRES_PASSWORD: rupractice
      POSTGRES_DB: russian
    volumes:
      - pgdata:/var/lib/postgresql/data

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: stress-practice-app
    restart: unless-stopped
    ports:
      - "3000:3000" # backend
      - "5173:5173" # optional: frontend preview
    depends_on:
      - db
    volumes:
      - ./etc/secrets:/etc/secrets:ro
    environment:
      DATABASE_URL: postgres://rupractice:rupractice@db:5432/russian
      NODE_ENV: production
    command: ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]

volumes:
  pgdata:
</file>

<file path="frontend/.gitignore">
dist
node-modules
</file>

<file path="tmep">
# ---------------------- BASE IMAGE ----------------------
FROM node:22-slim AS base

RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable

# ---------------------- PREPARE (Install only) ----------------------
FROM base AS prepare_workspace
WORKDIR /app

COPY pnpm-workspace.yaml pnpm-lock.yaml package.json ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY shared/package.json ./shared/

RUN pnpm install --frozen-lockfile

# ---------------------- BUILD ----------------------
FROM prepare_workspace AS build
WORKDIR /app

# Копируем исходники после установки
COPY . .

# Копируем .env (если VITE_* переменные нужны во время сборки)
COPY etc/secrets/.frontend.env ./frontend/.env
COPY etc/secrets/.backend.env ./backend/.env

RUN pnpm build # должен собирать frontend и backend

# ---------------------- FINAL IMAGE ----------------------
FROM node:22-slim AS prod
WORKDIR /app

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
ENV NODE_ENV=production

# Копируем workspace манифесты
COPY package.json pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY shared/package.json ./shared/

# Копируем node_modules (или установим заново)
COPY --from=prepare_workspace /app/node_modules ./node_modules
COPY --from=prepare_workspace /app/backend/node_modules ./backend/node_modules
COPY --from=prepare_workspace /app/shared/node_modules ./shared/node_modules

# Копируем прод-сборку
COPY --from=build /app/backend/dist ./backend/dist
COPY --from=build /app/frontend/dist ./frontend/dist

# Копируем .env для backend
COPY etc/secrets/.backend.env ./backend/.env

HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:3000/ping || exit 1

EXPOSE 3000

CMD ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]
</file>

<file path=".lintstagedrc.yml">
'*.{ts,js,json,yml}': 'prettier --loglevel warn --cache --write'
</file>

<file path="backend/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix"
  - "prettier --loglevel warn --cache --write"
"*.{json,yml,scss}": "prettier --loglevel warn --cache --write"
</file>

<file path="backend/eslint.config.mjs">
import { defineConfig } from "eslint/config";
import path from 'path';
import tsParser from '@typescript-eslint/parser';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import importPlugin from 'eslint-plugin-import';

export default defineConfig([{
    files: ['**/*.ts', '**/*.tsx', '**/*.js'],
    ignores: ['jest.config.js'],
    plugins: {
        '@typescript-eslint': tsPlugin,
        'import': importPlugin
      },
    languageOptions: {
        ecmaVersion: 5,
        sourceType: "script",
        parser: tsParser,
        parserOptions: {
            project: "./tsconfig.json",
        },
    },

    settings: {
        "import/resolver": {
            node: {
                extensions: [".js", ".ts", ".tsx"],
            },
        },
    },

    rules: {
        "no-console": "error",

        "no-restricted-imports": ["error", {
        patterns: [{
          group: [
            path.join(process.cwd(), "src/test/**"),
            `!${path.join(process.cwd(), "src/**/*.integration.test.ts")}`
          ],
          message: "Import from test dir is only allowed in integration test files",
        }]
      }],

      "import/order": ["error", {
            groups: ["builtin", "external", "parent", "sibling", "index"],

            pathGroups: [{
                pattern: "{.,..}/**/env\n",
                group: "builtin",
                position: "before",
            }, {
                pattern: "{.,..}/**/test/integration\n",
                group: "builtin",
                position: "before",
            }],

            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],
    },
}]);
</file>

<file path="backend/jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.cjs'),
  }
</file>



export default rawWords;
</file>

<file path="backend/src/index.ts">
import { env } from "./utils/env";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import cors from "cors";
import express from "express";
import { AppContext, createAppContext } from "./lib/ctx";
import { applyPassportToExpressApp } from "./lib/passport";
import { ApplyTrpcToExpressApp, getCreateTrpcContext } from "./lib/trpc";
import { trpcRouter } from "./router";
import { logger } from "./utils/logger";

void (async () => {
  let ctx: AppContext | null = null;
  try {
    const app = express();
    ctx = createAppContext();
    
    app.use(
      cors({
        origin: ["http://localhost:5173"], // Explicitly allow your frontend origin
        credentials: true,
        methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowedHeaders: [
          "Content-Type",
          "Authorization",
          "x-trpc-source",
          "Access-Control-Allow-Origin",
          "Access-Control-Allow-Credentials",
        ],
      })
    );
    
    // Важно: применяем Passport до TRPC middleware
    applyPassportToExpressApp(app, ctx);
    
    await ApplyTrpcToExpressApp(app, ctx, trpcRouter);
    
    app.options("*", cors());
    app.get("/ping", (req, res) => {
      res.send("pong");
    });
    
    app.use(
      (
        error: unknown,
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        logger.error("express", error);
        if (res.headersSent) {
          next(error);
          return;
        }
        res.status(500).send("Internal server error");
      }
    );

    app.listen(env.PORT, () => {
      logger.info("app", `listening on http://localhost:${env.PORT}`);
    });
  } catch (error) {
    logger.error("app", error);
    await ctx?.stop();
  }
})();
</file>

<file path="backend/src/lib/ctx.ts">
import { createPrismaClient } from "./prisma";

export const createAppContext = () => {
  const prisma = createPrismaClient();
  return {
    prisma,
    stop: async () => {
      await prisma.$disconnect();
    },
  };
};

export type AppContext = ReturnType<typeof createAppContext>;
</file>

<file path="backend/src/lib/passport.ts">
import { env } from "../utils/env";
import { Express } from "express";
import { Passport } from "passport";
import { ExtractJwt, Strategy as JWTStrategy } from "passport-jwt";
import { logger } from "../utils/logger";
import { AppContext } from "./ctx";

export const applyPassportToExpressApp = (expressApp: Express, ctx: AppContext): void => {
  const passport = new Passport();

  // Стандартный payload: { sub: user.id, … }
  passport.use(
    new JWTStrategy(
      {
        secretOrKey: env.JWT_SECRET,
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      },
      async (jwtPayload: any, done) => {
        try {
          logger.info("passport:jwt", "JWT payload received", { payload: jwtPayload });
          const userId = parseInt(jwtPayload.sub, 10);
          logger.info("passport:jwt", "Looking for user with ID", { userId });
          
          const user = await ctx.prisma.user.findUnique({ where: { id: userId } });
          
          if (!user) {
            logger.info("passport:jwt", "User not found", { userId });
            return done(null, false);
          }
          
          logger.info("passport:jwt", "User authenticated successfully", { userId });
          return done(null, user);
        } catch (error) {
          logger.error("passport:jwt", error);
          return done(error, false);
        }
      }
    )
  );

  expressApp.use((req, res, next) => {
    // если нет заголовка – пропускаем дальше
    if (!req.headers.authorization) {
      logger.info("passport:middleware", "No authorization header");
      return next();
    }

    logger.info("passport:middleware", "Authorization header found", { 
      header: req.headers.authorization.substring(0, 20) + '...' 
    });

    passport.authenticate("jwt", { session: false }, (err: any, user: any) => {
      if (err) {
        logger.error("passport:middleware", err);
      }
      
      req.user = user ?? undefined;
      logger.info("passport:middleware", user ? "User attached to request" : "No user attached to request", {
        userId: user?.id
      });
      
      next();
    })(req, res, next);
  });
};
</file>

<file path="backend/src/lib/prisma.ts">
import { env } from "../utils/env";
import { PrismaClient } from "@prisma/client";
import { logger } from "../utils/logger";

export const createPrismaClient = () => {
  const prisma = new PrismaClient({
    log: [
      {
        emit: "event",
        level: "query",
      },
      {
        emit: "event",
        level: "info",
      },
    ],
  });

  prisma.$on("query", (e) => {
    logger.info("prisma:low:query", "Successfull request", {
      query: e.query,
      duration: e.duration,
      params: env.HOST_ENV === "local" ? e.params : "***",
    });
  });

  prisma.$on("info", (e) => {
    logger.info("prisma:low:info", e.message);
  });

  const extendedPrisma = prisma.$extends({
    client: {},
    query: {
      $allModels: {
        $allOperations: async ({ model, operation, args, query }) => {
          const start = Date.now();
          try {
            const result = await query(args);
            const durationMs = Date.now() - start;
            logger.info("prisma:high", "Successfull request", {
              model,
              operation,
              args,
              durationMs,
            });
            return result;
          } catch (error) {
            const durationMs = Date.now() - start;
            logger.error("prisma:high", error, {
              model,
              operation,
              args,
              durationMs,
            });
            throw error;
          }
        },
      },
    },
  });

  return extendedPrisma;
};
</file>

<file path="backend/src/lib/trpc.ts">
import { inferAsyncReturnType, initTRPC } from "@trpc/server";
import * as trpcExpress from "@trpc/server/adapters/express";
import { type Express } from "express";
import { SuperJSON } from "superjson";
import { expressHandler } from "trpc-playground/handlers/express";
import { TrpcRouter, type trpcRouter } from "../router";
// import { AppContext } from "./ctx";
import { ExpectedError } from "../utils/error";
import { logger } from "../utils/logger";
import { ExpressRequest } from "../utils/types";
import { AppContext } from "./ctx";

export const getTrpcContext = ({ appContext, req }: {appContext: AppContext, req: ExpressRequest}) => ({
  ...appContext,
  me: (req as ExpressRequest).user || null,
})


export const getCreateTrpcContext =
  (appContext: AppContext) =>
  ({ req }: trpcExpress.CreateExpressContextOptions) =>
    getTrpcContext({ appContext, req: req as ExpressRequest })

type TrpcContext = inferAsyncReturnType<
  ReturnType<typeof getCreateTrpcContext>
>;

const trpc = initTRPC.context<TrpcContext>().create({
  transformer: SuperJSON,
  errorFormatter: ({shape, error}) => {
    const orginalError = error.cause as Error
    const expected = orginalError instanceof ExpectedError
    return {
      ...shape,
      data: {
        ...shape.data,
        expected
      }
    }
  }
});

export const createTrpcRouter = trpc.router

export const trpcLoggedProcedure = trpc.procedure.use(
  trpc.middleware(async ({ path, type, next, ctx, rawInput }) => {
    const start = Date.now()
    const result = await next()
    const durationMs = Date.now() - start
    const meta = {
      path,
      type,
      userId: ctx.me?.id || null,
      durationMs,
      rawInput: rawInput || null,
    }
    if (result.ok) {
      logger.info(`trpc:${type}:success`, 'Successfull request', { ...meta, output: result.data })
    } else {
      logger.error(`trpc:${type}:error`, result.error)
    }
    return result
  })
)

export const ApplyTrpcToExpressApp = async (
  app: Express,
  ctx: AppContext,
  trpcRouter: TrpcRouter,
) => {
  app.use(
    "/trpc",
    trpcExpress.createExpressMiddleware({
      router: trpcRouter,
      createContext: getCreateTrpcContext(ctx),
    }),
  );

  app.use(
    "/trpc-playground",
    await expressHandler({
      trpcApiEndpoint: "/trpc",
      playgroundEndpoint: "/trpc-playground",
      router: trpcRouter,
      request: {
        superjson: true,
      },
    }),
  );
};
</file>

<file path="backend/src/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="backend/src/router/auth/GetAuth/index.ts">
import { Provider } from "@prisma/client";
import jwt from "jsonwebtoken"
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { env } from "../../../utils/env";
import { ExpectedError } from "../../../utils/error";
import { zOAuthLogin } from "./input";

export const GetAuthTrpcRoute = trpcLoggedProcedure
  .input(zOAuthLogin)
  .mutation(async ({ ctx, input }) => {
    const { provider, credentials } = input;

    try {
      // Try to find existing user
      const existingUser = await ctx.prisma.user.findUnique({
        where: {
          provider_providerId: {
            provider: provider as Provider,
            providerId: credentials.providerId,
          },
        },
      });

      let newOrUpdatedUser;
      
      if (existingUser) {
        // Update existing user's tokens
        newOrUpdatedUser = await ctx.prisma.user.update({
          where: { id: existingUser.id },
          data: {
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
            name: credentials.name || existingUser.name,
          },
        });
      } else {
        // Create new user
        newOrUpdatedUser = await ctx.prisma.user.create({
          data: {
            email: credentials.email,
            name: credentials.name,
            provider: provider as Provider,
            providerId: credentials.providerId,
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
          },
        });
      }
      
      const appToken = jwt.sign(
        { sub: newOrUpdatedUser.id },
        env.JWT_SECRET,
        { expiresIn: "7d" }
      );
      
      return { user: newOrUpdatedUser, token: appToken };
    } catch (error) {
      throw new ExpectedError("Failed to process authentication");
    }
  });
</file>

<file path="backend/src/router/auth/GetAuth/input.ts">
import { z } from "zod";

export const zOAuthCredentials = z.object({
  email: z.string().email(),
  name: z.string().optional(),
  providerId: z.string(),
  accessToken: z.string(),
  refreshToken: z.string().optional(),
  tokenExpires: z.string().optional().transform(val => val ? new Date(val) : undefined),
});

export const zOAuthLogin = z.object({
  provider: z.enum(['GOOGLE', 'YANDEX']),
  credentials: zOAuthCredentials,
});
</file>

<file path="backend/src/router/auth/GetMe/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { toClientMe } from "../../../utils/models";

export const GetMeTrpcRoute = trpcLoggedProcedure.query(({ ctx }) => {
  return { me: toClientMe(ctx.me) };
});
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zCheckPersonalItem } from "./input";

export const CheckPersonalItemTrpcRoute = trpcLoggedProcedure
  .input(zCheckPersonalItem)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type, id } = input;

    if (type === "STRESS") {
      // Проверяем, есть ли слово в личном словарике
      const personalWord = await ctx.prisma.personalWord.findUnique({
        where: {
          userId_wordId: {
            userId: ctx.me.id,
            wordId: id,
          },
        },
      });

      return { isPersonal: !!personalWord };
    } else if (type === "PARONYM") {
      // Проверяем, есть ли пара паронимов в личном словарике
      const personalParonym = await ctx.prisma.personalParonym.findUnique({
        where: {
          userId_paronymPairId: {
            userId: ctx.me.id,
            paronymPairId: id,
          },
        },
      });

      return { isPersonal: !!personalParonym };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Неподдерживаемый тип",
    });
  });
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/input.ts">
import { z } from "zod";

export const zCheckPersonalItem = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  id: z.number(),
});
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPersonalDictionary } from "./input";

export const GetPersonalDictionaryTrpcRoute = trpcLoggedProcedure
  .input(zGetPersonalDictionary)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type } = input;

    if (type === "STRESS") {
      // Получаем слова с ударениями из личного словарика
      const personalWords = await ctx.prisma.personalWord.findMany({
        where: {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
        },
        include: {
          word: {
            include: {
              practices: {
                where: {
                  userId: ctx.me.id,
                },
                orderBy: {
                  createdAt: "desc",
                },
              },
            },
          },
        },
      });

      return {
        words: personalWords.map((entry) => ({
          id: entry.word.id,
          word: entry.word.word,
          accentIdx: entry.word.stress,
          history: entry.word.practices.map((practice) => ({
            correct: practice.correct,
            date: practice.createdAt,
          })),
        })),
      };
    } else if (type === "PARONYM") {
      // Получаем пары паронимов из личного словарика
      const personalParonyms = await ctx.prisma.personalParonym.findMany({
        where: {
          userId: ctx.me.id,
        },
        include: {
          paronymPair: {
            include: {
              words: true,
            },
          },
        },
      });

      return {
        paronyms: personalParonyms.map((entry) => ({
          id: entry.paronymPair.id,
          group: entry.paronymPair.words.map((word) => word.word),
          paronyms: entry.paronymPair.words.map((word) => ({
            id: word.id,
            word: word.word,
            explanation: word.description || "",
          })),
        })),
      };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Неподдерживаемый тип словарика",
    });
  });
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/input.ts">
import { z } from "zod";

export const zGetPersonalDictionary = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalParonym } from "./input";

export const TogglePersonalParonymTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalParonym)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { paronymPairId, isPersonal } = input;

    // Проверяем существование пары паронимов
    const paronymPair = await ctx.prisma.paronymPair.findUnique({
      where: { id: paronymPairId },
    });

    if (!paronymPair) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "Пара паронимов не найдена",
      });
    }

    // Проверяем, есть ли уже эта пара в личном словарике
    const existingEntry = await ctx.prisma.personalParonym.findUnique({
      where: {
        userId_paronymPairId: {
          userId: ctx.me.id,
          paronymPairId: paronymPairId,
        },
      },
    });

    if (isPersonal) {
      // Если нужно добавить в словарик и записи еще нет
      if (!existingEntry) {
        await ctx.prisma.personalParonym.create({
          data: {
            userId: ctx.me.id,
            paronymPairId: paronymPairId,
          },
        });
      }
    } else {
      // Если нужно удалить из словарика и запись существует
      if (existingEntry) {
        await ctx.prisma.personalParonym.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, paronymPair };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/input.ts">
import { z } from "zod";

export const zTogglePersonalParonym = z.object({
  paronymPairId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalWord } from "./input";

export const TogglePersonalWordTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalWord)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { wordId, isPersonal } = input;

    // Проверяем существование слова
    const word = await ctx.prisma.word.findUnique({
      where: { id: wordId },
    });

    if (!word) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "Слово не найдено",
      });
    }

    // Проверяем, есть ли уже это слово в личном словарике
    const existingEntry = await ctx.prisma.personalWord.findUnique({
      where: {
        userId_wordId: {
          userId: ctx.me.id,
          wordId: wordId,
        },
      },
    });

    if (isPersonal) {
      // Если нужно добавить в словарик и записи еще нет
      if (!existingEntry) {
        await ctx.prisma.personalWord.create({
          data: {
            userId: ctx.me.id,
            wordId: wordId,
          },
        });
      }
    } else {
      // Если нужно удалить из словарика и запись существует
      if (existingEntry) {
        await ctx.prisma.personalWord.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, word };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/input.ts">
import { z } from "zod";

export const zTogglePersonalWord = z.object({
  wordId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Practice/GetParonyms/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";

export const GetParonymsTrpcRoute = trpcLoggedProcedure
  .query(async ({ ctx }) => {
    // Получаем все пары паронимов из базы данных
    const paronymPairs = await ctx.prisma.paronymPair.findMany({
      include: {
        words: true,
      },
    });

    // Преобразуем данные в формат, удобный для фронтенда
    const paronyms = paronymPairs.map(pair => {
      return {
        id: pair.id,
        group: pair.words.map(word => word.word),
        paronyms: pair.words.map(word => ({
          id: word.id,
          word: word.word,
          explanation: word.description || "", // Используем индивидуальное описание слова
        })),
      };
    });

    return { paronyms };
  });
</file>

<file path="backend/src/router/Practice/GetPracticeWords/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPracticeWords } from "./input";

export const GetPracticeWordsTrpcRoute = trpcLoggedProcedure
    .input(zGetPracticeWords)
    .query(async ({ ctx, input }) => {
        const words = await ctx.prisma.word.findMany({
            where: {
                type: input.type
            },
            select: {
                id: true,
                word: true,
                stress: true,
                practices: {
                    where: {
                        userId: ctx.me?.id
                    },
                    orderBy: {
                        createdAt: 'desc'
                    },
                    take: 10
                }
            }
        });
        
        return {
            words: words.map(word => ({
                id: word.id,
                word: word.word,
                accentIdx: word.stress,
                history: word.practices.map(practice => ({
                    correct: practice.correct,
                    date: practice.createdAt
                }))
            }))
        };
    });
</file>

<file path="backend/src/router/Practice/GetPracticeWords/input.ts">
import {z} from 'zod'

export const zGetPracticeWords = z.object({
    type: z.enum(['STRESS', 'PARONYM'])
})
</file>

<file path="backend/src/router/Practice/RecordPractice/input.ts">
import {z} from "zod"

export const zRecordPractice = z.object({
  // Общие поля
  correct: z.boolean(),
  
  wordId: z.number().optional(),
  
  paronymPairId: z.number().optional(),
  selectedWordId: z.number().optional(),
  correctWordId: z.number().optional(),
  
  type: z.enum(["STRESS", "PARONYM"]).optional(),
});
</file>

<file path="backend/src/scripts/importParonyms.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import paronymData from "../data/paronyms";
import { logger } from "../utils/logger";

async function importParonyms() {
  const prisma = new PrismaClient();
  logger.info("presetDB", "starting paronyms import...");
  
  try {
    // Для каждой группы паронимов
    for (const group of paronymData) {
      logger.info("presetDB", `Обрабатываем группу: ${group.group.join(", ")}`);
      
      // Создаем или находим слова для каждого паронима
      const wordRecords = [];
      
      for (const paronym of group.paronyms) {
        // Ищем слово в базе данных
        let word = await prisma.word.findFirst({
          where: {
            word: paronym.word,
          },
        });
        
        // Если слово не найдено, создаем его
        if (!word) {
          word = await prisma.word.create({
            data: {
              word: paronym.word,
              stress: 0, // Для паронимов позиция ударения не важна
              type: PracticeType.PARONYM,
              description: paronym.explanation // Сохраняем индивидуальное описание
            },
          });
          logger.info("presetDB", `Created new word: ${word.word} with explanation: ${paronym.explanation}`);
        } else {
          // Обновляем тип слова и описание, если оно уже существует
          word = await prisma.word.update({
            where: { id: word.id },
            data: { 
              type: PracticeType.PARONYM,
              description: paronym.explanation
            }
          });
        }
        
        wordRecords.push(word);
      }
      
      // Создаем пару паронимов и связываем с словами
      const paronymPair = await prisma.paronymPair.create({
        data: {
          words: {
            connect: wordRecords.map(word => ({ id: word.id }))
          }
        }
      });
      
      logger.info("presetDB", `Created paronym pair with ID: ${paronymPair.id}`);
    }
    
    logger.info("presetDB", "Paronyms import completed successfully");
  } catch(error) {
    logger.error("presetDB", "Error during database preset", error as any);
  } finally {
    await prisma.$disconnect();
  }
}

// Вызываем функцию импорта
if (require.main === module) {
  importParonyms()
    .then(() => {
      logger.info("presetDB", "Import script finished");
      process.exit(0);
    })
    .catch(error => {
      logger.error("presetDB", "Import script failed", error);
      process.exit(1);
    });
}

export default importParonyms;
</file>

<file path="backend/src/scripts/presetDB.ts">
import { PrismaClient, PracticeType } from '@prisma/client';
import rawWords from '../data/words';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

// Функция для инициализации слов (адаптирована из utils.ts)
function processRawWords(rawWords: string[]): { word: string, accentIdx: number }[] {
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx || -1
    };
  });
}

async function presetDB() {
  logger.info("presetDB", "Starting database preset...");
  
  try {
    // Обработка слов из words.js
    const processedWords = processRawWords(rawWords);
    
    // Фильтрация слов с корректным ударением
    const validWords = processedWords.filter(word => word.accentIdx >= 0 && word.word.length > 0);
    
    logger.info("presetDB", `Processed ${validWords.length} valid words`);

    // Очистка существующих слов типа STRESS (опционально)
    await prisma.word.deleteMany({
      where: {
        type: PracticeType.STRESS
      }
    });
    
    logger.info("presetDB", "Deleted existing stress practice words");
    
    // Добавление слов в базу данных
    const createdWords = await prisma.word.createMany({
      data: validWords.map(word => ({
        word: word.word,
        stress: word.accentIdx,
        type: PracticeType.STRESS
      })),
      skipDuplicates: true
    });
    
    logger.info("presetDB", `Added ${createdWords.count} words to the database`);

    return { success: true, count: createdWords.count };
  } catch (error) {
    logger.error("presetDB", "Error during database preset", error as any);
    return { success: false, error };
  } finally {
    await prisma.$disconnect();
  }
}

// Запуск скрипта, если он вызван напрямую
if (require.main === module) {
  presetDB()
    .then(result => {
      if (result.success) {
        logger.info("presetDB", "Database preset completed successfully!");
        process.exit(0);
      } else {
        logger.error("presetDB", "Database preset failed!", result.error as any);
        process.exit(1);
      }
    })
    .catch(err => {
      logger.error("presetDB", "Unhandled error during database preset", err);   
      process.exit(1);
    });
}

export default presetDB;
</file>

<file path="backend/src/utils/deepMap.ts">
import _ from "lodash";

type ReplaceFn = ({
  path,
  key,
  value,
}: {
  path: string;
  key: string;
  value: Value;
}) => Value;
type Value =
  | Object
  | number
  | string
  | boolean
  | null
  | undefined
  | Function
  | Symbol
  | any[];

const recursion = ({
  input,
  replaceFn,
  seen,
  pathStartsWith,
  parentKey,
}: {
  input: Value;
  replaceFn: ReplaceFn;
  seen: WeakSet<any>;
  pathStartsWith: string;
  parentKey: string;
}): Value => {
  if (
    ["object", "function", "symbol"].includes(typeof input) &&
    input !== null
  ) {
    if (seen.has(input)) {
      return "!!!CIRCULAR!!!";
    } else {
      seen.add(input);
    }
  }
  const result = replaceFn({
    path: pathStartsWith.replace(/\.$/, ""),
    key: parentKey,
    value: input,
  });
  if (!result) {
    return result;
  }
  if (_.isArray(result)) {
    return result.map((item, index) =>
      recursion({
        input: item,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${index}.`,
        parentKey: index.toString(),
      }),
    );
  }
  if (_.isObject(result)) {
    const object: any = {};
    for (const [key, value] of Object.entries(result)) {
      object[key] = recursion({
        input: value,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${key}.`,
        parentKey: key,
      });
    }
    return object;
  }
  return result;
};

export const deepMap = <T = Value>(input: Value, replaceFn: ReplaceFn): T => {
  const seen = new WeakSet();
  const mappedObject = recursion({
    input,
    replaceFn,
    seen,
    pathStartsWith: "",
    parentKey: "",
  });
  const clonedMappedObject = _.cloneDeep(mappedObject);
  return clonedMappedObject as T;
};
</file>

<file path="backend/src/utils/error.ts">
export class ExpectedError extends Error {
  isExpected = true as const;
}
</file>

<file path="backend/src/utils/logger.ts">
import { env } from "./env";
import { EOL } from "os";
import {omit} from "@russian-stress-practice/shared/src/omit"
import { TRPCError } from "@trpc/server";
import debug from "debug";
import _ from "lodash";
import pc from "picocolors";
import { serializeError } from "serialize-error";
import { MESSAGE } from "triple-beam";
import winston from "winston";
import * as yaml from "yaml";
import { deepMap } from "./deepMap";
import { ExpectedError } from "./error";
// import { sentryCaptureException } from "./sentry";

export const winstonLogger = winston.createLogger({
  level: "debug",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  defaultMeta: { service: "backend", hostEnv: env.HOST_ENV },
  transports: [
    new winston.transports.Console({
      format:
        env.HOST_ENV !== "local"
          ? winston.format.json()
          : winston.format((logData) => {
              const setColor = {
                info: (str: string) => pc.blue(str),
                error: (str: string) => pc.red(str),
                debug: (str: string) => pc.cyan(str),
              }[logData.level as "info" | "error" | "debug"];
              const levelAndType = `${logData.level} ${logData.logType}`;
              const timestamp =
                typeof logData.timestamp === "string" ? logData.timestamp : "";
              const topMessage = `[${setColor(levelAndType)}] ${pc.green(timestamp)}${EOL}${logData.message}`;

              const visibleMessageTags = omit(logData, [
                "level",
                "logType",
                "timestamp",
                "message",
                "service",
                "hostEnv",
              ]);

              const stringifyedLogData = _.trim(
                yaml.stringify(visibleMessageTags, (_k, v) =>
                  _.isFunction(v) ? "Function" : v,
                ),
              );

              const resultLogData = {
                ...logData,
                [MESSAGE]:
                  [
                    topMessage,
                    Object.keys(visibleMessageTags).length > 0
                      ? `${EOL}${stringifyedLogData}`
                      : "",
                  ]
                    .filter(Boolean)
                    .join("") + EOL,
              };

              return resultLogData;
            })(),
    }),
  ],
});

export type LoggerMetaData = Record<string, any> | undefined;
const prettifyMeta = (meta: LoggerMetaData): LoggerMetaData => {
  return deepMap(meta, ({ key, value }) => {
    if (
      [
        "email",
        "password",
        "newPassword",
        "oldPassword",
        "token",
        "text",
        "description",
      ].includes(key)
    ) {
      return "🙈";
    }
    return value;
  });
};

export const logger = {
  info: (logType: string, message: string, meta?: LoggerMetaData) => {
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    winstonLogger.info(message, { logType, ...prettifyMeta(meta) });
  },
  error: (logType: string, error: any, meta?: LoggerMetaData) => {
    // const isNativeExpectedError = error instanceof ExpectedError
    // const isTrpcExpectedError = error instanceof TRPCError && error.cause instanceof ExpectedError
    const prettifiedMetaData = prettifyMeta(meta)
    // if (!isNativeExpectedError && !isTrpcExpectedError) {
    //   sentryCaptureException(error, prettifiedMetaData)
    // }
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    const serializedError = serializeError(error);
    winstonLogger.error(serializedError.message || "Unknown error", {
      logType,
      error,
      errorStack: serializedError.stack,
      ...prettifiedMetaData,
    });
  },
};
</file>

<file path="backend/src/utils/models.ts">
import type { User } from "@prisma/client";
import {pick} from "@russian-stress-practice/shared/src/pick"

export const toClientMe = (user: User | null) => {
  return user && pick(user, ["id", "name", "email", "score", "provider", "providerId", "accessToken"]);
};
</file>

<file path="backend/src/utils/types.ts">
import { type User } from "@prisma/client";
import { type Request } from "express";

export type ExpressRequest = Request & {
  user: User | undefined;
};
</file>

<file path="backend/tsconfig.json">
{
  "ts-node": {
    "files": true,
    "transpile0nly": true
  },
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "downlevelIteration": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "inlineSources": true,
    "isolatedModules": false,
    "lib": ["ES2021"],
    "module": "commonjs",
    "moduleResolution": "Node",
    "target": "ES2021",
    "paths": {
      "@russian-stress-practice/shared/*": ["../shared/*"],
      "@russian-stress-practice/frontend/*": ["../frontend/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import node from "eslint-plugin-node";
import jest from "eslint-plugin-jest";
import path from "node:path";
import { fileURLToPath } from "node:url";
import js from "@eslint/js";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
    baseDirectory: __dirname,
    recommendedConfig: js.configs.recommended,
    allConfig: js.configs.all
});

export default defineConfig([globalIgnores(["**/node_modules", "**/dist", "**/*.config.js"]), {
    extends: compat.extends("standard-with-typescript", "prettier", "plugin:jest/recommended"),

    plugins: {
        node,
        jest,
    },

    rules: {
        "no-new": "off",

        "import/order": ["error", {
            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],

        "@typescript-eslint/consistent-type-definitions": ["error", "type"],
        "@typescript-eslint/strict-boolean-expressions": "off",
        "@typescript-eslint/prefer-nullish-coalescing": "off",
        "@typescript-eslint/explicit-function-return-type": "off",
        "@typescript-eslint/restrict-template-expressions": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/consistent-type-assertions": "off",
        "jsx-a11y/anchor-is-valid": "off",
        curly: ["error", "all"],

        "no-irregular-whitespace": ["error", {
            skipTemplates: true,
            skipStrings: true,
        }],

        "node/no-process-env": "error",

        "no-restricted-syntax": ["error", {
            selector: "[object.type=MetaProperty][property.name=env]",
            message: "Use instead import { env } from \"lib/env\"",
        }],
    },
}]);
</file>

<file path="frontend/.env.production">
HOST_ENV=render
NODE_ENV=production
VITE_GOOGLE_CLIENT_ID=186603076724-rv7ju37n9gs3gck7a11a6ertr08k35be.apps.googleusercontent.com
VITE_GOOGLE_REDIRECT_URI=http://localhost:5173/auth/callback/google
VITE_BACKEND_TRPC_URL=http://localhost:3000/trpc
VITE_WEBAPP_URL=http://localhost:5173/
VITE_PORT=5173
</file>

<file path="frontend/.envrc">
use flake
</file>

<file path="frontend/.github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>


<file path="frontend/README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"вОвремя"` (stress on the first 'о')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="frontend/src/components/Loader/index.tsx">
import { Bouncy } from "ldrs/react";
import React from "react";
import "ldrs/react/Bouncy.css";
import { JellyTriangle } from 'ldrs/react'
import 'ldrs/react/JellyTriangle.css'


interface LoaderProps {
    size?: string
    speed?: string
    color?: string
}

export const Loader = ({size="45px", speed="1.2s", color="rgb(67, 73, 233)"}: LoaderProps) => {
  return (
    <>
      <JellyTriangle size={size} speed={speed} color={color} />
    </>
  );
};
</file>

<file path="frontend/src/components/Login/index.tsx">
import React, { useEffect } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";
import { useGoogleAuth  } from "../../utils/googleAuth";

interface LoginProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function Login({ isOpen, onClose }: LoginProps) {
  const login = useGoogleAuth();
  const handleGoogleLoginClick = async () => {
    try {
      login();
      onClose();
    } catch (error) {
      console.error('Failed to login with Google:', error);
    }
  };

  const handleYandexLogin = async () => {
    // TODO: Implement Yandex OAuth
    console.log("Yandex login clicked");
  };

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 backdrop-blur-sm" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <Dialog.Title
                  as="h3"
                  className="text-lg font-medium leading-6 text-gray-900 text-center mb-4"
                >
                  Войти в аккаунт
                </Dialog.Title>

                <div className="mt-4 space-y-3">
                  <button
                    onClick={handleGoogleLoginClick}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://www.google.com/favicon.ico"
                      alt="Google logo"
                    />
                    Войти через Google
                  </button>

                  <button
                    onClick={handleYandexLogin}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://yastatic.net/s3/home-static/_/7c/7ccf30cd11b00c2eb4f79f698da24aa2.png"
                      alt="Yandex logo"
                    />
                    Войти через Яндекс
                  </button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
}
</file>

<file path="frontend/src/components/PracticeStats/index.tsx">
import React from 'react';
import { Loader } from '../Loader';
import { PracticeType } from '../../types/practice';
import trpc from '../../utils/trpc';

// Типы для пропсов компонента
interface PracticeStatsProps {
  type: "STRESS" | "PARONYM";
  period?: number;
  onPeriodChange?: (period?: number) => void;
}

// Типы для данных статистики
interface StatsData {
  summary: {
    totalAttempts: number;
    correctAttempts: number;
    correctRate: number;
    recentStats?: {
      totalAttempts: number;
      correctAttempts: number;
      correctRate: number;
    };
  };
  dailyStats: Array<{
    date: string;
    total: number;
    correct: number;
    rate: number;
  }>;
  problemWords: Array<{
    id: number;
    word: string;
    total: number;
    correct: number;
  }>;
}

// Хук для получения статистики
export const useUserStats = (params: { type: "STRESS" | "PARONYM"; period?: number }) => {
  const { data, isLoading, error, refetch } = trpc.GetUserStats.useQuery(params, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
    onError: (error) => {
      console.error("Failed to fetch user stats:", error);
    }
  });

  return {
    stats: data as StatsData | undefined,
    isLoading,
    error,
    refetch
  };
};

const PracticeStats: React.FC<PracticeStatsProps> = ({ type, period, onPeriodChange }) => {
  // Получаем статистику с помощью хука
  const { stats, isLoading } = useUserStats({ type, period });

  // Функция для изменения периода
  const handlePeriodChange = (newPeriod?: number) => {
    if (onPeriodChange) {
      onPeriodChange(newPeriod);
    }
  };

  return (
    <div>
      {/* Заголовок статистики */}
      <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">
        Статистика
      </h2>

      {/* Селектор периода */}
      <div className="mb-4 flex space-x-2">
        <button
          onClick={() => handlePeriodChange(undefined)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === undefined ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          Все время
        </button>
        <button
          onClick={() => handlePeriodChange(7)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 7 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          7 дней
        </button>
        <button
          onClick={() => handlePeriodChange(30)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 30 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          30 дней
        </button>
      </div>

      {isLoading ? (
        // Показываем индикатор загрузки, пока данные загружаются
        <div className="flex justify-center py-8">
          <Loader />
        </div>
      ) : stats ? (
        // Показываем статистику, когда данные загружены
        <>
          {/* Основная статистика */}
          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Всего попыток</p>
                <p className="text-xl font-semibold text-slate-800">
                  {stats.summary.totalAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Правильных</p>
                <p className="text-xl font-semibold text-emerald-600">
                  {stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Неправильных</p>
                <p className="text-xl font-semibold text-amber-600">
                  {stats.summary.totalAttempts - stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Точность</p>
                <p className="text-xl font-semibold text-indigo-600">
                  {Math.round(stats.summary.correctRate * 100)}%
                </p>
              </div>
            </div>
          </div>
          
          {/* Прогресс-бар точности */}
          <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
            <h3 className="text-md font-semibold mb-2 text-slate-700">Точность ответов</h3>
            <div className="w-full bg-slate-100 rounded-full h-4">
              <div 
                className="bg-emerald-500 h-4 rounded-full" 
                style={{ width: `${Math.round(stats.summary.correctRate * 100)}%` }}
              ></div>
            </div>
            <p className="text-right text-sm text-slate-600 mt-1">
              {Math.round(stats.summary.correctRate * 100)}%
            </p>
          </div>
          
          {/* Статистика за последние 7 дней (если доступна) */}
          {stats.summary.recentStats && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">Последние 7 дней</h3>
              <div className="grid grid-cols-2 gap-3">
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">Попыток</p>
                  <p className="text-lg font-semibold text-slate-800">
                    {stats.summary.recentStats.totalAttempts}
                  </p>
                </div>
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">Правильных</p>
                  <p className="text-lg font-semibold text-emerald-600">
                    {stats.summary.recentStats.correctAttempts}
                  </p>
                </div>
              </div>
              <div className="mt-2 w-full bg-slate-100 rounded-full h-3">
                <div 
                  className="bg-indigo-500 h-3 rounded-full" 
                  style={{ 
                    width: `${stats.summary.recentStats.totalAttempts > 0 
                      ? Math.round((stats.summary.recentStats.correctAttempts / stats.summary.recentStats.totalAttempts) * 100) 
                      : 0}%` 
                  }}
                ></div>
              </div>
            </div>
          )}
          
          {/* Ежедневная статистика (последние 7 дней) */}
          {stats.dailyStats.length > 0 && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">Ежедневная статистика</h3>
              <div className="space-y-2">
                {stats.dailyStats
                  .slice(0, 7) // Показываем только последние 7 дней
                  .map((day, i) => (
                    <div key={i} className="flex items-center">
                      <span className="text-xs text-slate-500 w-20">{new Date(day.date).toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' })}</span>
                      <div className="flex-1 ml-2">
                        <div className="w-full bg-slate-100 rounded-full h-3">
                          <div 
                            className="bg-emerald-500 h-3 rounded-full" 
                            style={{ width: `${Math.round(day.rate * 100)}%` }}
                          ></div>
                        </div>
                      </div>
                      <span className="text-xs font-medium ml-2 w-12 text-right">
                        {day.correct}/{day.total}
                      </span>
                    </div>
                  ))}
              </div>
            </div>
          )}
          
          {/* Проблемные слова */}
          {stats.problemWords.length > 0 && (
            <div className="mb-6">
              <h3 className="text-md font-semibold mb-2 text-slate-700">Сложные слова</h3>
              <ul className="bg-white rounded-xl shadow-sm divide-y divide-slate-100">
                {stats.problemWords.map((word, i) => (
                  <li key={i} className="py-2 px-3 flex justify-between items-center">
                    <span className="text-slate-700">{word.word}</span>
                    <div className="flex items-center">
                      <span className="text-xs text-slate-500 mr-2">
                        {word.correct}/{word.total}
                      </span>
                      <span className="px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-700">
                        {Math.round((word.correct / word.total) * 100)}%
                      </span>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </>
      ) : (
        // Если данных нет
        <div className="text-center py-8 text-slate-500">
          Нет данных о практике
        </div>
      )}
    </div>
  );
};

export default PracticeStats;
</file>

<file path="frontend/src/components/svg/svgNative.tsx">
import React, { SVGProps } from "react";

export const SymbolLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-6 w-6 mr-2"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
      />
    </svg>
  );
};

export const StressLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"
      />
    </svg>
  );
};

export const ParonymsLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
      />
    </svg>
  );
};

export const SignInLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"
      />
    </svg>
  );
};


export function LogoutIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" {...props}>{/* Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ */}<path fill="currentColor" d="M14.945 1.25c-1.367 0-2.47 0-3.337.117c-.9.12-1.658.38-2.26.981c-.524.525-.79 1.17-.929 1.928c-.135.737-.161 1.638-.167 2.72a.75.75 0 0 0 1.5.008c.006-1.093.034-1.868.142-2.457c.105-.566.272-.895.515-1.138c.277-.277.666-.457 1.4-.556c.755-.101 1.756-.103 3.191-.103h1c1.436 0 2.437.002 3.192.103c.734.099 1.122.28 1.4.556c.276.277.456.665.555 1.4c.102.754.103 1.756.103 3.191v8c0 1.435-.001 2.436-.103 3.192c-.099.734-.279 1.122-.556 1.399s-.665.457-1.399.556c-.755.101-1.756.103-3.192.103h-1c-1.435 0-2.436-.002-3.192-.103c-.733-.099-1.122-.28-1.399-.556c-.243-.244-.41-.572-.515-1.138c-.108-.589-.136-1.364-.142-2.457a.75.75 0 1 0-1.5.008c.006 1.082.032 1.983.167 2.72c.14.758.405 1.403.93 1.928c.601.602 1.36.86 2.26.982c.866.116 1.969.116 3.336.116h1.11c1.368 0 2.47 0 3.337-.116c.9-.122 1.658-.38 2.26-.982s.86-1.36.982-2.26c.116-.867.116-1.97.116-3.337v-8.11c0-1.367 0-2.47-.116-3.337c-.121-.9-.38-1.658-.982-2.26s-1.36-.86-2.26-.981c-.867-.117-1.97-.117-3.337-.117z"></path><path fill="currentColor" d="M15 11.25a.75.75 0 0 1 0 1.5H4.027l1.961 1.68a.75.75 0 1 1-.976 1.14l-3.5-3a.75.75 0 0 1 0-1.14l3.5-3a.75.75 0 1 1 .976 1.14l-1.96 1.68z"></path></svg>
  )
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="frontend/src/pages/LogOutPage/index.tsx">
import Cookies from "js-cookie";
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { GetStressPractice } from "../../utils/routes";
import React from "react";

export const LogOutPage = () => {
  const navigate = useNavigate();
  const trpcUtils = trpc.useContext();
  useEffect(() => {
    Cookies.remove("token");
    void trpcUtils.invalidate().then(() => {
      navigate(GetStressPractice());
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return <Loader size={"45"} speed={"0.7"} color={"blue"} />;
};
</file>

<file path="frontend/src/pages/PersonalDictionaryPage/index.tsx">
import React, { useState } from 'react';
import { Tab } from '@headlessui/react';
import trpc from '../../utils/trpc';
import { Loader } from '../../components/Loader';
import PersonalDictionaryButton from '../../components/PersonalDictionaryButton';
import { PracticeType, PersonalDictionaryWord, PersonalDictionaryParonym } from '../../types/practice';
import { useMe } from '../../utils/ctx';
import { Link } from 'react-router-dom';
import { GetStressPractice, GetParonymsPractice } from '../../utils/routes';

const PersonalDictionaryPage: React.FC = () => {
  const [selectedTab, setSelectedTab] = useState(0);
  const me = useMe();
  
  // Получаем слова с ударениями из личного словарика
  const { 
    data: stressData, 
    isLoading: isLoadingStress,
    refetch: refetchStressData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.STRESS },
    { 
      enabled: selectedTab === 0 && !!me,
      onError: (error) => {
        console.error("Ошибка при загрузке слов:", error);
      }
    }
  );
  
  // Получаем паронимы из личного словарика
  const { 
    data: paronymsData, 
    isLoading: isLoadingParonyms,
    refetch: refetchParonymsData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.PARONYM },
    { 
      enabled: selectedTab === 1 && !!me,
      onError: (error) => {
        console.error("Ошибка при загрузке паронимов:", error);
      }
    }
  );
  
  // Обработчик удаления элемента из словаря
  const handleToggle = (isPersonal: boolean) => {
    if (selectedTab === 0) {
      refetchStressData();
    } else {
      refetchParonymsData();
    }
  };
  
  // Функция для отображения слова с ударением
  const renderWordWithStress = (word: string, accentIdx: number) => {
    return (
      <>
        {word.substring(0, accentIdx)}
        <span className="text-indigo-600 font-bold">
          {word.charAt(accentIdx)}
        </span>
        {word.substring(accentIdx + 1)}
      </>
    );
  };
  
  // Если пользователь не авторизован
  if (!me) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
        <div className="max-w-4xl mx-auto text-center py-12 bg-white rounded-xl shadow-sm">
          <h1 className="text-3xl font-bold mb-6 text-slate-800">
            Личный словарик
          </h1>
          <p className="text-slate-500 mb-6">
            Для доступа к личному словарику необходимо авторизоваться.
          </p>
          <button
            className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
            onClick={() => window.location.href = "/auth/login"}
          >
            Войти
          </button>
        </div>
      </div>
    );
  }
  
  // Функция для создания URL с параметром source=dictionary
  const getPracticeUrlWithDictionarySource = (baseUrl: string) => {
    return `${baseUrl}?source=dictionary`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-6 text-slate-800">
          Личный словарик
        </h1>
        
        <Tab.Group onChange={setSelectedTab}>
          <Tab.List className="flex space-x-1 rounded-xl bg-white p-1 mb-6 shadow-sm">
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Ударения
            </Tab>
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Паронимы
            </Tab>
          </Tab.List>
          
          <Tab.Panels>
            {/* Панель с ударениями */}
            <Tab.Panel>
              {isLoadingStress ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : stressData?.words && stressData.words.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetStressPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Практиковать слова из словаря
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {stressData.words.map((word) => (
                        <li key={word.id} className="p-4 flex justify-between items-center">
                          <div>
                            <p className="text-lg font-medium text-slate-800">
                              {renderWordWithStress(word.word, word.accentIdx)}
                            </p>
                            {word.history.length > 0 && (
                              <p className="text-xs text-slate-500 mt-1">
                                Последняя практика: {new Date(word.history[0].date).toLocaleDateString()}
                                {word.history[0].correct ? ' ✓' : ' ✗'}
                              </p>
                            )}
                          </div>
                          <PersonalDictionaryButton
                            type={PracticeType.STRESS}
                            id={word.id}
                            initialIsPersonal={true}
                            onToggle={handleToggle}
                          />
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    В вашем личном словарике пока нет слов с ударениями.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    Добавьте слова из практики, нажав на иконку закладки.
                  </p>
                  <Link 
                    to={GetStressPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Перейти к практике ударений
                  </Link>
                </div>
              )}
            </Tab.Panel>
            
            {/* Панель с паронимами */}
            <Tab.Panel>
              {isLoadingParonyms ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : paronymsData?.paronyms && paronymsData.paronyms.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetParonymsPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Практиковать паронимы из словаря
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {paronymsData.paronyms.map((pair) => (
                        <li key={pair.id} className="p-4">
                          <div className="flex justify-between items-start">
                            <div>
                              <p className="text-lg font-medium text-slate-800">
                                {pair.group.join(' / ')}
                              </p>
                            </div>
                            <PersonalDictionaryButton
                              type={PracticeType.PARONYM}
                              id={pair.id}
                              initialIsPersonal={true}
                              onToggle={handleToggle}
                            />
                          </div>
                          <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                            {pair.paronyms.map((paronym) => (
                              <div key={paronym.id} className="bg-slate-50 p-3 rounded-lg">
                                <p className="font-medium text-indigo-700">{paronym.word}</p>
                                <p className="text-sm text-slate-600 mt-1">{paronym.explanation}</p>
                              </div>
                            ))}
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    В вашем личном словарике пока нет паронимов.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    Добавьте паронимы из практики, нажав на иконку закладки.
                  </p>
                  <Link 
                    to={GetParonymsPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Перейти к практике паронимов
                  </Link>
                </div>
              )}
            </Tab.Panel>
          </Tab.Panels>
        </Tab.Group>
      </div>
    </div>
  );
};

export default PersonalDictionaryPage;
</file>

<file path="frontend/src/types/practice.ts">
export enum PracticeType {
  STRESS = 'STRESS',
  PARONYM = 'PARONYM'
}

// Типы для личного словаря
export interface PersonalDictionaryWord {
  id: number;
  word: string;
  accentIdx: number;
  history: {
    correct: boolean;
    date: string;
  }[];
}

export interface PersonalDictionaryParonym {
  id: number;
  group: string[];
  paronyms: {
    id: number;
    word: string;
    explanation: string;
  }[];
}

export interface PersonalDictionaryResponse {
  words?: PersonalDictionaryWord[];
  paronyms?: PersonalDictionaryParonym[];
}
</file>

<file path="frontend/src/types/types.d.ts">
declare module '*.css'
</file>

<file path="frontend/src/utils/ctx.tsx">
import type { TrpcRouterOutput } from "@russian-stress-practice/backend/src/router";
import React, { createContext, useContext } from "react";
import trpc from "./trpc";
import { Loader } from "../components/Loader";

export type AppContext = {
  me: TrpcRouterOutput["GetMe"]["me"];
};

const AppReactContext = createContext<AppContext>({
  me: null,
});

export const AppContextProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const { data, error, isLoading, isFetching, isError } = trpc.GetMe.useQuery();
  return (
    <AppReactContext.Provider
      value={{
        me: data?.me || null,
      }}
    >
      {isLoading || isFetching ? (
        <Loader size="45px" speed="1.2s" color="rgb(67, 73, 233)" />
      ) : isError ? (
        <p>Error: {error?.message}</p>
      ) : (
        children
      )}
    </AppReactContext.Provider>
  );
};

export const useAppContext = () => {
  return useContext(AppReactContext);
};

export const useMe = () => {
  const { me } = useAppContext();
  return me;
};
</file>

<file path="frontend/src/utils/googleAuth.ts">
import { useGoogleLogin } from '@react-oauth/google';
import trpc from '../utils/trpc';
import { useQueryClient } from '@tanstack/react-query';
import Cookies from 'js-cookie';

interface GoogleCredentials {
  email: string;
  name?: string;
  providerId: string;
  accessToken: string;
  refreshToken?: string;
  tokenExpires?: string;
}

/**
 * Кастомный хук для Google OAuth: переводим хук мутации наружу
 */
export function useGoogleAuth() {
  const { mutateAsync } = trpc.GetAuth.useMutation();
  const queryClient = useQueryClient();

  return useGoogleLogin({
    flow: 'implicit',
    scope: 'openid email profile',
    onSuccess: async (tokenResponse) => {
      try {
        const userInfo = await fetch(
          'https://www.googleapis.com/oauth2/v3/userinfo',
          { 
            headers: { Authorization: `Bearer ${tokenResponse.access_token}` },
            mode: 'cors'
          }
        ).then(res => res.json());

        const creds: GoogleCredentials = {
          email: userInfo.email,
          name: userInfo.name,
          providerId: userInfo.sub,
          accessToken: tokenResponse.access_token,
          refreshToken: tokenResponse.access_token,
          tokenExpires: new Date(Date.now() + tokenResponse.expires_in * 1000).toISOString(),
        };

        const result = await mutateAsync({
          provider: 'GOOGLE',
          credentials: creds,
        });
        
        console.log('Authentication result:', result);
        
        // Сохраняем JWT токен, полученный от нашего бэкенда
        if (result.token) {
          Cookies.set('token', result.token);
          console.log('Token saved to cookies:', result.token.substring(0, 20) + '...');
        } else {
          console.error('No token received from backend');
        }
        
        queryClient.invalidateQueries(['GetMe']);
        window.location.reload()
      } catch (error) {
        console.error('Ошибка Google OAuth:', error);
      }
    },
    onError: (error) => {
      console.error('Не удалось войти через Google:', error);
    },
  });
}
</file>

<file path="frontend/src/utils/pumpGetRoute.ts">
import { useParams as useReactRouterParams } from "react-router-dom";

const baseUrl = process.env.VITE_WEBAPP_URL || process.env.WEBAPP_URL;

type PumpedGetRouteInputBase = {
  abs?: boolean;
};

function pumpGetRoute<T extends Record<string, boolean>>(
  routeParamsDefinition: T,
  getRoute: (routeParams: Record<keyof T, string>) => string,
): {
  (routeParams: Record<keyof T, string> & PumpedGetRouteInputBase): string;
  placeholders: Record<keyof T, string>;
  useParams: () => Record<keyof T, string>;
  definition: string;
};

function pumpGetRoute(getRoute: () => string): {
  (routeParams?: PumpedGetRouteInputBase): string;
  placeholders: {};
  useParams: () => {};
  definition: string;
};

function pumpGetRoute(routeParamsOrGetRoute?: any, maybeGetRoute?: any) {
  const routeParamsDefinition =
    typeof routeParamsOrGetRoute === "function" ? {} : routeParamsOrGetRoute;
  const getRoute =
    typeof routeParamsOrGetRoute === "function"
      ? routeParamsOrGetRoute
      : maybeGetRoute;
  const placeholders = Object.keys(routeParamsDefinition).reduce(
    (acc, key) => ({ ...acc, [key]: `:${key}` }),
    {},
  );
  const definition = getRoute(placeholders);
  const pumpedGetRoute = (routeParams?: PumpedGetRouteInputBase) => {
    const route = getRoute(routeParams);
    if (routeParams?.abs) {
      return `${baseUrl}${route}`;
    } else {
      return route;
    }
  };
  pumpedGetRoute.placeholders = placeholders;
  pumpedGetRoute.definition = definition;
  pumpedGetRoute.useParams = useReactRouterParams as any;
  return pumpedGetRoute;
}

export type RouteParams<T extends { placeholders: Record<string, string> }> =
  T["placeholders"];

export const pgr = pumpGetRoute;
</file>

<file path="frontend/src/utils/statsContext.tsx">
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface StatsContextType {
  isStatsVisible: boolean;
  toggleStats: () => void;
}

const StatsContext = createContext<StatsContextType | undefined>(undefined);

export function StatsProvider({ children }: { children: ReactNode }) {
  const [isStatsVisible, setIsStatsVisible] = useState(false);

  const toggleStats = () => {
    setIsStatsVisible(prev => !prev);
  };

  return (
    <StatsContext.Provider value={{ isStatsVisible, toggleStats }}>
      {children}
    </StatsContext.Provider>
  );
}

export function useStats() {
  const context = useContext(StatsContext);
  if (context === undefined) {
    throw new Error('useStats must be used within a StatsProvider');
  }
  return context;
}
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    passWithNoTests: true,
    verbose: true,
    prettierPath: null,
  }
</file>

<file path="shared/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix
  - prettier --loglevel warn --cache --write
"*.{json,yml,scss}": prettier --loglevel warn --cache --write
</file>

<file path="shared/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.js'),
  }
</file>

<file path="shared/package.json">
{
  "name": "@russian-stress-practice/shared",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --ext .ts .",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "test": "jest"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/lodash": "^4.17.15"
  }
}
</file>

<file path="shared/src/getKeysAsArray.ts">
import lodashKeys from 'lodash/keys'

// https://catchts.com/union-array
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type UnionToOvlds<U> = UnionToIntersection<U extends any ? (f: U) => void : never>
type PopUnion<U> = UnionToOvlds<U> extends (a: infer A) => void ? A : never
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true
type UnionToArray<T, A extends unknown[] = []> = IsUnion<T> extends true
  ? UnionToArray<Exclude<T, PopUnion<T>>, [PopUnion<T>, ...A]>
  : [T, ...A]

export const getKeysAsArray = <T>(obj: T): UnionToArray<keyof T> => {
  return lodashKeys(obj) as UnionToArray<keyof T>
}
</file>

<file path="shared/src/omit.ts">
import lodashOmit from 'lodash/omit'

export const omit = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Omit<TObject, TKeys> => {
  return lodashOmit(obj, keys)
}
</file>

<file path="shared/src/pick.ts">
import lodashPick from 'lodash/pick'

export const pick = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Pick<TObject, TKeys> => {
  return lodashPick(obj, keys)
}
</file>

<file path="shared/src/tryCatch.ts">
type Success<T> = {
    data: T;
    error: null;
  };
  
  type Failure<E> = {
    data: null;
    error: E;
  };
  
  type Result<T, E = Error> = Success<T> | Failure<E>;
  
  export async function tryCatch<T, E = Error>(
    promise: Promise<T>,
  ): Promise<Result<T, E>> {
    try {
      const data = await promise;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error as E };
    }
}
</file>

<file path="shared/src/zod.ts">
import { z } from "zod";

export const zEnvNonemptyTrimmed = z.string().trim().min(1);
export default zEnvNonemptyTrimmed;
export const zEnvNonemptyTrimmedRequiredOnNotLocal = zEnvNonemptyTrimmed
  .optional()
  .refine(
    // eslint-disable-next-line node/no-process-env
    (val) => `${process.env.HOST_ENV}` === "local" || !!val,
    "Required on not local host",
  );
export const zEnvHost = z.enum(["local", "production"]);

export const zStringRequired = z
  .string({ required_error: "Please, fill it" })
  .min(1, "Please, fill it");
export const zStringOptional = z.string().optional();
export const zEmailRequired = zStringRequired.email();
export const zNickRequired = zStringRequired.regex(
  /^[a-z0-9-]+$/,
  "Nick may contain only lowercase letters, numbers and dashes",
);
export const zStringMin = (min: number) =>
  zStringRequired.min(min, `Text should be at least ${min} characters long`);
export const zPasswordsMustBeTheSame =
  (passwordFieldName: string, passwordAgainFieldName: string) =>
  (val: any, ctx: z.RefinementCtx) => {
    if (val[passwordFieldName] !== val[passwordAgainFieldName]) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Passwords must be the same",
        path: [passwordAgainFieldName],
      });
    }
  };
</file>

<file path="shared/tsconfig.json">
{
  "extends": "../backend/tsconfig.json",
  "include": ["src"]
}
</file>

<file path="backend/.gitignore">
node-modules
dist
.DS_Store
.env
.env.production
</file>



export default paronymData;
</file>

<file path="backend/src/router/index.ts">
import { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { createTrpcRouter } from "../lib/trpc";
// @index('./**/index.ts', f => `import { ${f.path.split('/').slice(0, -1).pop()}TrpcRoute } from '${f.path.split('/').slice(0, -1).join('/')}'`)
import { CheckPersonalItemTrpcRoute } from './Dictionary/CheckPersonalItem'
import { GetPersonalDictionaryTrpcRoute } from './Dictionary/GetPersonalDictionary'
import { TogglePersonalParonymTrpcRoute } from './Dictionary/TogglePersonalParonym'
import { TogglePersonalWordTrpcRoute } from './Dictionary/TogglePersonalWord'
import { GetParonymsTrpcRoute } from './Practice/GetParonyms'
import { GetPracticeWordsTrpcRoute } from './Practice/GetPracticeWords'
import { GetUserStatsTrpcRoute } from './Practice/GetUserStats'
import { RecordPracticeTrpcRoute } from './Practice/RecordPractice'
import { GetAuthTrpcRoute } from './auth/GetAuth'
import { GetMeTrpcRoute } from './auth/GetMe'
// @endindex


export const trpcRouter = createTrpcRouter({
    // @index('./**/index.ts', f => `${f.path.split('/').slice(0, -1).pop()}: ${f.path.split('/').slice(0, -1).pop()}TrpcRoute,`)
    GetAuth: GetAuthTrpcRoute,
    GetMe: GetMeTrpcRoute,
    CheckPersonalItem: CheckPersonalItemTrpcRoute,
    GetPersonalDictionary: GetPersonalDictionaryTrpcRoute,
    TogglePersonalParonym: TogglePersonalParonymTrpcRoute,
    TogglePersonalWord: TogglePersonalWordTrpcRoute,
    GetParonyms: GetParonymsTrpcRoute,
    GetPracticeWords: GetPracticeWordsTrpcRoute,
    GetUserStats: GetUserStatsTrpcRoute,
    RecordPractice: RecordPracticeTrpcRoute,
    // @endindex
})


export type TrpcRouter = typeof trpcRouter;
export type TrpcRouterInput = inferRouterInputs<TrpcRouter>;
export type TrpcRouterOutput = inferRouterOutputs<TrpcRouter>;
</file>

<file path="backend/src/router/Practice/GetUserStats/index.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { format, subDays } from "date-fns";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetUserStats } from "./input";

export const GetUserStatsTrpcRoute = trpcLoggedProcedure
  .input(zGetUserStats)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type, period } = input;
    
    // Определяем период для фильтрации
    const periodDate = period 
      ? new Date(Date.now() - period * 24 * 60 * 60 * 1000)
      : undefined;

    try {
      // Общая статистика в зависимости от типа практики
      if (type === "STRESS") {
        // Получаем статистику по ударениям
        const practiceQuery = {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
          },
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getDailyStats(ctx.prisma as any, ctx.me.id, "STRESS", period);
        
        // Проблемные слова
        const problemWords = await getProblemWords(ctx.prisma as any, ctx.me.id, "STRESS");
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords,
        };
      } 
      else if (type === "PARONYM") {
        // Получаем статистику по паронимам
        const practiceQuery = {
          userId: ctx.me.id,
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.paronymPractice.count({
          where: practiceQuery,
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            ...practiceQuery,
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getParonymDailyStats(ctx.prisma as any, ctx.me.id, period);
        
        // Проблемные пары паронимов
        const problemParonyms = await getProblemParonyms(ctx.prisma as any, ctx.me.id);
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords: problemParonyms, // Используем тот же формат для совместимости
        };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Неподдерживаемый тип практики",
      });
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("Error fetching user stats:", error);
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Не удалось получить статистику",
        cause: error,
      });
    }
  });

// Типы для статистики
type DailyStats = {
  date: string;
  total: number;
  correct: number;
  rate: number;
};

type ProblemWord = {
  id: number;
  word: string;
  total: number;
  correct: number;
};

// Вспомогательная функция для получения ежедневной статистики по ударениям
async function getDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // По умолчанию 30 дней
  const startDate = subDays(new Date(), periodDays);
  
  // Получаем все попытки за указанный период
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // Группируем по дням
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Вспомогательная функция для получения проблемных слов
async function getProblemWords(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType
): Promise<ProblemWord[]> {
  // Получаем все попытки пользователя для данного типа практики
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
    },
    include: {
      word: true,
    },
  });
  
  // Группируем по словам и считаем статистику
  const wordStats = new Map<number, { word: string, total: number, correct: number }>();
  
  practices.forEach(practice => {
    const wordId = practice.wordId;
    
    if (!wordStats.has(wordId)) {
      wordStats.set(wordId, { 
        word: practice.word.word, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = wordStats.get(wordId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив и фильтруем слова с минимум 3 попытками
  const result = Array.from(wordStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.word,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(word => word.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // Сортируем по проценту правильных ответов
  
  return result.slice(0, 5); // Возвращаем топ-5 проблемных слов
}

// Вспомогательная функция для получения ежедневной статистики по паронимам
async function getParonymDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // По умолчанию 30 дней
  const startDate = subDays(new Date(), periodDays);
  
  // Получаем все попытки за указанный период
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // Группируем по дням
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Вспомогательная функция для получения проблемных пар паронимов
async function getProblemParonyms(
  prisma: PrismaClient, 
  userId: number
): Promise<ProblemWord[]> {
  // Получаем все попытки пользователя для паронимов
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
    },
    include: {
      paronymPair: {
        include: {
          words: true,
        },
      },
    },
  });
  
  // Группируем по парам паронимов и считаем статистику
  const pairStats = new Map<number, { 
    words: string, 
    total: number, 
    correct: number 
  }>();
  
  practices.forEach(practice => {
    const pairId = practice.paronymPairId;
    
    if (!pairStats.has(pairId)) {
      // Формируем строку с паронимами через "/"
      const wordString = practice.paronymPair.words.map(w => w.word).join(' / ');
      
      pairStats.set(pairId, { 
        words: wordString, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = pairStats.get(pairId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив и фильтруем пары с минимум 3 попытками
  const result = Array.from(pairStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.words,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(pair => pair.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // Сортируем по проценту правильных ответов
  
  return result.slice(0, 5); // Возвращаем топ-5 проблемных пар
}
</file>

<file path="backend/src/router/Practice/GetUserStats/input.ts">
import { z } from "zod";

export const zGetUserStats = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  period: z.number().optional(), // период в днях (7, 30, etc.)
});
</file>

<file path="backend/src/router/Practice/RecordPractice/index.ts">
import { PrismaClient, Practice, User } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zRecordPractice } from "./input";

// Определяем типы для результатов
type StressPracticeResult = {
  success: boolean;
  practice: Practice;
};

type ParonymPracticeResult = {
  success: boolean;
  paronymPractice: {
    id: number;
    userId: number;
    paronymPairId: number;
    selectedWordId: number;
    correctWordId: number;
    correct: boolean;
    createdAt: Date;
  };
};

type PracticeResult = StressPracticeResult | ParonymPracticeResult;

export const RecordPracticeTrpcRoute = trpcLoggedProcedure
  .input(zRecordPractice)
  .mutation(async ({ input, ctx }): Promise<PracticeResult> => {
    const user = ctx.me;
    
    if (!user) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }
    
    // Определяем тип практики по входным данным, если не указан явно
    const practiceType = input.type || 
      (input.wordId ? "STRESS" : input.paronymPairId ? "PARONYM" : undefined);
    
    if (!practiceType) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Не удалось определить тип практики",
      });
    }
    
    try {
      if (practiceType === "STRESS") {
        // Проверяем наличие необходимых полей для практики ударений
        if (!input.wordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Для практики ударений необходимо указать wordId",
          });
        }
        
        // Записываем результат практики ударений
        const practice = await ctx.prisma.practice.create({
          data: {
            userId: user.id,
            wordId: input.wordId,
            correct: input.correct,
          },
        });
        
        // Обновляем счет пользователя
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, practice };
      } 
      else if (practiceType === "PARONYM") {
        // Проверяем наличие необходимых полей для практики паронимов
        if (!input.paronymPairId || !input.selectedWordId || !input.correctWordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Для практики паронимов необходимо указать paronymPairId, selectedWordId и correctWordId",
          });
        }
        
        // Записываем результат практики паронимов
        const paronymPractice = await ctx.prisma.paronymPractice.create({
          data: {
            userId: user.id,
            paronymPairId: input.paronymPairId,
            selectedWordId: input.selectedWordId,
            correctWordId: input.correctWordId,
            correct: input.correct,
          },
        });
        
        // Обновляем счет пользователя
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, paronymPractice };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Неподдерживаемый тип практики",
      });
    } catch (error) {
      
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Не удалось записать результат практики",
        cause: error,
      });
    }
  });

// Вспомогательная функция для обновления счета пользователя
async function updateUserScore(
  prisma: PrismaClient, 
  userId: number, 
  correct: boolean
): Promise<User> {
  return prisma.user.update({
    where: { id: userId },
    data: {
      score: {
        increment: correct ? 1 : 0,
      },
    },
  });
}
</file>

<file path="backend/src/utils/env.ts">
/* eslint-disable no-console */
import fs from 'fs';
import path from 'path';
import {zEnvNonemptyTrimmed} from '@russian-stress-practice/shared/src/zod'
import * as dotenv from "dotenv";
import { z } from "zod";

const findFileDeep = (startDir: string, targetFilename: string): string | null => {
  const entries = fs.readdirSync(startDir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(startDir, entry.name);
    if (entry.isFile() && entry.name === targetFilename) {
      return fullPath;
    } else if (entry.isDirectory()) {
      const found = findFileDeep(fullPath, targetFilename);
      if (found) return found;
    }
  }

  return null;
};

// const prodSecretPath = "/etc/secrets/.backend.env";

// if (localSecretPath) {
//   // eslint-disable-next-line no-console
//   console.log('✅ Loading env from:', localSecretPath);
//   const result = dotenv.config({ path: localSecretPath });
//   // eslint-disable-next-line no-console
//   console.log('✅ dotenv result:', result);
//   console.log('✅ process.env.PORT:', process.env.PORT);
// } else {
//   console.warn('⚠️  No .backend.env file found!');
// }

// if (process.env.NODE_ENV === "production") {
//   const projectRoot = path.resolve(__dirname, "../../../../../");
// const localSecretPath = findFileDeep(projectRoot, ".backend.env");
//   if (localSecretPath) {
//    console.log('loaded prod local');
//   dotenv.config({ path: localSecretPath });
//   } else {
//     console.log('loaded local');
//     dotenv.config();
//   }
// } else {
//   dotenv.config();
// }
const envPath = findFileDeep(path.resolve(__dirname, "../../../"), ".env")
if (envPath) {
  dotenv.config({path: envPath})
} else {
  dotenv.config()
}
const zEnv = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().min(1),
  HOST_ENV: z.enum(['local', 'production']).default('local'),
  DEBUG: z
  .string()
  .optional()
  .refine(
    (val) => process.env.HOST_ENV === 'local' || process.env.NODE_ENV !== 'production' || (!!val && val.length > 0),
    'Required on not local host on production'
  ),
  FRONTEND_URL: zEnvNonemptyTrimmed,
  JWT_SECRET: zEnvNonemptyTrimmed
});

export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/components/Navigation.tsx">
import React, { useState, useEffect } from "react";
import { Link, useLocation } from "react-router-dom";
import Login from "./Login";
import {
  LogoutIcon,
  ParonymsLogo,
  SignInLogo,
  StressLogo,
  SymbolLogo,
} from "./svg/svgNative";
import { useMe } from "../utils/ctx";
import { useStats } from "../utils/statsContext";
import { GetLogOut, GetParonymsPractice, GetStressPractice, GetPersonalDictionary } from "../utils/routes";

export default function Navigation() {
  const location = useLocation();
  const [isLoginOpen, setIsLoginOpen] = useState(false);
  const me = useMe();
  const { toggleStats } = useStats();

  // Содержимое навигации, которое будет использоваться и вверху, и внизу
  const navigationContent = (
    <>
      <Link
        to={GetStressPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetStressPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <StressLogo />
          <span className="hidden md:inline">Ударения</span>
        </div>
      </Link>
      <Link
        to={GetParonymsPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetParonymsPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <ParonymsLogo />
          <span className="hidden md:inline">Паронимы</span>
        </div>
      </Link>
      <Link
        to={GetPersonalDictionary()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetPersonalDictionary()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-5 w-5 mr-2"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
          </svg>
          <span className="hidden md:inline">Личный словарь</span>
        </div>
      </Link>
    </>
  );

  return (
    <>
      {/* Верхняя навигация - видна только на десктопах */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10 hidden md:block">
        <div className="container mx-auto flex justify-between items-center">
          <div className="text-xl font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            Русский язык: Тренажеры
          </div>
          <div className="flex items-center space-x-2">
            {navigationContent}
            {me ? (
              <div className="flex items-center">
                <div className="px-4 py-2 rounded-lg bg-indigo-100 text-indigo-700 flex items-center">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-5 w-5 mr-2"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"
                      clipRule="evenodd"
                    />
                  </svg>
                  {me.name || me.email}
                  <div className="ml-3 p-1 bg-white rounded-lg">
                    <Link to={GetLogOut()}>
                      <button
                        className="px-3 py-1 rounded-md bg-red-100 text-red-700 hover:bg-red-200 transition-colors duration-200 flex items-center"
                      >
                        <LogoutIcon />
                      </button>
                    </Link>
                  </div>
                </div>
              </div>
            ) : (
              <div className="flex">
                <button
                  onClick={() => setIsLoginOpen(true)}
                  className="ml-4 px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors duration-200 flex items-center"
                >
                  <SignInLogo />
                  Войти
                </button>
              </div>
            )}
          </div>
        </div>
      </nav>

      {/* Верхняя мини-навигация для мобильных - только заголовок и кнопка статистики */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-3 px-4 sticky top-0 z-10 md:hidden">
        <div className="flex justify-between items-center">
          <div className="text-lg font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            <span className="ml-1">Тренажеры</span>
          </div>
          <button 
            id="stats-toggle-button"
            onClick={toggleStats}
            className="p-2 rounded-lg bg-slate-100 text-slate-700"
            aria-label="Показать статистику"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
          </button>
        </div>
      </nav>

      {/* Нижняя навигация - видна только на мобильных */}
      <nav className="bg-white shadow-lg border-t border-slate-200 text-slate-700 py-2 px-4 fixed bottom-0 left-0 right-0 z-10 md:hidden">
        <div className="flex justify-around items-center">
          {navigationContent}
          {me ? (
            <Link to={GetLogOut()} className="px-3 py-2 rounded-lg text-red-600">
              <LogoutIcon />
            </Link>
          ) : (
            <button
              onClick={() => setIsLoginOpen(true)}
              className="px-3 py-2 rounded-lg text-indigo-600"
            >
              <SignInLogo />
            </button>
          )}
        </div>
      </nav>

      <Login isOpen={isLoginOpen} onClose={() => setIsLoginOpen(false)} />
    </>
  );
}
</file>

<file path="frontend/src/components/PersonalDictionaryButton/index.tsx">
import React, { useState, useEffect } from "react";
import { BookmarkIcon as BookmarkOutlineIcon } from "@heroicons/react/24/outline";
import { BookmarkIcon as BookmarkSolidIcon } from "@heroicons/react/24/solid";
import trpc from "../../utils/trpc";

interface PersonalDictionaryButtonProps {
  type: "STRESS" | "PARONYM";
  id: number | undefined;
  initialIsPersonal?: boolean;
  onToggle?: (isPersonal: boolean) => void;
}

const PersonalDictionaryButton: React.FC<PersonalDictionaryButtonProps> = ({
  type,
  id,
  initialIsPersonal,
  onToggle,
}) => {
  const [isPersonal, setIsPersonal] = useState(initialIsPersonal || false);
  const utils = trpc.useUtils(); // Получаем utils один раз на уровне компонента

  // Проверяем, находится ли элемент в личном словарике
  const { data: checkResult } = trpc.CheckPersonalItem.useQuery(
    { type, id: id! },
    { enabled: id !== undefined && initialIsPersonal === undefined }
  );

  // Обновляем состояние, когда получаем результат проверки
  useEffect(() => {
    if (checkResult) {
      setIsPersonal(checkResult.isPersonal);
    }
  }, [checkResult]);

  // Мутации для добавления/удаления из личного словарика
  const togglePersonalWord = trpc.TogglePersonalWord.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // Инвалидируем кеш для обновления списка личного словарика
      utils.GetPersonalDictionary.invalidate();
      utils.CheckPersonalItem.invalidate();
    },
  });

  const togglePersonalParonym = trpc.TogglePersonalParonym.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // Инвалидируем кеш для обновления списка личного словарика
      utils.GetPersonalDictionary.invalidate();
      utils.CheckPersonalItem.invalidate();
    },
  });

  const handleToggle = () => {
    if (!id) return;
    if (type === "STRESS") {
      togglePersonalWord.mutate({
        wordId: id,
        isPersonal: !isPersonal,
      });
    } else if (type === "PARONYM") {
      togglePersonalParonym.mutate({
        paronymPairId: id,
        isPersonal: !isPersonal,
      });
    }
  };

  return (
    <>
      <button
        onClick={handleToggle}
        className="p-2 rounded-full hover:bg-slate-100 transition-colors"
        title={
          isPersonal
            ? "Удалить из личного словарика"
            : "Добавить в личный словарик"
        }
      >
        {isPersonal ? (
          <BookmarkSolidIcon className="h-5 w-5 text-indigo-600" />
        ) : (
          <BookmarkOutlineIcon className="h-5 w-5 text-slate-500" />
        )}
      </button>
    </>
  );
};

export default PersonalDictionaryButton;
</file>

<file path="frontend/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { GoogleOAuthProvider } from "@react-oauth/google";
import { env } from "./utils/env";
import "./index.css";

const rootElement = document.getElementById("root");
if (rootElement) {
  ReactDOM.createRoot(rootElement).render(
    <GoogleOAuthProvider clientId={env.VITE_GOOGLE_CLIENT_ID}>
      <React.StrictMode>
        <App />
      </React.StrictMode>
    </GoogleOAuthProvider>
  );
} else {
  console.error("Root element not found");
}
</file>

<file path="frontend/src/pages/ParonymsPage/ParonymsInterface.tsx">
import React, { useState, useEffect } from "react";
import { shuffleArray } from "../../utils/utils";
import { Paronym, ParonymGroup } from "../../types/nodes";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface ParonymsInterfaceProps {
  paronymGroups: ParonymGroup[];
  isLoading: boolean;
  statsPeriod: number | undefined;
  setStatsPeriod: (period?: number) => void;
  recordPractice: (paronymId: number, selectedWord: string, correct: boolean) => void;
  isPersonalDictionary: boolean;
}

export default function ParonymsInterface({
  paronymGroups,
  isLoading,
  statsPeriod,
  setStatsPeriod,
  recordPractice,
  isPersonalDictionary,
}: ParonymsInterfaceProps) {
  // Получаем состояние видимости статистики
  const { isStatsVisible } = useStats();

  // State for the current paronym group being practiced
  const [currentParonymGroup, setCurrentParonymGroup] = useState<ParonymGroup | null>(null);

  // State to track the user's selected paronym
  const [selectedParonym, setSelectedParonym] = useState<string | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to track if all paronyms are completed
  const [allCompleted, setAllCompleted] = useState(false);

  // Add state to track the correct word for the current task
  const [correctWord, setCorrectWord] = useState<string | null>(null);

  // Load a random paronym group
  const loadRandomParonymGroup = () => {
    if (paronymGroups.length === 0) {
      setCurrentParonymGroup(null);
      setAllCompleted(true);
      return;
    }

    // Get a random paronym group
    const randomIndex = Math.floor(Math.random() * paronymGroups.length);
    const randomGroup = paronymGroups[randomIndex];

    // Shuffle the paronyms in the group
    const shuffledParonyms = shuffleArray([...randomGroup.paronyms]);
    
    // Randomly select one paronym as the correct one for this task
    const correctIndex = Math.floor(Math.random() * shuffledParonyms.length);
    const correctParonym = shuffledParonyms[correctIndex];
    
    // Create a task from the selected paronym's explanation
    const task = `Выберите слово, соответствующее описанию: ${correctParonym.explanation}`;
    
    // Store the correct word for this task
    setCorrectWord(correctParonym.word);
    
    setCurrentParonymGroup({
      ...randomGroup,
      context: task,
      paronyms: shuffledParonyms,
    });
    
    setSelectedParonym(null);
    setFeedback("");
  };

  // Handle user selecting a paronym
  const handleSelect = (paronym: Paronym) => {
    // Only allow selection if no feedback is currently shown
    if (feedback) return;

    // Guard against no current paronym group or no correct word
    if (!currentParonymGroup || !correctWord) return;

    setSelectedParonym(paronym.word);

    // Check if the selected paronym is correct
    const isCorrect = paronym.word === correctWord;
    
    // Find the correct paronym object
    const correctParonymObj = currentParonymGroup.paronyms.find(p => p.word === correctWord);
    
    if (!correctParonymObj) {
      console.error("Не удалось найти правильный пароним");
      return;
    }

    // Record practice attempt to backend with both selected word and correct word
    if (currentParonymGroup.id) {
      recordPractice(
        currentParonymGroup.id, 
        correctParonymObj.word, // Передаем слово правильного паронима
        isCorrect
      );
    }

    if (isCorrect) {
      setFeedback("✅ Правильно! " + paronym.explanation);
    } else {
      // Find the correct paronym for the explanation
      const correctParonym = currentParonymGroup.paronyms.find(p => p.word === correctWord);
      setFeedback(`❌ Неправильно. Правильный ответ: ${correctParonym?.word}. ${correctParonym?.explanation}`);
    }
  };

  // Load initial paronym group
  useEffect(() => {
    if (paronymGroups.length > 0 && !currentParonymGroup) {
      loadRandomParonymGroup();
    } else if (paronymGroups.length === 0 && !isLoading) {
      setAllCompleted(true);
    }
  }, [paronymGroups, isLoading]);

  // Если на мобильном устройстве открыта статистика, не показываем основной контент
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for stats - только для десктопов */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="PARONYM"
          period={statsPeriod}
          onPeriodChange={setStatsPeriod}
        />
        
        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            Вы практикуете паронимы из личного словаря
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            Тренажер паронимов
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : allCompleted ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {paronymGroups.length === 0 
                  ? (isPersonalDictionary 
                    ? "В вашем словаре нет паронимов для практики" 
                    : "Список паронимов для практики пуст")
                  : "Поздравляем!"}
              </h2>
              {paronymGroups.length === 0 ? (
                <p className="text-slate-600 mb-6">
                  {isPersonalDictionary
                    ? "Добавьте паронимы в личный словарь во время обычной практики"
                    : "Пожалуйста, обратитесь к администратору для добавления паронимов"}
                </p>
              ) : (
                <>
                  <p className="text-slate-600 mb-6">
                    Вы прошли все доступные паронимы. Хотите продолжить практику?
                  </p>
                  <button
                    onClick={loadRandomParonymGroup}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Практиковаться еще
                  </button>
                </>
              )}
            </div>
          ) : currentParonymGroup ? (
            <>
               <div className="bg-white p-4 sm:p-6 md:p-8 pt-14 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* Кнопка для личного словаря (только в обычном режиме) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.PARONYM}
                      id={currentParonymGroup.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  {currentParonymGroup.context}
                </h2>
                
                {/* Варианты паронимов */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                  {currentParonymGroup.paronyms.map((paronym) => (
                    <button
                      key={paronym.word}
                      onClick={() => handleSelect(paronym)}
                      disabled={!!feedback}
                      className={`
                        p-4 rounded-xl text-lg font-medium transition-all duration-200
                        ${!feedback ? 'hover:bg-indigo-50 hover:border-indigo-200 active:bg-indigo-100' : ''}
                        ${selectedParonym === paronym.word && paronym.word === correctWord ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        ${selectedParonym === paronym.word && paronym.word !== correctWord ? 'bg-rose-100 border-rose-300 text-rose-800' : ''}
                        ${!selectedParonym ? 'bg-white border-slate-200 text-slate-700' : ''}
                        ${feedback && paronym.word === correctWord && selectedParonym !== paronym.word ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        border-2
                      `}
                    >
                      {paronym.word}
                    </button>
                  ))}
                </div>
                
                {/* Сообщение с обратной связью */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 p-4 rounded-xl mx-auto
                    ${feedback.includes('Правильно') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg mb-2 font-medium">
                      {feedback.includes('Правильно') ? '✅ Правильно!' : '❌ Неправильно!'}
                    </p>
                    
                    {/* Объяснения всех слов в группе */}
                    <div className="mt-3 space-y-2">
                      {currentParonymGroup?.paronyms.map((paronym) => (
                        <div key={paronym.id} className={`p-2 rounded ${
                          paronym.word === correctWord 
                            ? 'bg-white border border-emerald-100' 
                            : 'bg-white border border-slate-100'
                        }`}>
                          <p className="font-medium">{paronym.word}</p>
                          <p className="text-sm">{paronym.explanation}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                {/* Кнопка для перехода к следующему паронимы */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadRandomParonymGroup}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Следующий пароним
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
} from "../../utils/utils";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface StressPracticeInterfaceProps {
  words: Word[];
  isLoading: boolean;
  statsParams: UserStatsParams;
  changeStatsPeriod: (period?: number) => void;
  recordPractice: (wordId: number, correct: boolean) => void;
  isPersonalDictionary: boolean;
  stats?: UserStats;
  isStatsLoading: boolean;
  vowels: string[];
  today: Date;
  setWords?: (updater: (prevWords: Word[]) => Word[]) => void;
}

export default function StressPracticeInterface({
  words,
  isLoading,
  statsParams,
  changeStatsPeriod,
  recordPractice,
  isPersonalDictionary,
  stats,
  isStatsLoading,
  vowels,
  today,
  setWords,
}: StressPracticeInterfaceProps) {
  // Получаем состояние видимости статистики
  const { isStatsVisible } = useStats();

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState<Word | null>(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState<number | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);
  const [isInitialWordLoadPending, setIsInitialWordLoadPending] =
    useState(false);

  // Добавим новое состояние для отслеживания пустого списка слов
  const [emptyWordsList, setEmptyWordsList] = useState(false);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter((w) => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split("") : [];

  // Load the next word to practice
  const loadNextWord = (): void => {
    const due = getDueWords(words, today);
    // console.log(
    //   "Loading next word. Due words:",
    //   due.length,
    //   "Total words:",
    //   words.length
    // );

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else if (words.length > 0) {
      // Если есть слова, но нет доступных для практики сегодня
      setCurrentWord(null);
      setAllLearned(true);
    } else {
      // Если список слов пуст
      setCurrentWord(null);
      setAllLearned(false);
    }

    setSelected(null);
    setFeedback("");
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx: number): void => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // Проверяем ответ
    const isCorrect = idx === currentWord.accentIdx;

    // Record practice attempt to backend
    if (currentWord.id) {
      recordPractice(currentWord.id, isCorrect);
    }

    if (isCorrect) {
      // Правильный ответ - показываем успех
      setFeedback("✅ Правильно!");

      // Update the word's learning metadata locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak += 1;

            // If streak reaches 4, retire the word
            if (word.correctStreak >= 4) {
              word.retired = true;
            } else {
              // Otherwise, schedule next review based on streak
              word.nextReview = computeNextReview(word.correctStreak, today);
            }
          });
        });
      }
    } else {
      // Неправильный ответ
      setFeedback("❌ Неправильно. Правильный ответ выделен.");

      // Reset the word's streak locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak = 0;
            word.wrongCount += 1;
            word.nextReview = addDays(today, 1); // Review again tomorrow
          });
        });
      }
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = (): void => {
    setShowAllWords((prev) => !prev);
  };

  // Load initial word when words are loaded
  useEffect(() => {
    if (words.length > 0 && !currentWord) {
      loadNextWord();
      setEmptyWordsList(false);
    } else if (words.length === 0 && !isLoading) {
      // Если список слов пуст, устанавливаем соответствующий флаг
      setEmptyWordsList(true);
      setAllLearned(false);
    }
  }, [words, isLoading]);

  // Если на мобильном устройстве открыта статистика, не показываем основной контент
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats - только для десктопов */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="STRESS"
          period={statsParams.period}
          onPeriodChange={changeStatsPeriod}
        />

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-4 px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? "Показать изучаемые" : "Показать все слова"}
        </button>

        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            Вы практикуете слова из личного словаря
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            Тренажер ударений
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : emptyWordsList ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {isPersonalDictionary
                  ? "В вашем словаре нет слов для практики"
                  : "Список слов для практики пуст"}
              </h2>
              <p className="text-slate-600 mb-6">
                {isPersonalDictionary
                  ? "Добавьте слова в личный словарь во время обычной практики"
                  : "Пожалуйста, обратитесь к администратору для добавления слов"}
              </p>
            </div>
          ) : allLearned ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                Поздравляем!
              </h2>
              <p className="text-slate-600 mb-6">
                Вы повторили все слова на сегодня. Возвращайтесь завтра для
                новой практики!
              </p>
              <button
                onClick={() => setAllLearned(false)}
                className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
              >
                Практиковаться еще
              </button>
            </div>
          ) : currentWord ? (
            <>
              <div className="bg-white p-4 sm:p-6 md:p-8 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* Кнопка для личного словаря (только в обычном режиме) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.STRESS}
                      id={currentWord.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  Выберите ударный слог
                </h2>
                
                {/* Адаптивный интерфейс для отображения слова */}
                <div className="w-full overflow-x-auto mb-6 sm:mb-8 py-2">
                  <div className="flex justify-center items-center space-x-1 sm:space-x-2 text-3xl sm:text-4xl md:text-5xl min-w-min mx-auto">
                    {letters.map((letter, idx) => {
                      const isVowel = vowels.includes(letter.toLowerCase());
                      const isCorrect = idx === currentWord?.accentIdx;
                      const isSelected = selected === idx;
                      const showCorrect = feedback && isCorrect;

                      return (
                        <span
                          key={idx}
                          onClick={() => handleSelect(idx)}
                          className={`
                            relative cursor-pointer px-1 sm:px-2 py-1 rounded-lg transition-all duration-200
                            ${isVowel ? 'hover:bg-slate-100 hover:transform hover:scale-110 active:bg-slate-200 active:scale-105' : 'cursor-default'}
                            ${isSelected && isCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                            ${isSelected && !isCorrect ? 'bg-rose-500 text-white' : ''}
                            ${showCorrect && !isSelected ? 'bg-emerald-500 text-white transform scale-110' : ''}
                          `}
                        >
                          {letter}
                          {isVowel && (
                            <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                          )}
                        </span>
                      );
                    })}
                  </div>
                </div>
                
                {/* Сообщение с обратной связью */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 text-center py-2 sm:py-3 px-3 sm:px-4 rounded-xl mx-auto max-w-md
                    ${feedback.includes('Правильно') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg flex items-center justify-center">
                      {feedback}
                    </p>
                  </div>
                )}
                
                {/* Кнопка для перехода к следующему слову */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadNextWord}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Следующее слово
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils/utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["тЕст", "примЕр"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("пример");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 },
      { word: "пример", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "тест1", nextReview: yesterday, retired: false },
      { word: "тест2", nextReview: today, retired: false },
      { word: "тест3", nextReview: tomorrow, retired: false },
      { word: "тест4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "тест1")).toBe(true);
    expect(result.some(w => w.word === "тест2")).toBe(true);
    expect(result.some(w => w.word === "тест3")).toBe(false);
    expect(result.some(w => w.word === "тест4")).toBe(false);
  });
});
</file>

<file path="frontend/src/utils/env.ts">
import { z } from "zod";
import zEnvNonemptyTrimmed, {zEnvHost} from '@russian-stress-practice/shared/src/zod'
 
export const zEnv = z.object({
  VITE_BACKEND_TRPC_URL: zEnvNonemptyTrimmed,
  VITE_WEBAPP_URL: zEnvNonemptyTrimmed,
  HOST_ENV: zEnvHost,
  VITE_GOOGLE_CLIENT_ID: zEnvNonemptyTrimmed,
  VITE_GOOGLE_REDIRECT_URI: zEnvNonemptyTrimmed,
  NODE_ENV: z.enum(["development", "production"]),
  VITE_PORT: zEnvNonemptyTrimmed
});

// eslint-disable-next-line no-restricted-syntax
export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/utils/routes.ts">
import { pgr } from "./pumpGetRoute";

export const GetStressPractice = pgr(() => "/");
export const GetParonymsPractice = pgr(() => "/paronyms");
export const GetLogOut = pgr(() => "/logout");
export const GetPersonalDictionary = () => "/personal-dictionary";
</file>

<file path="frontend/src/utils/trpc.tsx">
import { env } from "./env";
import React from 'react'
import { createTRPCReact } from "@trpc/react-query";
import type { TrpcRouter } from "@russian-stress-practice/backend/src/router";
import Cookies from "js-cookie";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { httpBatchLink, loggerLink } from "@trpc/react-query";
import { SuperJSON } from "superjson";

const trpc = createTRPCReact<TrpcRouter>();

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
    },
  },
});
const trpcClient = trpc.createClient({
  transformer: SuperJSON,
  links: [
    loggerLink({
      enabled: () => env.NODE_ENV === 'development',
    }),
    httpBatchLink({
      url: env.VITE_BACKEND_TRPC_URL,
      headers: () => {
        const token = Cookies.get('token');
        console.log('Using token for request:', token ? 'Token exists' : 'No token');
        return {
          ...(token && { Authorization: `Bearer ${token}` })
        };
      },
      fetch: (url, options) => {
        console.log('Making TRPC request to:', url);
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});

export const TrpcProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
};

export default trpc;
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "jsx": "react",
    "allowJs": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "../shared/src/zod.ts"]
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "frontend"
  - "backend"
  - "shared"
</file>

<file path="backend/package.json">
{
  "name": "@russian-stress-practice/backend",
  "version": "0.0.0",
  "private": "true",
  "devDependencies": {
    "@prisma/client": "^6.6.0",
    "@sentry/cli": "^2.43.0",
    "@types/cors": "^2.8.17",
    "@types/debug": "^4.1.12",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/lodash": "^4.17.15",
    "@types/node": "^22.10.7",
    "@types/passport": "^1.0.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/triple-beam": "^1.3.5",
    "@typescript-eslint/eslint-plugin": "^8.26.1",
    "@typescript-eslint/parser": "^8.26.1",
    "dotenv-cli": "^8.0.0",
    "eslint-plugin-import": "^2.31.0",
    "prisma": "^6.6.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0"
  },
  "scripts": {
    "dev": "ts-node-dev --rs --exit-child ./src/index.ts",
    "build": "rimraf ./dist && tsc --build ./tsconfig.build.json",
    "start": "NODE_ENV=production ts-node -r tsconfig-paths/register ./dist/backend/src/index.js",
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache .",
    "pmd": "prisma migrate dev",
    "pmt": "dotenv -e ./.env.test prisma migrate deploy",
    "pgc": "prisma generate",
    "test": "jest --runInBand",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "preset-db": "ts-node src/scripts/presetDB.ts",
    "preset-paronyms": "ts-node src/scripts/importParonyms.ts"
  },
  "prisma": {
    "schema": "./src/prisma/schema.prisma"
  },
  "dependencies": {
    "@russian-stress-practice/frontend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@trpc/server": "^10.45.2",
    "axios": "^1.8.4",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "cron": "^4.1.3",
    "cross-env": "^7.0.3",
    "date-fns": "^4.1.0",
    "debug": "^4.4.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "fast-glob": "^3.3.3",
    "handlebars": "^4.7.8",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "picocolors": "^1.1.1",
    "randomstring": "^1.3.1",
    "serialize-error": "^8.1.0",
    "superjson": "1.13.1",
    "triple-beam": "^1.4.1",
    "trpc-playground": "^1.0.4",
    "tsconfig-paths": "^4.2.0",
    "winston": "^3.17.0",
    "yaml": "^2.7.1",
    "zod": "^3.24.2"
  }
}
</file>

<file path="backend/src/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  name          String?
  score         Int       @default(0)
  provider      Provider  
  providerId    String    
  accessToken   String? 
  refreshToken  String?  
  tokenExpires  DateTime?
  practices     Practice[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  personalWords PersonalWord[] // Связь с личным словариком слов
  personalParonyms PersonalParonym[] // Связь с личным словариком паронимов

  @@unique([provider, providerId])
  ParonymPractice ParonymPractice[]
}

enum Provider {
  GOOGLE
  YANDEX
}

model Word {
  id          Int        @id @default(autoincrement())
  word        String
  stress      Int        // Позиция ударения
  description String?    // Описание слова (для паронимов)
  practices   Practice[]
  type        PracticeType @default(STRESS)
  paronymPairs ParonymPair[] @relation("ParonymWords")
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  personalWords PersonalWord[] // Связь с личным словариком
}

enum PracticeType {
  STRESS   
  PARONYM  
}

model Practice {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  correct   Boolean
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([wordId])
}

model ParonymPair {
  id          Int      @id @default(autoincrement())
  words       Word[]   @relation("ParonymWords")
  description String?  // Описание различия между паронимами
  practices   ParonymPractice[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  personalParonyms PersonalParonym[] // Связь с личным словариком
}

model ParonymPractice {
  id           Int         @id @default(autoincrement())
  user         User        @relation(fields: [userId], references: [id])
  userId       Int
  paronymPair  ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  selectedWordId Int       // ID выбранного слова
  correctWordId Int        // ID правильного слова
  correct      Boolean     // Правильно ли выбрано слово
  createdAt    DateTime    @default(now())

  @@index([userId])
  @@index([paronymPairId])
}

// Модель для личного словарика слов
model PersonalWord {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  createdAt DateTime @default(now())

  @@unique([userId, wordId]) // Уникальный индекс для пары пользователь-слово
  @@index([userId])
  @@index([wordId])
}

// Модель для личного словарика паронимов
model PersonalParonym {
  id            Int         @id @default(autoincrement())
  user          User        @relation(fields: [userId], references: [id])
  userId        Int
  paronymPair   ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  createdAt     DateTime    @default(now())

  @@unique([userId, paronymPairId]) // Уникальный индекс для пары пользователь-пароним
  @@index([userId])
  @@index([paronymPairId])
}
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Тренажер ударений</title>
    <meta
      http-equiv="Cross-Origin-Opener-Policy"
      content="same-origin-allow-popups"
    />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/App.tsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './pages/StressPracticePage';
import ParonymsPage from './pages/ParonymsPage';
import PersonalDictionaryPage from './pages/PersonalDictionaryPage';
import { TrpcProvider } from './utils/trpc';
import { AppContextProvider } from './utils/ctx';
import { StatsProvider } from './utils/statsContext';
import { GetLogOut, GetParonymsPractice, GetPersonalDictionary, GetStressPractice } from './utils/routes';
import { LogOutPage } from './pages/LogOutPage';
import Navigation from './components/Navigation';

export default function App() {
  return (
    <TrpcProvider>
      <AppContextProvider>
        <StatsProvider>
          <Router basename="/russian-stress-practice">
            <div className="flex flex-col min-h-screen">
              <Navigation />
              <div className="flex-grow pb-16 md:pb-0"> {/* Добавляем отступ снизу для мобильной навигации */}
                <Routes>
                  <Route path={GetStressPractice()} element={<StressPracticePage />} />
                  <Route path={GetParonymsPractice()} element={<ParonymsPage />} />
                  <Route path={GetPersonalDictionary()} element={<PersonalDictionaryPage />} />
                  <Route path={GetLogOut()} element={<LogOutPage />} />
                  <Route path="*" element={<div>404</div>} />
                </Routes>
              </div>
            </div>
          </Router>
        </StatsProvider>
      </AppContextProvider>
    </TrpcProvider>
  );
}
</file>

<file path="frontend/src/pages/ParonymsPage/index.tsx">
import React, { useEffect, useState } from "react";
import { useSearchParams } from "react-router-dom";
import ParonymsInterface from "./ParonymsInterface";
import { useStats } from "../../utils/statsContext";
import trpc from "../../utils/trpc";
import PracticeStats from "../../components/PracticeStats";

export default function ParonymsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const isPersonalDictionary = searchParams.get("personal") === "true";
  const [statsPeriod, setStatsPeriod] = useState<number | undefined>(undefined);
  
  // Получаем функции для управления видимостью статистики
  const { isStatsVisible, toggleStats } = useStats();

  // Получаем паронимы
  const { data: paronymsData, isLoading: isParonymsLoading } = trpc.GetParonyms.useQuery(
    undefined,
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // Получаем статистику
  const { data: statsData, isLoading: isStatsLoading, refetch: refetchStats } = trpc.GetUserStats.useQuery(
    { type: "PARONYM", period: statsPeriod },
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // Обработчик записи практики
  const recordPracticeMutation = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // Обновляем статистику после успешной записи практики
      refetchStats();
    },
  });

  // Обработчик ответа пользователя
  const handleRecordPractice = async (paronymId: number, selectedWord: string, isCorrect: boolean) => {
    try {
      // Получаем данные о паронимах
      const paronymPair = paronymsData?.paronyms.find(p => p.id === paronymId);
      if (!paronymPair) {
        console.error("Не удалось найти пару паронимов с ID:", paronymId);
        return;
      }
      
      // Находим ID выбранного слова
      const selectedParonym = paronymPair.paronyms.find(p => p.word === selectedWord);
      if (!selectedParonym) {
        console.error("Не удалось найти выбранное слово:", selectedWord);
        return;
      }
      
      // Находим ID правильного слова (то, которое соответствует заданию)
      // Предполагаем, что ParonymsInterface передает нам правильное значение isCorrect
      const correctParonym = paronymPair.paronyms.find(p => 
        isCorrect ? p.word === selectedWord : p.word !== selectedWord
      );
      
      if (!correctParonym) {
        console.error("Не удалось определить правильное слово");
        return;
      }
      
      await recordPracticeMutation.mutateAsync({
        type: "PARONYM",
        paronymPairId: paronymId,
        selectedWordId: selectedParonym.id,
        correctWordId: correctParonym.id,
        correct: isCorrect
      });
    } catch (error) {
      console.error("Failed to record practice:", error);
    }
  };

  // Обработчик изменения периода статистики
  const handlePeriodChange = (period?: number) => {
    setStatsPeriod(period);
  };


  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* Мобильная статистика - показывается только когда isStatsVisible=true */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">Статистика</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="PARONYM"
            period={statsPeriod}
            onPeriodChange={handlePeriodChange}
          />
        </div>
      )}
      
      {/* Main content - показывается всегда на десктопе и когда статистика скрыта на мобильных */}
      <div className={isStatsVisible ? 'hidden md:block' : ''}>
        <ParonymsInterface
          paronymGroups={(paronymsData?.paronyms || []).map(pg => ({ ...pg, context: "" }))}
          isLoading={isParonymsLoading}
          statsPeriod={statsPeriod}
          setStatsPeriod={handlePeriodChange}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/StressPracticePage/index.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  initializeWords,
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
  shuffleArray,
} from "../../utils/utils";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { PracticeType } from '../../types/practice';
import { useLocation, useNavigate } from "react-router-dom";
import StressPracticeInterface from "./StressPracticeInterface";
import { useStats } from "../../utils/statsContext";
import PracticeStats from "../../components/PracticeStats";

const vowels = ["а", "е", "ё", "и", "о", "у", "ы", "э", "ю", "я"];

// Calculate streak from history
const calculateStreak = (history: { correct: boolean; date: Date }[]) => {
  let streak = 0;
  // Count consecutive correct answers from most recent
  for (let i = 0; i < history.length; i++) {
    if (history[i].correct) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
};

// Calculate wrong count from history
const calculateWrongCount = (history: { correct: boolean; date: Date }[]) => {
  return history.filter(h => !h.correct).length;
};

export default function StressPracticePage() {
  const location = useLocation();
  const navigate = useNavigate();
  
  // Определяем, загружаем ли мы слова из личного словаря
  const params = new URLSearchParams(location.search);
  const isPersonalDictionary = params.get("source") === "dictionary";
  
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState<Word[]>([]);

  // Loading state
  const [isLoadingState, setisLoadingState] = useState(true);
  
  // Параметры для запроса статистики
  const [statsParams, setStatsParams] = useState<UserStatsParams>({
    type: "STRESS",
    period: undefined // По умолчанию без ограничения по времени
  });
  
  // Получаем функции для управления видимостью статистики
  const { isStatsVisible, toggleStats } = useStats();
  
  // Запрос статистики с бэкенда
  const { 
    data: stats, 
    isLoading: isStatsLoading, 
    refetch: refetchStats 
  } = trpc.GetUserStats.useQuery(statsParams, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
  });

  // Заменяем получение слов на запрос к бэкенду
  const { 
    data: fetchedWords, 
    isLoading: loadingWords 
  } = isPersonalDictionary
    ? trpc.GetPersonalDictionary.useQuery(
        { type: PracticeType.STRESS }, 
        { 
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch dictionary words:", error);
            setisLoadingState(false);
          }
        }
      )
    : trpc.GetPracticeWords.useQuery(
        { type: "STRESS" },
        {
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch practice words:", error);
            setisLoadingState(false);
          }
        }
      );

  // Record practice attempt
  const recordPractice = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // Обновляем статистику после успешной записи практики
      refetchStats();
    },
  });

  // Функция для изменения периода статистики
  const changeStatsPeriod = (period?: number) => {
    setStatsParams(prev => ({
      ...prev,
      period
    }));
  };

  // Обработчик записи практики
  const handleRecordPractice = (wordId: number, correct: boolean) => {
    recordPractice.mutate({
      type: "STRESS",
      wordId: wordId,
      correct: correct
    });
  };


  // Initialize words with learning metadata when fetched
  useEffect(() => {
    if (fetchedWords) {
      // Transform the fetched data to match the expected format
      const initializedWords = isPersonalDictionary
        ? (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }))
        : (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }));
      setWords(initializedWords);
      setisLoadingState(false);
    }
  }, [fetchedWords, today, isPersonalDictionary]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* Мобильная статистика - показывается только когда isStatsVisible=true на мобильных */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white fixed top-0 left-0 right-0 bottom-0 z-50 overflow-y-auto">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">Статистика</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="STRESS"
            period={statsParams.period}
            onPeriodChange={changeStatsPeriod}
          />
        </div>
      )}
      
      {/* Main content - всегда показывается, но может быть перекрыт статистикой на мобильных */}
      <div>
        <StressPracticeInterface
          words={words}
          isLoading={isLoadingState || loadingWords}
          statsParams={statsParams}
          changeStatsPeriod={changeStatsPeriod}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
          stats={stats as unknown as UserStats}
          isStatsLoading={isStatsLoading}
          vowels={vowels}
          today={today}
          setWords={setWords}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/types/nodes.ts">
export interface Word {
  id?: number;
  word: string;
  accentIdx: number;
  retired?: boolean;
  correctStreak: number;
  wrongCount: number;
  nextReview: Date;
}

export interface PracticeHistory {
  correct: boolean;
  date: Date;
}

export interface UserStatsSummary {
  totalAttempts: number;
  correctAttempts: number;
  correctRate: number;
  recentStats?: {
    totalAttempts: number;
    correctAttempts: number;
  };
}

export interface DailyStats {
  date: string;
  total: number;
  correct: number;
  rate: number;
}

export interface ProblemWord {
  word: string;
  total: number;
  correct: number;
  type: string;
}

export interface UserStats {
  summary: UserStatsSummary;
  dailyStats: DailyStats[];
  problemWords: ProblemWord[];
}

export interface UserStatsParams {
  type: 'STRESS' | 'PARONYM';
  period?: number;
}

export interface Paronym {
  word: string;
  explanation: string;
  id: number
}

export interface ParonymGroup {
  id: number;
  group: string[];
  paronyms: Paronym[];
  context: string;
}
</file>

<file path="frontend/src/utils/utils.ts">
// Define interfaces for better type safety
import {Word} from "../types/nodes"

// Date utility functions
export function addDays(d: Date, n: number): Date {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak: number, today: Date = new Date()): Date {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords: string[]): Word[] {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx !== null ? accentIdx : -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words: Word[], targetWord: Word, updateFn: (word: Word) => void): Word[] {
  //console.log("Updating word:", targetWord.word);
  
  return words.map(word => {
    if (word.id === targetWord.id) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      //console.log("Word updated:", updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review today
export function getDueWords(words: Word[], today: Date): Word[] {
  //console.log("Getting due words from", words.length, "total words");
  //console.log("Today's date:", today);
  
  // Если список слов пуст, возвращаем пустой массив
  if (!words || words.length === 0) {
    //console.log("Words list is empty");
    return [];
  }
  
  // Фильтруем слова, которые нужно повторить сегодня
  const dueWords = words.filter(word => {
    // Проверяем, что nextReview - это действительно дата
    if (!(word.nextReview instanceof Date)) {
      //console.log("Invalid nextReview date for word:", word);
      return true; // Если дата некорректна, считаем слово доступным для практики
    }
    
    const isDue = !word.retired && word.nextReview <= today;
    if (!isDue) {
      //console.log("Word not due:", word.word, "nextReview:", word.nextReview, "today:", today);
    }
    
    return isDue;
  });
  
  //console.log("Found", dueWords.length, "due words");
  return dueWords;
}

export const shuffleArray = (array: any[]) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// Форматирование даты для отображения
export function formatDate(date: Date): string {
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  // Сравниваем только даты без времени
  const isToday = date.toDateString() === today.toDateString();
  const isTomorrow = date.toDateString() === tomorrow.toDateString();
  
  if (isToday) {
    return "Сегодня";
  } else if (isTomorrow) {
    return "Завтра";
  } else {
    // Форматируем дату как "ДД.ММ.ГГГГ"
    return date.toLocaleDateString('ru-RU', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
}

// Форматирование короткой даты для графиков
export function formatShortDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('ru-RU', {
    day: 'numeric',
    month: 'numeric'
  });
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), "");
  const publicEnv = Object.entries(env).reduce((acc, [key, value]) => {
    if (key.startsWith('VITE_') || ["HOST_ENV", "NODE_ENV"].includes(key) ) {
      return {
        ...acc,
        [key]: value,
      }
    }
    return acc
  }, {})

  return {
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
      outDir: "dist",
      emptyOutDir: true,
      rollupOptions: {
        input: "./index.html",
        output: {
          entryFileNames: `assets/[name].[hash].js`,
          chunkFileNames: `assets/[name].[hash].js`,
          assetFileNames: `assets/[name].[hash].[ext]`
        }
      }
    },
    publicDir: "public",
    server: {
      open: true,
      port: +env.VITE_PORT,
    },
    preview: {
      port: +env.VITE_PORT,
    },
    define: {
      'process.env': publicEnv,
    },
  };
});
</file>

<file path="Dockerfile">
# ---------------------- BASE IMAGE ----------------------
FROM node:22-slim AS base

RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable

# ---------------------- PREPARE WORKSPACE (DEPS + SOURCE) ----------------------
FROM base AS prepare_workspace
WORKDIR /app

# Копируем манифесты воркспейса
COPY pnpm-workspace.yaml ./
COPY pnpm-lock.yaml ./
COPY package.json ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY shared/package.json ./shared/

# Копируем ВЕСЬ остальной исходный код проекта
# Убедитесь, что .dockerignore настроен правильно, чтобы не копировать лишнее (например, локальные node_modules)
COPY . .

# Устанавливаем зависимости, включая devDependencies, так как они нужны для сборки
RUN pnpm install --frozen-lockfile

# ---------------------- BUILD ----------------------
FROM prepare_workspace AS build
# WORKDIR /app уже установлен из prepare_workspace

# Копируем .env файлы, если они нужны на этапе сборки (например, VITE_* в фронте)
# Эти пути должны быть относительно контекста сборки Docker (где лежит Dockerfile)
COPY etc/secrets/.frontend.env ./frontend/.env
COPY etc/secrets/.backend.env ./backend/.env

RUN pnpm b pgc
RUN pnpm build

# ---------------------- FINAL (PRODUCTION) ----------------------
FROM node:22-slim AS prod
WORKDIR /app

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
ENV NODE_ENV=production

# Копируем package.json и pnpm-workspace.yaml для запуска через pnpm
COPY package.json pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
# Если backend имеет прямые workspace-зависимости от shared, которые не встроены в bundle:
# COPY shared/package.json ./shared/

# Копируем только production node_modules (или все, если pnpm их отфильтрует при запуске)
# и артефакты сборки
COPY --from=prepare_workspace /app/node_modules ./node_modules
COPY --from=build /app/backend/dist ./backend/dist
COPY --from=build /app/frontend/dist ./frontend/dist 
# Если фронтенд нужно раздавать с этого же сервера

# Копируем .env для runtime бэкенда
COPY etc/secrets/.backend.env ./backend/.env


HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:3000/ping || exit 1

EXPOSE 3000

CMD ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]
</file>

<file path="package.json">
{
    "name": "russian-stress-practice",
    "version": "0.0.0",
    "private": "true",
    "dependencies": {
      "@tanstack/react-query": "4",
      "@trpc/client": "^10.45.2",
      "@trpc/next": "^10.45.2",
      "@trpc/react": "^9.27.4",
      "@trpc/server": "^10.45.2",
      "cors": "^2.8.5",
      "eslint": "^9.20.1",
      "eslint-plugin-node": "^11.1.0",
      "express": "^4.21.2",
      "react-dom": "^18.3.1",
      "react-router-dom": "^7.1.5",
      "w": "^1.1.0"
    },
    "pnpm": {
      "overrides": {
        "@tanstack/react-query": "4.36.1"
      }
    },
    "scripts": {
      "b": "pnpm --filter @russian-stress-practice/backend",
      "w": "pnpm --filter @russian-stress-practice/frontend",
      "sh": "pnpm --filter @russian-stress-practice/shared",
      "dev": "pnpm -r --parallel dev",
      "types": "pnpm -r --parallel types",
      "test": "pnpm -r test",
      "build": "pnpm w build && pnpm b build"

    },
    "devDependencies": {
      "@eslint/eslintrc": "^3.3.1",
      "@types/express": "^5.0.0",
      "@types/jest": "^29.5.14",
      "@types/node": "^22.10.7",
      "@typescript-eslint/eslint-plugin": "^8.24.0",
      "@typescript-eslint/parser": "^8.24.0",
      "eslint-config-prettier": "^10.0.1",
      "eslint-config-react-app": "^7.0.1",
      "eslint-config-standard-with-typescript": "^43.0.1",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jest": "^28.11.0",
      "husky": "^8.0.0",
      "jest": "^29.7.0",
      "lint-staged": "^15.4.3",
      "node": "link:@types\\node",
      "rimraf": "^6.0.1",
      "ts-jest": "^29.3.1",
      "ts-patch": "^3.3.0",
      "typescript": "^5.7.3",
      "typescript-transform-paths": "^3.5.5"
    },
    "type": "module",
    "packageManager": "pnpm@10.11.0" 
  }
</file>

<file path=".gitignore">
node_modules
.env
*.sql
*.xml
secrets
dist
</file>

<file path="frontend/package.json">
{
  "name": "@russian-stress-practice/frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "types": "tsc --noEmit --project ./tsconfig.json && tsc --noEmit --project ./tsconfig.node.json"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.2",
    "@heroicons/react": "^2.2.0",
    "@react-oauth/google": "^0.12.1",
    "@russian-stress-practice/backend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@tanstack/react-query": "4.36.1",
    "@trpc/client": "^10.45.2",
    "@trpc/react-query": "^10.45.2",
    "@trpc/server": "^10.45.2",
    "classnames": "^2.5.1",
    "date-fns": "^4.1.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-react": "^7.37.5",
    "formik": "^2.4.6",
    "formik-validator-zod": "^2.2.0",
    "heroicons": "^2.2.0",
    "js-cookie": "^3.0.5",
    "ldrs": "^1.1.7",
    "lodash": "^4.17.21",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2",
    "serve": "^14.2.4",
    "superjson": "1.13.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/js-cookie": "^3.0.6",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

</files>
