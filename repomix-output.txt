This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
.lintstagedrc.yml
backend/.gitignore
backend/.lintstagedrc.yml
backend/eslint.config.mjs
backend/jest.config.cjs
backend/package.json
backend/src/data/paronyms.js
backend/src/data/words.js
backend/src/index.ts
backend/src/lib/ctx.ts
backend/src/lib/passport.ts
backend/src/lib/prisma.ts
backend/src/lib/trpc.ts
backend/src/prisma/migrations/migration_lock.toml
backend/src/prisma/schema.prisma
backend/src/router/auth/GetAuth/index.ts
backend/src/router/auth/GetAuth/input.ts
backend/src/router/auth/GetMe/index.ts
backend/src/router/Dictionary/CheckPersonalItem/index.ts
backend/src/router/Dictionary/CheckPersonalItem/input.ts
backend/src/router/Dictionary/GetPersonalDictionary/index.ts
backend/src/router/Dictionary/GetPersonalDictionary/input.ts
backend/src/router/Dictionary/TogglePersonalParonym/index.ts
backend/src/router/Dictionary/TogglePersonalParonym/input.ts
backend/src/router/Dictionary/TogglePersonalWord/index.ts
backend/src/router/Dictionary/TogglePersonalWord/input.ts
backend/src/router/index.ts
backend/src/router/Practice/GetParonyms/index.ts
backend/src/router/Practice/GetPracticeWords/index.ts
backend/src/router/Practice/GetPracticeWords/input.ts
backend/src/router/Practice/GetUserStats/index.ts
backend/src/router/Practice/GetUserStats/input.ts
backend/src/router/Practice/RecordPractice/index.ts
backend/src/router/Practice/RecordPractice/input.ts
backend/src/scripts/importParonyms.ts
backend/src/scripts/presetDB.ts
backend/src/utils/deepMap.ts
backend/src/utils/env.ts
backend/src/utils/error.ts
backend/src/utils/logger.ts
backend/src/utils/models.ts
backend/src/utils/types.ts
backend/tsconfig.build.json
backend/tsconfig.json
docker-compose.yml
Dockerfile
eslint.config.mjs
frontend/.env.production
frontend/.envrc
frontend/.github/workflows/deploy.yml
frontend/.gitignore
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/public/index.js
frontend/public/vite.svg
frontend/README.md
frontend/src/App.tsx
frontend/src/components/Loader/index.tsx
frontend/src/components/Login/index.tsx
frontend/src/components/Navigation.tsx
frontend/src/components/PersonalDictionaryButton/index.tsx
frontend/src/components/PracticeStats/index.tsx
frontend/src/components/svg/svgNative.tsx
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/LogOutPage/index.tsx
frontend/src/pages/ParonymsPage/index.tsx
frontend/src/pages/ParonymsPage/ParonymsInterface.tsx
frontend/src/pages/PersonalDictionaryPage/index.tsx
frontend/src/pages/StressPracticePage/index.tsx
frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx
frontend/src/types/nodes.ts
frontend/src/types/practice.ts
frontend/src/types/types.d.ts
frontend/src/utils.test.js
frontend/src/utils/ctx.tsx
frontend/src/utils/env.ts
frontend/src/utils/googleAuth.ts
frontend/src/utils/pumpGetRoute.ts
frontend/src/utils/routes.ts
frontend/src/utils/statsContext.tsx
frontend/src/utils/trpc.tsx
frontend/src/utils/utils.ts
frontend/tailwind.config.js
frontend/tsconfig.json
frontend/vite.config.ts
jest.config.cjs
package.json
pnpm-workspace.yaml
shared/.lintstagedrc.yml
shared/jest.config.js
shared/package.json
shared/src/getKeysAsArray.ts
shared/src/omit.ts
shared/src/pick.ts
shared/src/tryCatch.ts
shared/src/zod.ts
shared/tsconfig.json
tmep
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
node_modules
dist
.env*
*.env
frontend/.env*
backend/.env*
**/.turbo
**/.next
**/.cache
**/pnpm-debug.log
</file>

<file path="backend/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["**/test/**/*", "**/*.test.ts"]
}
</file>

<file path="docker-compose.yml">
version: '3.9'

services:
  db:
    image: postgres:15
    restart: unless-stopped
    container_name: postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: rupractice
      POSTGRES_PASSWORD: rupractice
      POSTGRES_DB: russian
    volumes:
      - pgdata:/var/lib/postgresql/data

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: stress-practice-app
    restart: unless-stopped
    ports:
      - "3000:3000" # backend
      - "5173:5173" # optional: frontend preview
    depends_on:
      - db
    volumes:
      - ./etc/secrets:/etc/secrets:ro
    environment:
      DATABASE_URL: postgres://rupractice:rupractice@db:5432/russian
      NODE_ENV: production
    command: ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]

volumes:
  pgdata:
</file>

<file path="frontend/.gitignore">
dist
node-modules
</file>

<file path="tmep">
# ---------------------- BASE IMAGE ----------------------
FROM node:22-slim AS base

RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable

# ---------------------- PREPARE (Install only) ----------------------
FROM base AS prepare_workspace
WORKDIR /app

COPY pnpm-workspace.yaml pnpm-lock.yaml package.json ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY shared/package.json ./shared/

RUN pnpm install --frozen-lockfile

# ---------------------- BUILD ----------------------
FROM prepare_workspace AS build
WORKDIR /app

# –ö–æ–ø–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–∏–∫–∏ –ø–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
COPY . .

# –ö–æ–ø–∏—Ä—É–µ–º .env (–µ—Å–ª–∏ VITE_* –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω—É–∂–Ω—ã –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏)
COPY etc/secrets/.frontend.env ./frontend/.env
COPY etc/secrets/.backend.env ./backend/.env

RUN pnpm build # –¥–æ–ª–∂–µ–Ω —Å–æ–±–∏—Ä–∞—Ç—å frontend –∏ backend

# ---------------------- FINAL IMAGE ----------------------
FROM node:22-slim AS prod
WORKDIR /app

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
ENV NODE_ENV=production

# –ö–æ–ø–∏—Ä—É–µ–º workspace –º–∞–Ω–∏—Ñ–µ—Å—Ç—ã
COPY package.json pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY shared/package.json ./shared/

# –ö–æ–ø–∏—Ä—É–µ–º node_modules (–∏–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∏–º –∑–∞–Ω–æ–≤–æ)
COPY --from=prepare_workspace /app/node_modules ./node_modules
COPY --from=prepare_workspace /app/backend/node_modules ./backend/node_modules
COPY --from=prepare_workspace /app/shared/node_modules ./shared/node_modules

# –ö–æ–ø–∏—Ä—É–µ–º –ø—Ä–æ–¥-—Å–±–æ—Ä–∫—É
COPY --from=build /app/backend/dist ./backend/dist
COPY --from=build /app/frontend/dist ./frontend/dist

# –ö–æ–ø–∏—Ä—É–µ–º .env –¥–ª—è backend
COPY etc/secrets/.backend.env ./backend/.env

HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:3000/ping || exit 1

EXPOSE 3000

CMD ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]
</file>

<file path=".lintstagedrc.yml">
'*.{ts,js,json,yml}': 'prettier --loglevel warn --cache --write'
</file>

<file path="backend/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix"
  - "prettier --loglevel warn --cache --write"
"*.{json,yml,scss}": "prettier --loglevel warn --cache --write"
</file>

<file path="backend/eslint.config.mjs">
import { defineConfig } from "eslint/config";
import path from 'path';
import tsParser from '@typescript-eslint/parser';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import importPlugin from 'eslint-plugin-import';

export default defineConfig([{
    files: ['**/*.ts', '**/*.tsx', '**/*.js'],
    ignores: ['jest.config.js'],
    plugins: {
        '@typescript-eslint': tsPlugin,
        'import': importPlugin
      },
    languageOptions: {
        ecmaVersion: 5,
        sourceType: "script",
        parser: tsParser,
        parserOptions: {
            project: "./tsconfig.json",
        },
    },

    settings: {
        "import/resolver": {
            node: {
                extensions: [".js", ".ts", ".tsx"],
            },
        },
    },

    rules: {
        "no-console": "error",

        "no-restricted-imports": ["error", {
        patterns: [{
          group: [
            path.join(process.cwd(), "src/test/**"),
            `!${path.join(process.cwd(), "src/**/*.integration.test.ts")}`
          ],
          message: "Import from test dir is only allowed in integration test files",
        }]
      }],

      "import/order": ["error", {
            groups: ["builtin", "external", "parent", "sibling", "index"],

            pathGroups: [{
                pattern: "{.,..}/**/env\n",
                group: "builtin",
                position: "before",
            }, {
                pattern: "{.,..}/**/test/integration\n",
                group: "builtin",
                position: "before",
            }],

            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],
    },
}]);
</file>

<file path="backend/jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.cjs'),
  }
</file>



export default rawWords;
</file>

<file path="backend/src/index.ts">
import { env } from "./utils/env";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import cors from "cors";
import express from "express";
import { AppContext, createAppContext } from "./lib/ctx";
import { applyPassportToExpressApp } from "./lib/passport";
import { ApplyTrpcToExpressApp, getCreateTrpcContext } from "./lib/trpc";
import { trpcRouter } from "./router";
import { logger } from "./utils/logger";

void (async () => {
  let ctx: AppContext | null = null;
  try {
    const app = express();
    ctx = createAppContext();
    
    app.use(
      cors({
        origin: ["http://localhost:5173"], // Explicitly allow your frontend origin
        credentials: true,
        methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowedHeaders: [
          "Content-Type",
          "Authorization",
          "x-trpc-source",
          "Access-Control-Allow-Origin",
          "Access-Control-Allow-Credentials",
        ],
      })
    );
    
    // –í–∞–∂–Ω–æ: –ø—Ä–∏–º–µ–Ω—è–µ–º Passport –¥–æ TRPC middleware
    applyPassportToExpressApp(app, ctx);
    
    await ApplyTrpcToExpressApp(app, ctx, trpcRouter);
    
    app.options("*", cors());
    app.get("/ping", (req, res) => {
      res.send("pong");
    });
    
    app.use(
      (
        error: unknown,
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        logger.error("express", error);
        if (res.headersSent) {
          next(error);
          return;
        }
        res.status(500).send("Internal server error");
      }
    );

    app.listen(env.PORT, () => {
      logger.info("app", `listening on http://localhost:${env.PORT}`);
    });
  } catch (error) {
    logger.error("app", error);
    await ctx?.stop();
  }
})();
</file>

<file path="backend/src/lib/ctx.ts">
import { createPrismaClient } from "./prisma";

export const createAppContext = () => {
  const prisma = createPrismaClient();
  return {
    prisma,
    stop: async () => {
      await prisma.$disconnect();
    },
  };
};

export type AppContext = ReturnType<typeof createAppContext>;
</file>

<file path="backend/src/lib/passport.ts">
import { env } from "../utils/env";
import { Express } from "express";
import { Passport } from "passport";
import { ExtractJwt, Strategy as JWTStrategy } from "passport-jwt";
import { logger } from "../utils/logger";
import { AppContext } from "./ctx";

export const applyPassportToExpressApp = (expressApp: Express, ctx: AppContext): void => {
  const passport = new Passport();

  // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π payload: { sub: user.id, ‚Ä¶ }
  passport.use(
    new JWTStrategy(
      {
        secretOrKey: env.JWT_SECRET,
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      },
      async (jwtPayload: any, done) => {
        try {
          logger.info("passport:jwt", "JWT payload received", { payload: jwtPayload });
          const userId = parseInt(jwtPayload.sub, 10);
          logger.info("passport:jwt", "Looking for user with ID", { userId });
          
          const user = await ctx.prisma.user.findUnique({ where: { id: userId } });
          
          if (!user) {
            logger.info("passport:jwt", "User not found", { userId });
            return done(null, false);
          }
          
          logger.info("passport:jwt", "User authenticated successfully", { userId });
          return done(null, user);
        } catch (error) {
          logger.error("passport:jwt", error);
          return done(error, false);
        }
      }
    )
  );

  expressApp.use((req, res, next) => {
    // –µ—Å–ª–∏ –Ω–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞ ‚Äì –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –¥–∞–ª—å—à–µ
    if (!req.headers.authorization) {
      logger.info("passport:middleware", "No authorization header");
      return next();
    }

    logger.info("passport:middleware", "Authorization header found", { 
      header: req.headers.authorization.substring(0, 20) + '...' 
    });

    passport.authenticate("jwt", { session: false }, (err: any, user: any) => {
      if (err) {
        logger.error("passport:middleware", err);
      }
      
      req.user = user ?? undefined;
      logger.info("passport:middleware", user ? "User attached to request" : "No user attached to request", {
        userId: user?.id
      });
      
      next();
    })(req, res, next);
  });
};
</file>

<file path="backend/src/lib/prisma.ts">
import { env } from "../utils/env";
import { PrismaClient } from "@prisma/client";
import { logger } from "../utils/logger";

export const createPrismaClient = () => {
  const prisma = new PrismaClient({
    log: [
      {
        emit: "event",
        level: "query",
      },
      {
        emit: "event",
        level: "info",
      },
    ],
  });

  prisma.$on("query", (e) => {
    logger.info("prisma:low:query", "Successfull request", {
      query: e.query,
      duration: e.duration,
      params: env.HOST_ENV === "local" ? e.params : "***",
    });
  });

  prisma.$on("info", (e) => {
    logger.info("prisma:low:info", e.message);
  });

  const extendedPrisma = prisma.$extends({
    client: {},
    query: {
      $allModels: {
        $allOperations: async ({ model, operation, args, query }) => {
          const start = Date.now();
          try {
            const result = await query(args);
            const durationMs = Date.now() - start;
            logger.info("prisma:high", "Successfull request", {
              model,
              operation,
              args,
              durationMs,
            });
            return result;
          } catch (error) {
            const durationMs = Date.now() - start;
            logger.error("prisma:high", error, {
              model,
              operation,
              args,
              durationMs,
            });
            throw error;
          }
        },
      },
    },
  });

  return extendedPrisma;
};
</file>

<file path="backend/src/lib/trpc.ts">
import { inferAsyncReturnType, initTRPC } from "@trpc/server";
import * as trpcExpress from "@trpc/server/adapters/express";
import { type Express } from "express";
import { SuperJSON } from "superjson";
import { expressHandler } from "trpc-playground/handlers/express";
import { TrpcRouter, type trpcRouter } from "../router";
// import { AppContext } from "./ctx";
import { ExpectedError } from "../utils/error";
import { logger } from "../utils/logger";
import { ExpressRequest } from "../utils/types";
import { AppContext } from "./ctx";

export const getTrpcContext = ({ appContext, req }: {appContext: AppContext, req: ExpressRequest}) => ({
  ...appContext,
  me: (req as ExpressRequest).user || null,
})


export const getCreateTrpcContext =
  (appContext: AppContext) =>
  ({ req }: trpcExpress.CreateExpressContextOptions) =>
    getTrpcContext({ appContext, req: req as ExpressRequest })

type TrpcContext = inferAsyncReturnType<
  ReturnType<typeof getCreateTrpcContext>
>;

const trpc = initTRPC.context<TrpcContext>().create({
  transformer: SuperJSON,
  errorFormatter: ({shape, error}) => {
    const orginalError = error.cause as Error
    const expected = orginalError instanceof ExpectedError
    return {
      ...shape,
      data: {
        ...shape.data,
        expected
      }
    }
  }
});

export const createTrpcRouter = trpc.router

export const trpcLoggedProcedure = trpc.procedure.use(
  trpc.middleware(async ({ path, type, next, ctx, rawInput }) => {
    const start = Date.now()
    const result = await next()
    const durationMs = Date.now() - start
    const meta = {
      path,
      type,
      userId: ctx.me?.id || null,
      durationMs,
      rawInput: rawInput || null,
    }
    if (result.ok) {
      logger.info(`trpc:${type}:success`, 'Successfull request', { ...meta, output: result.data })
    } else {
      logger.error(`trpc:${type}:error`, result.error)
    }
    return result
  })
)

export const ApplyTrpcToExpressApp = async (
  app: Express,
  ctx: AppContext,
  trpcRouter: TrpcRouter,
) => {
  app.use(
    "/trpc",
    trpcExpress.createExpressMiddleware({
      router: trpcRouter,
      createContext: getCreateTrpcContext(ctx),
    }),
  );

  app.use(
    "/trpc-playground",
    await expressHandler({
      trpcApiEndpoint: "/trpc",
      playgroundEndpoint: "/trpc-playground",
      router: trpcRouter,
      request: {
        superjson: true,
      },
    }),
  );
};
</file>

<file path="backend/src/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="backend/src/router/auth/GetAuth/index.ts">
import { Provider } from "@prisma/client";
import jwt from "jsonwebtoken"
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { env } from "../../../utils/env";
import { ExpectedError } from "../../../utils/error";
import { zOAuthLogin } from "./input";

export const GetAuthTrpcRoute = trpcLoggedProcedure
  .input(zOAuthLogin)
  .mutation(async ({ ctx, input }) => {
    const { provider, credentials } = input;

    try {
      // Try to find existing user
      const existingUser = await ctx.prisma.user.findUnique({
        where: {
          provider_providerId: {
            provider: provider as Provider,
            providerId: credentials.providerId,
          },
        },
      });

      let newOrUpdatedUser;
      
      if (existingUser) {
        // Update existing user's tokens
        newOrUpdatedUser = await ctx.prisma.user.update({
          where: { id: existingUser.id },
          data: {
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
            name: credentials.name || existingUser.name,
          },
        });
      } else {
        // Create new user
        newOrUpdatedUser = await ctx.prisma.user.create({
          data: {
            email: credentials.email,
            name: credentials.name,
            provider: provider as Provider,
            providerId: credentials.providerId,
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
          },
        });
      }
      
      const appToken = jwt.sign(
        { sub: newOrUpdatedUser.id },
        env.JWT_SECRET,
        { expiresIn: "7d" }
      );
      
      return { user: newOrUpdatedUser, token: appToken };
    } catch (error) {
      throw new ExpectedError("Failed to process authentication");
    }
  });
</file>

<file path="backend/src/router/auth/GetAuth/input.ts">
import { z } from "zod";

export const zOAuthCredentials = z.object({
  email: z.string().email(),
  name: z.string().optional(),
  providerId: z.string(),
  accessToken: z.string(),
  refreshToken: z.string().optional(),
  tokenExpires: z.string().optional().transform(val => val ? new Date(val) : undefined),
});

export const zOAuthLogin = z.object({
  provider: z.enum(['GOOGLE', 'YANDEX']),
  credentials: zOAuthCredentials,
});
</file>

<file path="backend/src/router/auth/GetMe/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { toClientMe } from "../../../utils/models";

export const GetMeTrpcRoute = trpcLoggedProcedure.query(({ ctx }) => {
  return { me: toClientMe(ctx.me) };
});
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zCheckPersonalItem } from "./input";

export const CheckPersonalItemTrpcRoute = trpcLoggedProcedure
  .input(zCheckPersonalItem)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }

    const { type, id } = input;

    if (type === "STRESS") {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–ª–æ–≤–æ –≤ –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ
      const personalWord = await ctx.prisma.personalWord.findUnique({
        where: {
          userId_wordId: {
            userId: ctx.me.id,
            wordId: id,
          },
        },
      });

      return { isPersonal: !!personalWord };
    } else if (type === "PARONYM") {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–∞—Ä–∞ –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –≤ –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ
      const personalParonym = await ctx.prisma.personalParonym.findUnique({
        where: {
          userId_paronymPairId: {
            userId: ctx.me.id,
            paronymPairId: id,
          },
        },
      });

      return { isPersonal: !!personalParonym };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø",
    });
  });
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/input.ts">
import { z } from "zod";

export const zCheckPersonalItem = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  id: z.number(),
});
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPersonalDictionary } from "./input";

export const GetPersonalDictionaryTrpcRoute = trpcLoggedProcedure
  .input(zGetPersonalDictionary)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }

    const { type } = input;

    if (type === "STRESS") {
      // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ–≤–∞ —Å —É–¥–∞—Ä–µ–Ω–∏—è–º–∏ –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
      const personalWords = await ctx.prisma.personalWord.findMany({
        where: {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
        },
        include: {
          word: {
            include: {
              practices: {
                where: {
                  userId: ctx.me.id,
                },
                orderBy: {
                  createdAt: "desc",
                },
              },
            },
          },
        },
      });

      return {
        words: personalWords.map((entry) => ({
          id: entry.word.id,
          word: entry.word.word,
          accentIdx: entry.word.stress,
          history: entry.word.practices.map((practice) => ({
            correct: practice.correct,
            date: practice.createdAt,
          })),
        })),
      };
    } else if (type === "PARONYM") {
      // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
      const personalParonyms = await ctx.prisma.personalParonym.findMany({
        where: {
          userId: ctx.me.id,
        },
        include: {
          paronymPair: {
            include: {
              words: true,
            },
          },
        },
      });

      return {
        paronyms: personalParonyms.map((entry) => ({
          id: entry.paronymPair.id,
          group: entry.paronymPair.words.map((word) => word.word),
          paronyms: entry.paronymPair.words.map((word) => ({
            id: word.id,
            word: word.word,
            explanation: word.description || "",
          })),
        })),
      };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Å–ª–æ–≤–∞—Ä–∏–∫–∞",
    });
  });
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/input.ts">
import { z } from "zod";

export const zGetPersonalDictionary = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalParonym } from "./input";

export const TogglePersonalParonymTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalParonym)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }

    const { paronymPairId, isPersonal } = input;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–∞—Ä—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤
    const paronymPair = await ctx.prisma.paronymPair.findUnique({
      where: { id: paronymPairId },
    });

    if (!paronymPair) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "–ü–∞—Ä–∞ –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
      });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —ç—Ç–∞ –ø–∞—Ä–∞ –≤ –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ
    const existingEntry = await ctx.prisma.personalParonym.findUnique({
      where: {
        userId_paronymPairId: {
          userId: ctx.me.id,
          paronymPairId: paronymPairId,
        },
      },
    });

    if (isPersonal) {
      // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ä–∏–∫ –∏ –∑–∞–ø–∏—Å–∏ –µ—â–µ –Ω–µ—Ç
      if (!existingEntry) {
        await ctx.prisma.personalParonym.create({
          data: {
            userId: ctx.me.id,
            paronymPairId: paronymPairId,
          },
        });
      }
    } else {
      // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –∏–∑ —Å–ª–æ–≤–∞—Ä–∏–∫–∞ –∏ –∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      if (existingEntry) {
        await ctx.prisma.personalParonym.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, paronymPair };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/input.ts">
import { z } from "zod";

export const zTogglePersonalParonym = z.object({
  paronymPairId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalWord } from "./input";

export const TogglePersonalWordTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalWord)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }

    const { wordId, isPersonal } = input;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Å–ª–æ–≤–∞
    const word = await ctx.prisma.word.findUnique({
      where: { id: wordId },
    });

    if (!word) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "–°–ª–æ–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
      });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ —ç—Ç–æ —Å–ª–æ–≤–æ –≤ –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ
    const existingEntry = await ctx.prisma.personalWord.findUnique({
      where: {
        userId_wordId: {
          userId: ctx.me.id,
          wordId: wordId,
        },
      },
    });

    if (isPersonal) {
      // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ä–∏–∫ –∏ –∑–∞–ø–∏—Å–∏ –µ—â–µ –Ω–µ—Ç
      if (!existingEntry) {
        await ctx.prisma.personalWord.create({
          data: {
            userId: ctx.me.id,
            wordId: wordId,
          },
        });
      }
    } else {
      // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –∏–∑ —Å–ª–æ–≤–∞—Ä–∏–∫–∞ –∏ –∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      if (existingEntry) {
        await ctx.prisma.personalWord.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, word };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/input.ts">
import { z } from "zod";

export const zTogglePersonalWord = z.object({
  wordId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Practice/GetParonyms/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";

export const GetParonymsTrpcRoute = trpcLoggedProcedure
  .query(async ({ ctx }) => {
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–∞—Ä—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    const paronymPairs = await ctx.prisma.paronymPair.findMany({
      include: {
        words: true,
      },
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç, —É–¥–æ–±–Ω—ã–π –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    const paronyms = paronymPairs.map(pair => {
      return {
        id: pair.id,
        group: pair.words.map(word => word.word),
        paronyms: pair.words.map(word => ({
          id: word.id,
          word: word.word,
          explanation: word.description || "", // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Å–ª–æ–≤–∞
        })),
      };
    });

    return { paronyms };
  });
</file>

<file path="backend/src/router/Practice/GetPracticeWords/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPracticeWords } from "./input";

export const GetPracticeWordsTrpcRoute = trpcLoggedProcedure
    .input(zGetPracticeWords)
    .query(async ({ ctx, input }) => {
        const words = await ctx.prisma.word.findMany({
            where: {
                type: input.type
            },
            select: {
                id: true,
                word: true,
                stress: true,
                practices: {
                    where: {
                        userId: ctx.me?.id
                    },
                    orderBy: {
                        createdAt: 'desc'
                    },
                    take: 10
                }
            }
        });
        
        return {
            words: words.map(word => ({
                id: word.id,
                word: word.word,
                accentIdx: word.stress,
                history: word.practices.map(practice => ({
                    correct: practice.correct,
                    date: practice.createdAt
                }))
            }))
        };
    });
</file>

<file path="backend/src/router/Practice/GetPracticeWords/input.ts">
import {z} from 'zod'

export const zGetPracticeWords = z.object({
    type: z.enum(['STRESS', 'PARONYM'])
})
</file>

<file path="backend/src/router/Practice/RecordPractice/input.ts">
import {z} from "zod"

export const zRecordPractice = z.object({
  // –û–±—â–∏–µ –ø–æ–ª—è
  correct: z.boolean(),
  
  wordId: z.number().optional(),
  
  paronymPairId: z.number().optional(),
  selectedWordId: z.number().optional(),
  correctWordId: z.number().optional(),
  
  type: z.enum(["STRESS", "PARONYM"]).optional(),
});
</file>

<file path="backend/src/scripts/importParonyms.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import paronymData from "../data/paronyms";
import { logger } from "../utils/logger";

async function importParonyms() {
  const prisma = new PrismaClient();
  logger.info("presetDB", "starting paronyms import...");
  
  try {
    // –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤
    for (const group of paronymData) {
      logger.info("presetDB", `–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≥—Ä—É–ø–ø—É: ${group.group.join(", ")}`);
      
      // –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –Ω–∞—Ö–æ–¥–∏–º —Å–ª–æ–≤–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–∞—Ä–æ–Ω–∏–º–∞
      const wordRecords = [];
      
      for (const paronym of group.paronyms) {
        // –ò—â–µ–º —Å–ª–æ–≤–æ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        let word = await prisma.word.findFirst({
          where: {
            word: paronym.word,
          },
        });
        
        // –ï—Å–ª–∏ —Å–ª–æ–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, —Å–æ–∑–¥–∞–µ–º –µ–≥–æ
        if (!word) {
          word = await prisma.word.create({
            data: {
              word: paronym.word,
              stress: 0, // –î–ª—è –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –ø–æ–∑–∏—Ü–∏—è —É–¥–∞—Ä–µ–Ω–∏—è –Ω–µ –≤–∞–∂–Ω–∞
              type: PracticeType.PARONYM,
              description: paronym.explanation // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ
            },
          });
          logger.info("presetDB", `Created new word: ${word.word} with explanation: ${paronym.explanation}`);
        } else {
          // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∏–ø —Å–ª–æ–≤–∞ –∏ –æ–ø–∏—Å–∞–Ω–∏–µ, –µ—Å–ª–∏ –æ–Ω–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
          word = await prisma.word.update({
            where: { id: word.id },
            data: { 
              type: PracticeType.PARONYM,
              description: paronym.explanation
            }
          });
        }
        
        wordRecords.push(word);
      }
      
      // –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—É –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –∏ —Å–≤—è–∑—ã–≤–∞–µ–º —Å —Å–ª–æ–≤–∞–º–∏
      const paronymPair = await prisma.paronymPair.create({
        data: {
          words: {
            connect: wordRecords.map(word => ({ id: word.id }))
          }
        }
      });
      
      logger.info("presetDB", `Created paronym pair with ID: ${paronymPair.id}`);
    }
    
    logger.info("presetDB", "Paronyms import completed successfully");
  } catch(error) {
    logger.error("presetDB", "Error during database preset", error as any);
  } finally {
    await prisma.$disconnect();
  }
}

// –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–º–ø–æ—Ä—Ç–∞
if (require.main === module) {
  importParonyms()
    .then(() => {
      logger.info("presetDB", "Import script finished");
      process.exit(0);
    })
    .catch(error => {
      logger.error("presetDB", "Import script failed", error);
      process.exit(1);
    });
}

export default importParonyms;
</file>

<file path="backend/src/scripts/presetDB.ts">
import { PrismaClient, PracticeType } from '@prisma/client';
import rawWords from '../data/words';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–ª–æ–≤ (–∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–∞ –∏–∑ utils.ts)
function processRawWords(rawWords: string[]): { word: string, accentIdx: number }[] {
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx || -1
    };
  });
}

async function presetDB() {
  logger.info("presetDB", "Starting database preset...");
  
  try {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª–æ–≤ –∏–∑ words.js
    const processedWords = processRawWords(rawWords);
    
    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–ª–æ–≤ —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —É–¥–∞—Ä–µ–Ω–∏–µ–º
    const validWords = processedWords.filter(word => word.accentIdx >= 0 && word.word.length > 0);
    
    logger.info("presetDB", `Processed ${validWords.length} valid words`);

    // –û—á–∏—Å—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Å–ª–æ–≤ —Ç–∏–ø–∞ STRESS (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
    await prisma.word.deleteMany({
      where: {
        type: PracticeType.STRESS
      }
    });
    
    logger.info("presetDB", "Deleted existing stress practice words");
    
    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    const createdWords = await prisma.word.createMany({
      data: validWords.map(word => ({
        word: word.word,
        stress: word.accentIdx,
        type: PracticeType.STRESS
      })),
      skipDuplicates: true
    });
    
    logger.info("presetDB", `Added ${createdWords.count} words to the database`);

    return { success: true, count: createdWords.count };
  } catch (error) {
    logger.error("presetDB", "Error during database preset", error as any);
    return { success: false, error };
  } finally {
    await prisma.$disconnect();
  }
}

// –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞, –µ—Å–ª–∏ –æ–Ω –≤—ã–∑–≤–∞–Ω –Ω–∞–ø—Ä—è–º—É—é
if (require.main === module) {
  presetDB()
    .then(result => {
      if (result.success) {
        logger.info("presetDB", "Database preset completed successfully!");
        process.exit(0);
      } else {
        logger.error("presetDB", "Database preset failed!", result.error as any);
        process.exit(1);
      }
    })
    .catch(err => {
      logger.error("presetDB", "Unhandled error during database preset", err);   
      process.exit(1);
    });
}

export default presetDB;
</file>

<file path="backend/src/utils/deepMap.ts">
import _ from "lodash";

type ReplaceFn = ({
  path,
  key,
  value,
}: {
  path: string;
  key: string;
  value: Value;
}) => Value;
type Value =
  | Object
  | number
  | string
  | boolean
  | null
  | undefined
  | Function
  | Symbol
  | any[];

const recursion = ({
  input,
  replaceFn,
  seen,
  pathStartsWith,
  parentKey,
}: {
  input: Value;
  replaceFn: ReplaceFn;
  seen: WeakSet<any>;
  pathStartsWith: string;
  parentKey: string;
}): Value => {
  if (
    ["object", "function", "symbol"].includes(typeof input) &&
    input !== null
  ) {
    if (seen.has(input)) {
      return "!!!CIRCULAR!!!";
    } else {
      seen.add(input);
    }
  }
  const result = replaceFn({
    path: pathStartsWith.replace(/\.$/, ""),
    key: parentKey,
    value: input,
  });
  if (!result) {
    return result;
  }
  if (_.isArray(result)) {
    return result.map((item, index) =>
      recursion({
        input: item,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${index}.`,
        parentKey: index.toString(),
      }),
    );
  }
  if (_.isObject(result)) {
    const object: any = {};
    for (const [key, value] of Object.entries(result)) {
      object[key] = recursion({
        input: value,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${key}.`,
        parentKey: key,
      });
    }
    return object;
  }
  return result;
};

export const deepMap = <T = Value>(input: Value, replaceFn: ReplaceFn): T => {
  const seen = new WeakSet();
  const mappedObject = recursion({
    input,
    replaceFn,
    seen,
    pathStartsWith: "",
    parentKey: "",
  });
  const clonedMappedObject = _.cloneDeep(mappedObject);
  return clonedMappedObject as T;
};
</file>

<file path="backend/src/utils/error.ts">
export class ExpectedError extends Error {
  isExpected = true as const;
}
</file>

<file path="backend/src/utils/logger.ts">
import { env } from "./env";
import { EOL } from "os";
import {omit} from "@russian-stress-practice/shared/src/omit"
import { TRPCError } from "@trpc/server";
import debug from "debug";
import _ from "lodash";
import pc from "picocolors";
import { serializeError } from "serialize-error";
import { MESSAGE } from "triple-beam";
import winston from "winston";
import * as yaml from "yaml";
import { deepMap } from "./deepMap";
import { ExpectedError } from "./error";
// import { sentryCaptureException } from "./sentry";

export const winstonLogger = winston.createLogger({
  level: "debug",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  defaultMeta: { service: "backend", hostEnv: env.HOST_ENV },
  transports: [
    new winston.transports.Console({
      format:
        env.HOST_ENV !== "local"
          ? winston.format.json()
          : winston.format((logData) => {
              const setColor = {
                info: (str: string) => pc.blue(str),
                error: (str: string) => pc.red(str),
                debug: (str: string) => pc.cyan(str),
              }[logData.level as "info" | "error" | "debug"];
              const levelAndType = `${logData.level} ${logData.logType}`;
              const timestamp =
                typeof logData.timestamp === "string" ? logData.timestamp : "";
              const topMessage = `[${setColor(levelAndType)}] ${pc.green(timestamp)}${EOL}${logData.message}`;

              const visibleMessageTags = omit(logData, [
                "level",
                "logType",
                "timestamp",
                "message",
                "service",
                "hostEnv",
              ]);

              const stringifyedLogData = _.trim(
                yaml.stringify(visibleMessageTags, (_k, v) =>
                  _.isFunction(v) ? "Function" : v,
                ),
              );

              const resultLogData = {
                ...logData,
                [MESSAGE]:
                  [
                    topMessage,
                    Object.keys(visibleMessageTags).length > 0
                      ? `${EOL}${stringifyedLogData}`
                      : "",
                  ]
                    .filter(Boolean)
                    .join("") + EOL,
              };

              return resultLogData;
            })(),
    }),
  ],
});

export type LoggerMetaData = Record<string, any> | undefined;
const prettifyMeta = (meta: LoggerMetaData): LoggerMetaData => {
  return deepMap(meta, ({ key, value }) => {
    if (
      [
        "email",
        "password",
        "newPassword",
        "oldPassword",
        "token",
        "text",
        "description",
      ].includes(key)
    ) {
      return "üôà";
    }
    return value;
  });
};

export const logger = {
  info: (logType: string, message: string, meta?: LoggerMetaData) => {
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    winstonLogger.info(message, { logType, ...prettifyMeta(meta) });
  },
  error: (logType: string, error: any, meta?: LoggerMetaData) => {
    // const isNativeExpectedError = error instanceof ExpectedError
    // const isTrpcExpectedError = error instanceof TRPCError && error.cause instanceof ExpectedError
    const prettifiedMetaData = prettifyMeta(meta)
    // if (!isNativeExpectedError && !isTrpcExpectedError) {
    //   sentryCaptureException(error, prettifiedMetaData)
    // }
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    const serializedError = serializeError(error);
    winstonLogger.error(serializedError.message || "Unknown error", {
      logType,
      error,
      errorStack: serializedError.stack,
      ...prettifiedMetaData,
    });
  },
};
</file>

<file path="backend/src/utils/models.ts">
import type { User } from "@prisma/client";
import {pick} from "@russian-stress-practice/shared/src/pick"

export const toClientMe = (user: User | null) => {
  return user && pick(user, ["id", "name", "email", "score", "provider", "providerId", "accessToken"]);
};
</file>

<file path="backend/src/utils/types.ts">
import { type User } from "@prisma/client";
import { type Request } from "express";

export type ExpressRequest = Request & {
  user: User | undefined;
};
</file>

<file path="backend/tsconfig.json">
{
  "ts-node": {
    "files": true,
    "transpile0nly": true
  },
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "downlevelIteration": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "inlineSources": true,
    "isolatedModules": false,
    "lib": ["ES2021"],
    "module": "commonjs",
    "moduleResolution": "Node",
    "target": "ES2021",
    "paths": {
      "@russian-stress-practice/shared/*": ["../shared/*"],
      "@russian-stress-practice/frontend/*": ["../frontend/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import node from "eslint-plugin-node";
import jest from "eslint-plugin-jest";
import path from "node:path";
import { fileURLToPath } from "node:url";
import js from "@eslint/js";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
    baseDirectory: __dirname,
    recommendedConfig: js.configs.recommended,
    allConfig: js.configs.all
});

export default defineConfig([globalIgnores(["**/node_modules", "**/dist", "**/*.config.js"]), {
    extends: compat.extends("standard-with-typescript", "prettier", "plugin:jest/recommended"),

    plugins: {
        node,
        jest,
    },

    rules: {
        "no-new": "off",

        "import/order": ["error", {
            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],

        "@typescript-eslint/consistent-type-definitions": ["error", "type"],
        "@typescript-eslint/strict-boolean-expressions": "off",
        "@typescript-eslint/prefer-nullish-coalescing": "off",
        "@typescript-eslint/explicit-function-return-type": "off",
        "@typescript-eslint/restrict-template-expressions": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/consistent-type-assertions": "off",
        "jsx-a11y/anchor-is-valid": "off",
        curly: ["error", "all"],

        "no-irregular-whitespace": ["error", {
            skipTemplates: true,
            skipStrings: true,
        }],

        "node/no-process-env": "error",

        "no-restricted-syntax": ["error", {
            selector: "[object.type=MetaProperty][property.name=env]",
            message: "Use instead import { env } from \"lib/env\"",
        }],
    },
}]);
</file>

<file path="frontend/.env.production">
HOST_ENV=render
NODE_ENV=production
VITE_GOOGLE_CLIENT_ID=186603076724-rv7ju37n9gs3gck7a11a6ertr08k35be.apps.googleusercontent.com
VITE_GOOGLE_REDIRECT_URI=http://localhost:5173/auth/callback/google
VITE_BACKEND_TRPC_URL=http://localhost:3000/trpc
VITE_WEBAPP_URL=http://localhost:5173/
VITE_PORT=5173
</file>

<file path="frontend/.envrc">
use flake
</file>

<file path="frontend/.github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>


<file path="frontend/README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"–≤–û–≤—Ä–µ–º—è"` (stress on the first '–æ')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="frontend/src/components/Loader/index.tsx">
import { Bouncy } from "ldrs/react";
import React from "react";
import "ldrs/react/Bouncy.css";
import { JellyTriangle } from 'ldrs/react'
import 'ldrs/react/JellyTriangle.css'


interface LoaderProps {
    size?: string
    speed?: string
    color?: string
}

export const Loader = ({size="45px", speed="1.2s", color="rgb(67, 73, 233)"}: LoaderProps) => {
  return (
    <>
      <JellyTriangle size={size} speed={speed} color={color} />
    </>
  );
};
</file>

<file path="frontend/src/components/Login/index.tsx">
import React, { useEffect } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";
import { useGoogleAuth  } from "../../utils/googleAuth";

interface LoginProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function Login({ isOpen, onClose }: LoginProps) {
  const login = useGoogleAuth();
  const handleGoogleLoginClick = async () => {
    try {
      login();
      onClose();
    } catch (error) {
      console.error('Failed to login with Google:', error);
    }
  };

  const handleYandexLogin = async () => {
    // TODO: Implement Yandex OAuth
    console.log("Yandex login clicked");
  };

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 backdrop-blur-sm" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <Dialog.Title
                  as="h3"
                  className="text-lg font-medium leading-6 text-gray-900 text-center mb-4"
                >
                  –í–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç
                </Dialog.Title>

                <div className="mt-4 space-y-3">
                  <button
                    onClick={handleGoogleLoginClick}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://www.google.com/favicon.ico"
                      alt="Google logo"
                    />
                    –í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Google
                  </button>

                  <button
                    onClick={handleYandexLogin}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://yastatic.net/s3/home-static/_/7c/7ccf30cd11b00c2eb4f79f698da24aa2.png"
                      alt="Yandex logo"
                    />
                    –í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ –Ø–Ω–¥–µ–∫—Å
                  </button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
}
</file>

<file path="frontend/src/components/PracticeStats/index.tsx">
import React from 'react';
import { Loader } from '../Loader';
import { PracticeType } from '../../types/practice';
import trpc from '../../utils/trpc';

// –¢–∏–ø—ã –¥–ª—è –ø—Ä–æ–ø—Å–æ–≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞
interface PracticeStatsProps {
  type: "STRESS" | "PARONYM";
  period?: number;
  onPeriodChange?: (period?: number) => void;
}

// –¢–∏–ø—ã –¥–ª—è –¥–∞–Ω–Ω—ã—Ö —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
interface StatsData {
  summary: {
    totalAttempts: number;
    correctAttempts: number;
    correctRate: number;
    recentStats?: {
      totalAttempts: number;
      correctAttempts: number;
      correctRate: number;
    };
  };
  dailyStats: Array<{
    date: string;
    total: number;
    correct: number;
    rate: number;
  }>;
  problemWords: Array<{
    id: number;
    word: string;
    total: number;
    correct: number;
  }>;
}

// –•—É–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
export const useUserStats = (params: { type: "STRESS" | "PARONYM"; period?: number }) => {
  const { data, isLoading, error, refetch } = trpc.GetUserStats.useQuery(params, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
    onError: (error) => {
      console.error("Failed to fetch user stats:", error);
    }
  });

  return {
    stats: data as StatsData | undefined,
    isLoading,
    error,
    refetch
  };
};

const PracticeStats: React.FC<PracticeStatsProps> = ({ type, period, onPeriodChange }) => {
  // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å –ø–æ–º–æ—â—å—é —Ö—É–∫–∞
  const { stats, isLoading } = useUserStats({ type, period });

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–∏–æ–¥–∞
  const handlePeriodChange = (newPeriod?: number) => {
    if (onPeriodChange) {
      onPeriodChange(newPeriod);
    }
  };

  return (
    <div>
      {/* –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ */}
      <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">
        –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
      </h2>

      {/* –°–µ–ª–µ–∫—Ç–æ—Ä –ø–µ—Ä–∏–æ–¥–∞ */}
      <div className="mb-4 flex space-x-2">
        <button
          onClick={() => handlePeriodChange(undefined)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === undefined ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          –í—Å–µ –≤—Ä–µ–º—è
        </button>
        <button
          onClick={() => handlePeriodChange(7)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 7 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          7 –¥–Ω–µ–π
        </button>
        <button
          onClick={() => handlePeriodChange(30)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 30 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          30 –¥–Ω–µ–π
        </button>
      </div>

      {isLoading ? (
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏, –ø–æ–∫–∞ –¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è
        <div className="flex justify-center py-8">
          <Loader />
        </div>
      ) : stats ? (
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É, –∫–æ–≥–¥–∞ –¥–∞–Ω–Ω—ã–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        <>
          {/* –û—Å–Ω–æ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */}
          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">–í—Å–µ–≥–æ –ø–æ–ø—ã—Ç–æ–∫</p>
                <p className="text-xl font-semibold text-slate-800">
                  {stats.summary.totalAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö</p>
                <p className="text-xl font-semibold text-emerald-600">
                  {stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö</p>
                <p className="text-xl font-semibold text-amber-600">
                  {stats.summary.totalAttempts - stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">–¢–æ—á–Ω–æ—Å—Ç—å</p>
                <p className="text-xl font-semibold text-indigo-600">
                  {Math.round(stats.summary.correctRate * 100)}%
                </p>
              </div>
            </div>
          </div>
          
          {/* –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä —Ç–æ—á–Ω–æ—Å—Ç–∏ */}
          <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
            <h3 className="text-md font-semibold mb-2 text-slate-700">–¢–æ—á–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–æ–≤</h3>
            <div className="w-full bg-slate-100 rounded-full h-4">
              <div 
                className="bg-emerald-500 h-4 rounded-full" 
                style={{ width: `${Math.round(stats.summary.correctRate * 100)}%` }}
              ></div>
            </div>
            <p className="text-right text-sm text-slate-600 mt-1">
              {Math.round(stats.summary.correctRate * 100)}%
            </p>
          </div>
          
          {/* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞) */}
          {stats.summary.recentStats && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">–ü–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π</h3>
              <div className="grid grid-cols-2 gap-3">
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">–ü–æ–ø—ã—Ç–æ–∫</p>
                  <p className="text-lg font-semibold text-slate-800">
                    {stats.summary.recentStats.totalAttempts}
                  </p>
                </div>
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö</p>
                  <p className="text-lg font-semibold text-emerald-600">
                    {stats.summary.recentStats.correctAttempts}
                  </p>
                </div>
              </div>
              <div className="mt-2 w-full bg-slate-100 rounded-full h-3">
                <div 
                  className="bg-indigo-500 h-3 rounded-full" 
                  style={{ 
                    width: `${stats.summary.recentStats.totalAttempts > 0 
                      ? Math.round((stats.summary.recentStats.correctAttempts / stats.summary.recentStats.totalAttempts) * 100) 
                      : 0}%` 
                  }}
                ></div>
              </div>
            </div>
          )}
          
          {/* –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π) */}
          {stats.dailyStats.length > 0 && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h3>
              <div className="space-y-2">
                {stats.dailyStats
                  .slice(0, 7) // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
                  .map((day, i) => (
                    <div key={i} className="flex items-center">
                      <span className="text-xs text-slate-500 w-20">{new Date(day.date).toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' })}</span>
                      <div className="flex-1 ml-2">
                        <div className="w-full bg-slate-100 rounded-full h-3">
                          <div 
                            className="bg-emerald-500 h-3 rounded-full" 
                            style={{ width: `${Math.round(day.rate * 100)}%` }}
                          ></div>
                        </div>
                      </div>
                      <span className="text-xs font-medium ml-2 w-12 text-right">
                        {day.correct}/{day.total}
                      </span>
                    </div>
                  ))}
              </div>
            </div>
          )}
          
          {/* –ü—Ä–æ–±–ª–µ–º–Ω—ã–µ —Å–ª–æ–≤–∞ */}
          {stats.problemWords.length > 0 && (
            <div className="mb-6">
              <h3 className="text-md font-semibold mb-2 text-slate-700">–°–ª–æ–∂–Ω—ã–µ —Å–ª–æ–≤–∞</h3>
              <ul className="bg-white rounded-xl shadow-sm divide-y divide-slate-100">
                {stats.problemWords.map((word, i) => (
                  <li key={i} className="py-2 px-3 flex justify-between items-center">
                    <span className="text-slate-700">{word.word}</span>
                    <div className="flex items-center">
                      <span className="text-xs text-slate-500 mr-2">
                        {word.correct}/{word.total}
                      </span>
                      <span className="px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-700">
                        {Math.round((word.correct / word.total) * 100)}%
                      </span>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </>
      ) : (
        // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç
        <div className="text-center py-8 text-slate-500">
          –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø—Ä–∞–∫—Ç–∏–∫–µ
        </div>
      )}
    </div>
  );
};

export default PracticeStats;
</file>

<file path="frontend/src/components/svg/svgNative.tsx">
import React, { SVGProps } from "react";

export const SymbolLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-6 w-6 mr-2"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
      />
    </svg>
  );
};

export const StressLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"
      />
    </svg>
  );
};

export const ParonymsLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
      />
    </svg>
  );
};

export const SignInLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"
      />
    </svg>
  );
};


export function LogoutIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" {...props}>{/* Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ */}<path fill="currentColor" d="M14.945 1.25c-1.367 0-2.47 0-3.337.117c-.9.12-1.658.38-2.26.981c-.524.525-.79 1.17-.929 1.928c-.135.737-.161 1.638-.167 2.72a.75.75 0 0 0 1.5.008c.006-1.093.034-1.868.142-2.457c.105-.566.272-.895.515-1.138c.277-.277.666-.457 1.4-.556c.755-.101 1.756-.103 3.191-.103h1c1.436 0 2.437.002 3.192.103c.734.099 1.122.28 1.4.556c.276.277.456.665.555 1.4c.102.754.103 1.756.103 3.191v8c0 1.435-.001 2.436-.103 3.192c-.099.734-.279 1.122-.556 1.399s-.665.457-1.399.556c-.755.101-1.756.103-3.192.103h-1c-1.435 0-2.436-.002-3.192-.103c-.733-.099-1.122-.28-1.399-.556c-.243-.244-.41-.572-.515-1.138c-.108-.589-.136-1.364-.142-2.457a.75.75 0 1 0-1.5.008c.006 1.082.032 1.983.167 2.72c.14.758.405 1.403.93 1.928c.601.602 1.36.86 2.26.982c.866.116 1.969.116 3.336.116h1.11c1.368 0 2.47 0 3.337-.116c.9-.122 1.658-.38 2.26-.982s.86-1.36.982-2.26c.116-.867.116-1.97.116-3.337v-8.11c0-1.367 0-2.47-.116-3.337c-.121-.9-.38-1.658-.982-2.26s-1.36-.86-2.26-.981c-.867-.117-1.97-.117-3.337-.117z"></path><path fill="currentColor" d="M15 11.25a.75.75 0 0 1 0 1.5H4.027l1.961 1.68a.75.75 0 1 1-.976 1.14l-3.5-3a.75.75 0 0 1 0-1.14l3.5-3a.75.75 0 1 1 .976 1.14l-1.96 1.68z"></path></svg>
  )
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="frontend/src/pages/LogOutPage/index.tsx">
import Cookies from "js-cookie";
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { GetStressPractice } from "../../utils/routes";
import React from "react";

export const LogOutPage = () => {
  const navigate = useNavigate();
  const trpcUtils = trpc.useContext();
  useEffect(() => {
    Cookies.remove("token");
    void trpcUtils.invalidate().then(() => {
      navigate(GetStressPractice());
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return <Loader size={"45"} speed={"0.7"} color={"blue"} />;
};
</file>

<file path="frontend/src/pages/PersonalDictionaryPage/index.tsx">
import React, { useState } from 'react';
import { Tab } from '@headlessui/react';
import trpc from '../../utils/trpc';
import { Loader } from '../../components/Loader';
import PersonalDictionaryButton from '../../components/PersonalDictionaryButton';
import { PracticeType, PersonalDictionaryWord, PersonalDictionaryParonym } from '../../types/practice';
import { useMe } from '../../utils/ctx';
import { Link } from 'react-router-dom';
import { GetStressPractice, GetParonymsPractice } from '../../utils/routes';

const PersonalDictionaryPage: React.FC = () => {
  const [selectedTab, setSelectedTab] = useState(0);
  const me = useMe();
  
  // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ–≤–∞ —Å —É–¥–∞—Ä–µ–Ω–∏—è–º–∏ –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
  const { 
    data: stressData, 
    isLoading: isLoadingStress,
    refetch: refetchStressData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.STRESS },
    { 
      enabled: selectedTab === 0 && !!me,
      onError: (error) => {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å–ª–æ–≤:", error);
      }
    }
  );
  
  // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–æ–Ω–∏–º—ã –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
  const { 
    data: paronymsData, 
    isLoading: isLoadingParonyms,
    refetch: refetchParonymsData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.PARONYM },
    { 
      enabled: selectedTab === 1 && !!me,
      onError: (error) => {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–∞—Ä–æ–Ω–∏–º–æ–≤:", error);
      }
    }
  );
  
  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–∑ —Å–ª–æ–≤–∞—Ä—è
  const handleToggle = (isPersonal: boolean) => {
    if (selectedTab === 0) {
      refetchStressData();
    } else {
      refetchParonymsData();
    }
  };
  
  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ª–æ–≤–∞ —Å —É–¥–∞—Ä–µ–Ω–∏–µ–º
  const renderWordWithStress = (word: string, accentIdx: number) => {
    return (
      <>
        {word.substring(0, accentIdx)}
        <span className="text-indigo-600 font-bold">
          {word.charAt(accentIdx)}
        </span>
        {word.substring(accentIdx + 1)}
      </>
    );
  };
  
  // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω
  if (!me) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
        <div className="max-w-4xl mx-auto text-center py-12 bg-white rounded-xl shadow-sm">
          <h1 className="text-3xl font-bold mb-6 text-slate-800">
            –õ–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä–∏–∫
          </h1>
          <p className="text-slate-500 mb-6">
            –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ª–∏—á–Ω–æ–º—É —Å–ª–æ–≤–∞—Ä–∏–∫—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è.
          </p>
          <button
            className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
            onClick={() => window.location.href = "/auth/login"}
          >
            –í–æ–π—Ç–∏
          </button>
        </div>
      </div>
    );
  }
  
  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º source=dictionary
  const getPracticeUrlWithDictionarySource = (baseUrl: string) => {
    return `${baseUrl}?source=dictionary`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-6 text-slate-800">
          –õ–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä–∏–∫
        </h1>
        
        <Tab.Group onChange={setSelectedTab}>
          <Tab.List className="flex space-x-1 rounded-xl bg-white p-1 mb-6 shadow-sm">
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              –£–¥–∞—Ä–µ–Ω–∏—è
            </Tab>
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              –ü–∞—Ä–æ–Ω–∏–º—ã
            </Tab>
          </Tab.List>
          
          <Tab.Panels>
            {/* –ü–∞–Ω–µ–ª—å —Å —É–¥–∞—Ä–µ–Ω–∏—è–º–∏ */}
            <Tab.Panel>
              {isLoadingStress ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : stressData?.words && stressData.words.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetStressPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      –ü—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å —Å–ª–æ–≤–∞ –∏–∑ —Å–ª–æ–≤–∞—Ä—è
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {stressData.words.map((word) => (
                        <li key={word.id} className="p-4 flex justify-between items-center">
                          <div>
                            <p className="text-lg font-medium text-slate-800">
                              {renderWordWithStress(word.word, word.accentIdx)}
                            </p>
                            {word.history.length > 0 && (
                              <p className="text-xs text-slate-500 mt-1">
                                –ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–∫—Ç–∏–∫–∞: {new Date(word.history[0].date).toLocaleDateString()}
                                {word.history[0].correct ? ' ‚úì' : ' ‚úó'}
                              </p>
                            )}
                          </div>
                          <PersonalDictionaryButton
                            type={PracticeType.STRESS}
                            id={word.id}
                            initialIsPersonal={true}
                            onToggle={handleToggle}
                          />
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    –í –≤–∞—à–µ–º –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ –ø–æ–∫–∞ –Ω–µ—Ç —Å–ª–æ–≤ —Å —É–¥–∞—Ä–µ–Ω–∏—è–º–∏.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    –î–æ–±–∞–≤—å—Ç–µ —Å–ª–æ–≤–∞ –∏–∑ –ø—Ä–∞–∫—Ç–∏–∫–∏, –Ω–∞–∂–∞–≤ –Ω–∞ –∏–∫–æ–Ω–∫—É –∑–∞–∫–ª–∞–¥–∫–∏.
                  </p>
                  <Link 
                    to={GetStressPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø—Ä–∞–∫—Ç–∏–∫–µ —É–¥–∞—Ä–µ–Ω–∏–π
                  </Link>
                </div>
              )}
            </Tab.Panel>
            
            {/* –ü–∞–Ω–µ–ª—å —Å –ø–∞—Ä–æ–Ω–∏–º–∞–º–∏ */}
            <Tab.Panel>
              {isLoadingParonyms ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : paronymsData?.paronyms && paronymsData.paronyms.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetParonymsPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      –ü—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å –ø–∞—Ä–æ–Ω–∏–º—ã –∏–∑ —Å–ª–æ–≤–∞—Ä—è
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {paronymsData.paronyms.map((pair) => (
                        <li key={pair.id} className="p-4">
                          <div className="flex justify-between items-start">
                            <div>
                              <p className="text-lg font-medium text-slate-800">
                                {pair.group.join(' / ')}
                              </p>
                            </div>
                            <PersonalDictionaryButton
                              type={PracticeType.PARONYM}
                              id={pair.id}
                              initialIsPersonal={true}
                              onToggle={handleToggle}
                            />
                          </div>
                          <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                            {pair.paronyms.map((paronym) => (
                              <div key={paronym.id} className="bg-slate-50 p-3 rounded-lg">
                                <p className="font-medium text-indigo-700">{paronym.word}</p>
                                <p className="text-sm text-slate-600 mt-1">{paronym.explanation}</p>
                              </div>
                            ))}
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    –í –≤–∞—à–µ–º –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ –ø–æ–∫–∞ –Ω–µ—Ç –ø–∞—Ä–æ–Ω–∏–º–æ–≤.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    –î–æ–±–∞–≤—å—Ç–µ –ø–∞—Ä–æ–Ω–∏–º—ã –∏–∑ –ø—Ä–∞–∫—Ç–∏–∫–∏, –Ω–∞–∂–∞–≤ –Ω–∞ –∏–∫–æ–Ω–∫—É –∑–∞–∫–ª–∞–¥–∫–∏.
                  </p>
                  <Link 
                    to={GetParonymsPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    –ü–µ—Ä–µ–π—Ç–∏ –∫ –ø—Ä–∞–∫—Ç–∏–∫–µ –ø–∞—Ä–æ–Ω–∏–º–æ–≤
                  </Link>
                </div>
              )}
            </Tab.Panel>
          </Tab.Panels>
        </Tab.Group>
      </div>
    </div>
  );
};

export default PersonalDictionaryPage;
</file>

<file path="frontend/src/types/practice.ts">
export enum PracticeType {
  STRESS = 'STRESS',
  PARONYM = 'PARONYM'
}

// –¢–∏–ø—ã –¥–ª—è –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è
export interface PersonalDictionaryWord {
  id: number;
  word: string;
  accentIdx: number;
  history: {
    correct: boolean;
    date: string;
  }[];
}

export interface PersonalDictionaryParonym {
  id: number;
  group: string[];
  paronyms: {
    id: number;
    word: string;
    explanation: string;
  }[];
}

export interface PersonalDictionaryResponse {
  words?: PersonalDictionaryWord[];
  paronyms?: PersonalDictionaryParonym[];
}
</file>

<file path="frontend/src/types/types.d.ts">
declare module '*.css'
</file>

<file path="frontend/src/utils/ctx.tsx">
import type { TrpcRouterOutput } from "@russian-stress-practice/backend/src/router";
import React, { createContext, useContext } from "react";
import trpc from "./trpc";
import { Loader } from "../components/Loader";

export type AppContext = {
  me: TrpcRouterOutput["GetMe"]["me"];
};

const AppReactContext = createContext<AppContext>({
  me: null,
});

export const AppContextProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const { data, error, isLoading, isFetching, isError } = trpc.GetMe.useQuery();
  return (
    <AppReactContext.Provider
      value={{
        me: data?.me || null,
      }}
    >
      {isLoading || isFetching ? (
        <Loader size="45px" speed="1.2s" color="rgb(67, 73, 233)" />
      ) : isError ? (
        <p>Error: {error?.message}</p>
      ) : (
        children
      )}
    </AppReactContext.Provider>
  );
};

export const useAppContext = () => {
  return useContext(AppReactContext);
};

export const useMe = () => {
  const { me } = useAppContext();
  return me;
};
</file>

<file path="frontend/src/utils/googleAuth.ts">
import { useGoogleLogin } from '@react-oauth/google';
import trpc from '../utils/trpc';
import { useQueryClient } from '@tanstack/react-query';
import Cookies from 'js-cookie';

interface GoogleCredentials {
  email: string;
  name?: string;
  providerId: string;
  accessToken: string;
  refreshToken?: string;
  tokenExpires?: string;
}

/**
 * –ö–∞—Å—Ç–æ–º–Ω—ã–π —Ö—É–∫ –¥–ª—è Google OAuth: –ø–µ—Ä–µ–≤–æ–¥–∏–º —Ö—É–∫ –º—É—Ç–∞—Ü–∏–∏ –Ω–∞—Ä—É–∂—É
 */
export function useGoogleAuth() {
  const { mutateAsync } = trpc.GetAuth.useMutation();
  const queryClient = useQueryClient();

  return useGoogleLogin({
    flow: 'implicit',
    scope: 'openid email profile',
    onSuccess: async (tokenResponse) => {
      try {
        const userInfo = await fetch(
          'https://www.googleapis.com/oauth2/v3/userinfo',
          { 
            headers: { Authorization: `Bearer ${tokenResponse.access_token}` },
            mode: 'cors'
          }
        ).then(res => res.json());

        const creds: GoogleCredentials = {
          email: userInfo.email,
          name: userInfo.name,
          providerId: userInfo.sub,
          accessToken: tokenResponse.access_token,
          refreshToken: tokenResponse.access_token,
          tokenExpires: new Date(Date.now() + tokenResponse.expires_in * 1000).toISOString(),
        };

        const result = await mutateAsync({
          provider: 'GOOGLE',
          credentials: creds,
        });
        
        console.log('Authentication result:', result);
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º JWT —Ç–æ–∫–µ–Ω, –ø–æ–ª—É—á–µ–Ω–Ω—ã–π –æ—Ç –Ω–∞—à–µ–≥–æ –±—ç–∫–µ–Ω–¥–∞
        if (result.token) {
          Cookies.set('token', result.token);
          console.log('Token saved to cookies:', result.token.substring(0, 20) + '...');
        } else {
          console.error('No token received from backend');
        }
        
        queryClient.invalidateQueries(['GetMe']);
        window.location.reload()
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ Google OAuth:', error);
      }
    },
    onError: (error) => {
      console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Google:', error);
    },
  });
}
</file>

<file path="frontend/src/utils/pumpGetRoute.ts">
import { useParams as useReactRouterParams } from "react-router-dom";

const baseUrl = process.env.VITE_WEBAPP_URL || process.env.WEBAPP_URL;

type PumpedGetRouteInputBase = {
  abs?: boolean;
};

function pumpGetRoute<T extends Record<string, boolean>>(
  routeParamsDefinition: T,
  getRoute: (routeParams: Record<keyof T, string>) => string,
): {
  (routeParams: Record<keyof T, string> & PumpedGetRouteInputBase): string;
  placeholders: Record<keyof T, string>;
  useParams: () => Record<keyof T, string>;
  definition: string;
};

function pumpGetRoute(getRoute: () => string): {
  (routeParams?: PumpedGetRouteInputBase): string;
  placeholders: {};
  useParams: () => {};
  definition: string;
};

function pumpGetRoute(routeParamsOrGetRoute?: any, maybeGetRoute?: any) {
  const routeParamsDefinition =
    typeof routeParamsOrGetRoute === "function" ? {} : routeParamsOrGetRoute;
  const getRoute =
    typeof routeParamsOrGetRoute === "function"
      ? routeParamsOrGetRoute
      : maybeGetRoute;
  const placeholders = Object.keys(routeParamsDefinition).reduce(
    (acc, key) => ({ ...acc, [key]: `:${key}` }),
    {},
  );
  const definition = getRoute(placeholders);
  const pumpedGetRoute = (routeParams?: PumpedGetRouteInputBase) => {
    const route = getRoute(routeParams);
    if (routeParams?.abs) {
      return `${baseUrl}${route}`;
    } else {
      return route;
    }
  };
  pumpedGetRoute.placeholders = placeholders;
  pumpedGetRoute.definition = definition;
  pumpedGetRoute.useParams = useReactRouterParams as any;
  return pumpedGetRoute;
}

export type RouteParams<T extends { placeholders: Record<string, string> }> =
  T["placeholders"];

export const pgr = pumpGetRoute;
</file>

<file path="frontend/src/utils/statsContext.tsx">
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface StatsContextType {
  isStatsVisible: boolean;
  toggleStats: () => void;
}

const StatsContext = createContext<StatsContextType | undefined>(undefined);

export function StatsProvider({ children }: { children: ReactNode }) {
  const [isStatsVisible, setIsStatsVisible] = useState(false);

  const toggleStats = () => {
    setIsStatsVisible(prev => !prev);
  };

  return (
    <StatsContext.Provider value={{ isStatsVisible, toggleStats }}>
      {children}
    </StatsContext.Provider>
  );
}

export function useStats() {
  const context = useContext(StatsContext);
  if (context === undefined) {
    throw new Error('useStats must be used within a StatsProvider');
  }
  return context;
}
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    passWithNoTests: true,
    verbose: true,
    prettierPath: null,
  }
</file>

<file path="shared/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix
  - prettier --loglevel warn --cache --write
"*.{json,yml,scss}": prettier --loglevel warn --cache --write
</file>

<file path="shared/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.js'),
  }
</file>

<file path="shared/package.json">
{
  "name": "@russian-stress-practice/shared",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --ext .ts .",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "test": "jest"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/lodash": "^4.17.15"
  }
}
</file>

<file path="shared/src/getKeysAsArray.ts">
import lodashKeys from 'lodash/keys'

// https://catchts.com/union-array
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type UnionToOvlds<U> = UnionToIntersection<U extends any ? (f: U) => void : never>
type PopUnion<U> = UnionToOvlds<U> extends (a: infer A) => void ? A : never
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true
type UnionToArray<T, A extends unknown[] = []> = IsUnion<T> extends true
  ? UnionToArray<Exclude<T, PopUnion<T>>, [PopUnion<T>, ...A]>
  : [T, ...A]

export const getKeysAsArray = <T>(obj: T): UnionToArray<keyof T> => {
  return lodashKeys(obj) as UnionToArray<keyof T>
}
</file>

<file path="shared/src/omit.ts">
import lodashOmit from 'lodash/omit'

export const omit = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Omit<TObject, TKeys> => {
  return lodashOmit(obj, keys)
}
</file>

<file path="shared/src/pick.ts">
import lodashPick from 'lodash/pick'

export const pick = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Pick<TObject, TKeys> => {
  return lodashPick(obj, keys)
}
</file>

<file path="shared/src/tryCatch.ts">
type Success<T> = {
    data: T;
    error: null;
  };
  
  type Failure<E> = {
    data: null;
    error: E;
  };
  
  type Result<T, E = Error> = Success<T> | Failure<E>;
  
  export async function tryCatch<T, E = Error>(
    promise: Promise<T>,
  ): Promise<Result<T, E>> {
    try {
      const data = await promise;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error as E };
    }
}
</file>

<file path="shared/src/zod.ts">
import { z } from "zod";

export const zEnvNonemptyTrimmed = z.string().trim().min(1);
export default zEnvNonemptyTrimmed;
export const zEnvNonemptyTrimmedRequiredOnNotLocal = zEnvNonemptyTrimmed
  .optional()
  .refine(
    // eslint-disable-next-line node/no-process-env
    (val) => `${process.env.HOST_ENV}` === "local" || !!val,
    "Required on not local host",
  );
export const zEnvHost = z.enum(["local", "production"]);

export const zStringRequired = z
  .string({ required_error: "Please, fill it" })
  .min(1, "Please, fill it");
export const zStringOptional = z.string().optional();
export const zEmailRequired = zStringRequired.email();
export const zNickRequired = zStringRequired.regex(
  /^[a-z0-9-]+$/,
  "Nick may contain only lowercase letters, numbers and dashes",
);
export const zStringMin = (min: number) =>
  zStringRequired.min(min, `Text should be at least ${min} characters long`);
export const zPasswordsMustBeTheSame =
  (passwordFieldName: string, passwordAgainFieldName: string) =>
  (val: any, ctx: z.RefinementCtx) => {
    if (val[passwordFieldName] !== val[passwordAgainFieldName]) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Passwords must be the same",
        path: [passwordAgainFieldName],
      });
    }
  };
</file>

<file path="shared/tsconfig.json">
{
  "extends": "../backend/tsconfig.json",
  "include": ["src"]
}
</file>

<file path="backend/.gitignore">
node-modules
dist
.DS_Store
.env
.env.production
</file>



export default paronymData;
</file>

<file path="backend/src/router/index.ts">
import { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { createTrpcRouter } from "../lib/trpc";
// @index('./**/index.ts', f => `import { ${f.path.split('/').slice(0, -1).pop()}TrpcRoute } from '${f.path.split('/').slice(0, -1).join('/')}'`)
import { CheckPersonalItemTrpcRoute } from './Dictionary/CheckPersonalItem'
import { GetPersonalDictionaryTrpcRoute } from './Dictionary/GetPersonalDictionary'
import { TogglePersonalParonymTrpcRoute } from './Dictionary/TogglePersonalParonym'
import { TogglePersonalWordTrpcRoute } from './Dictionary/TogglePersonalWord'
import { GetParonymsTrpcRoute } from './Practice/GetParonyms'
import { GetPracticeWordsTrpcRoute } from './Practice/GetPracticeWords'
import { GetUserStatsTrpcRoute } from './Practice/GetUserStats'
import { RecordPracticeTrpcRoute } from './Practice/RecordPractice'
import { GetAuthTrpcRoute } from './auth/GetAuth'
import { GetMeTrpcRoute } from './auth/GetMe'
// @endindex


export const trpcRouter = createTrpcRouter({
    // @index('./**/index.ts', f => `${f.path.split('/').slice(0, -1).pop()}: ${f.path.split('/').slice(0, -1).pop()}TrpcRoute,`)
    GetAuth: GetAuthTrpcRoute,
    GetMe: GetMeTrpcRoute,
    CheckPersonalItem: CheckPersonalItemTrpcRoute,
    GetPersonalDictionary: GetPersonalDictionaryTrpcRoute,
    TogglePersonalParonym: TogglePersonalParonymTrpcRoute,
    TogglePersonalWord: TogglePersonalWordTrpcRoute,
    GetParonyms: GetParonymsTrpcRoute,
    GetPracticeWords: GetPracticeWordsTrpcRoute,
    GetUserStats: GetUserStatsTrpcRoute,
    RecordPractice: RecordPracticeTrpcRoute,
    // @endindex
})


export type TrpcRouter = typeof trpcRouter;
export type TrpcRouterInput = inferRouterInputs<TrpcRouter>;
export type TrpcRouterOutput = inferRouterOutputs<TrpcRouter>;
</file>

<file path="backend/src/router/Practice/GetUserStats/index.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { format, subDays } from "date-fns";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetUserStats } from "./input";

export const GetUserStatsTrpcRoute = trpcLoggedProcedure
  .input(zGetUserStats)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }

    const { type, period } = input;
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–µ—Ä–∏–æ–¥ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
    const periodDate = period 
      ? new Date(Date.now() - period * 24 * 60 * 60 * 1000)
      : undefined;

    try {
      // –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ø—Ä–∞–∫—Ç–∏–∫–∏
      if (type === "STRESS") {
        // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —É–¥–∞—Ä–µ–Ω–∏—è–º
        const practiceQuery = {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
        const totalAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
          },
        });
        
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
        const correctAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
            correct: true,
          },
        });
        
        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const dailyStats = await getDailyStats(ctx.prisma as any, ctx.me.id, "STRESS", period);
        
        // –ü—Ä–æ–±–ª–µ–º–Ω—ã–µ —Å–ª–æ–≤–∞
        const problemWords = await getProblemWords(ctx.prisma as any, ctx.me.id, "STRESS");
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords,
        };
      } 
      else if (type === "PARONYM") {
        // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø–∞—Ä–æ–Ω–∏–º–∞–º
        const practiceQuery = {
          userId: ctx.me.id,
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
        const totalAttempts = await ctx.prisma.paronymPractice.count({
          where: practiceQuery,
        });
        
        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
        const correctAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            ...practiceQuery,
            correct: true,
          },
        });
        
        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        const dailyStats = await getParonymDailyStats(ctx.prisma as any, ctx.me.id, period);
        
        // –ü—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ä—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤
        const problemParonyms = await getProblemParonyms(ctx.prisma as any, ctx.me.id);
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords: problemParonyms, // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏",
      });
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("Error fetching user stats:", error);
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
        cause: error,
      });
    }
  });

// –¢–∏–ø—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
type DailyStats = {
  date: string;
  total: number;
  correct: number;
  rate: number;
};

type ProblemWord = {
  id: number;
  word: string;
  total: number;
  correct: number;
};

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —É–¥–∞—Ä–µ–Ω–∏—è–º
async function getDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 30 –¥–Ω–µ–π
  const startDate = subDays(new Date(), periodDays);
  
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–Ω—è–º
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Å–ª–æ–≤
async function getProblemWords(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType
): Promise<ProblemWord[]> {
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø—Ä–∞–∫—Ç–∏–∫–∏
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
    },
    include: {
      word: true,
    },
  });
  
  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å–ª–æ–≤–∞–º –∏ —Å—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  const wordStats = new Map<number, { word: string, total: number, correct: number }>();
  
  practices.forEach(practice => {
    const wordId = practice.wordId;
    
    if (!wordStats.has(wordId)) {
      wordStats.set(wordId, { 
        word: practice.word.word, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = wordStats.get(wordId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–æ–≤–∞ —Å –º–∏–Ω–∏–º—É–º 3 –ø–æ–ø—ã—Ç–∫–∞–º–∏
  const result = Array.from(wordStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.word,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(word => word.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–æ—Ü–µ–Ω—Ç—É –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
  
  return result.slice(0, 5); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ø-5 –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Å–ª–æ–≤
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –ø–∞—Ä–æ–Ω–∏–º–∞–º
async function getParonymDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 30 –¥–Ω–µ–π
  const startDate = subDays(new Date(), periodDays);
  
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –¥–Ω—è–º
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–∞—Ä –ø–∞—Ä–æ–Ω–∏–º–æ–≤
async function getProblemParonyms(
  prisma: PrismaClient, 
  userId: number
): Promise<ProblemWord[]> {
  // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–∞—Ä–æ–Ω–∏–º–æ–≤
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
    },
    include: {
      paronymPair: {
        include: {
          words: true,
        },
      },
    },
  });
  
  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –ø–∞—Ä–∞–º –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –∏ —Å—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  const pairStats = new Map<number, { 
    words: string, 
    total: number, 
    correct: number 
  }>();
  
  practices.forEach(practice => {
    const pairId = practice.paronymPairId;
    
    if (!pairStats.has(pairId)) {
      // –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É —Å –ø–∞—Ä–æ–Ω–∏–º–∞–º–∏ —á–µ—Ä–µ–∑ "/"
      const wordString = practice.paronymPair.words.map(w => w.word).join(' / ');
      
      pairStats.set(pairId, { 
        words: wordString, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = pairStats.get(pairId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –º–∞—Å—Å–∏–≤ –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–∞—Ä—ã —Å –º–∏–Ω–∏–º—É–º 3 –ø–æ–ø—ã—Ç–∫–∞–º–∏
  const result = Array.from(pairStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.words,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(pair => pair.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–æ—Ü–µ–Ω—Ç—É –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
  
  return result.slice(0, 5); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ø-5 –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –ø–∞—Ä
}
</file>

<file path="backend/src/router/Practice/GetUserStats/input.ts">
import { z } from "zod";

export const zGetUserStats = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  period: z.number().optional(), // –ø–µ—Ä–∏–æ–¥ –≤ –¥–Ω—è—Ö (7, 30, etc.)
});
</file>

<file path="backend/src/router/Practice/RecordPractice/index.ts">
import { PrismaClient, Practice, User } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zRecordPractice } from "./input";

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
type StressPracticeResult = {
  success: boolean;
  practice: Practice;
};

type ParonymPracticeResult = {
  success: boolean;
  paronymPractice: {
    id: number;
    userId: number;
    paronymPairId: number;
    selectedWordId: number;
    correctWordId: number;
    correct: boolean;
    createdAt: Date;
  };
};

type PracticeResult = StressPracticeResult | ParonymPracticeResult;

export const RecordPracticeTrpcRoute = trpcLoggedProcedure
  .input(zRecordPractice)
  .mutation(async ({ input, ctx }): Promise<PracticeResult> => {
    const user = ctx.me;
    
    if (!user) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è",
      });
    }
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø–æ –≤—Ö–æ–¥–Ω—ã–º –¥–∞–Ω–Ω—ã–º, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω —è–≤–Ω–æ
    const practiceType = input.type || 
      (input.wordId ? "STRESS" : input.paronymPairId ? "PARONYM" : undefined);
    
    if (!practiceType) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏",
      });
    }
    
    try {
      if (practiceType === "STRESS") {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–æ–ª–µ–π –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ —É–¥–∞—Ä–µ–Ω–∏–π
        if (!input.wordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "–î–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ —É–¥–∞—Ä–µ–Ω–∏–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å wordId",
          });
        }
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∞–∫—Ç–∏–∫–∏ —É–¥–∞—Ä–µ–Ω–∏–π
        const practice = await ctx.prisma.practice.create({
          data: {
            userId: user.id,
            wordId: input.wordId,
            correct: input.correct,
          },
        });
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, practice };
      } 
      else if (practiceType === "PARONYM") {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–æ–ª–µ–π –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø–∞—Ä–æ–Ω–∏–º–æ–≤
        if (!input.paronymPairId || !input.selectedWordId || !input.correctWordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "–î–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å paronymPairId, selectedWordId –∏ correctWordId",
          });
        }
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø–∞—Ä–æ–Ω–∏–º–æ–≤
        const paronymPractice = await ctx.prisma.paronymPractice.create({
          data: {
            userId: user.id,
            paronymPairId: input.paronymPairId,
            selectedWordId: input.selectedWordId,
            correctWordId: input.correctWordId,
            correct: input.correct,
          },
        });
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, paronymPractice };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø –ø—Ä–∞–∫—Ç–∏–∫–∏",
      });
    } catch (error) {
      
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∞–∫—Ç–∏–∫–∏",
        cause: error,
      });
    }
  });

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async function updateUserScore(
  prisma: PrismaClient, 
  userId: number, 
  correct: boolean
): Promise<User> {
  return prisma.user.update({
    where: { id: userId },
    data: {
      score: {
        increment: correct ? 1 : 0,
      },
    },
  });
}
</file>

<file path="backend/src/utils/env.ts">
/* eslint-disable no-console */
import fs from 'fs';
import path from 'path';
import {zEnvNonemptyTrimmed} from '@russian-stress-practice/shared/src/zod'
import * as dotenv from "dotenv";
import { z } from "zod";

const findFileDeep = (startDir: string, targetFilename: string): string | null => {
  const entries = fs.readdirSync(startDir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(startDir, entry.name);
    if (entry.isFile() && entry.name === targetFilename) {
      return fullPath;
    } else if (entry.isDirectory()) {
      const found = findFileDeep(fullPath, targetFilename);
      if (found) return found;
    }
  }

  return null;
};

// const prodSecretPath = "/etc/secrets/.backend.env";

// if (localSecretPath) {
//   // eslint-disable-next-line no-console
//   console.log('‚úÖ Loading env from:', localSecretPath);
//   const result = dotenv.config({ path: localSecretPath });
//   // eslint-disable-next-line no-console
//   console.log('‚úÖ dotenv result:', result);
//   console.log('‚úÖ process.env.PORT:', process.env.PORT);
// } else {
//   console.warn('‚ö†Ô∏è  No .backend.env file found!');
// }

// if (process.env.NODE_ENV === "production") {
//   const projectRoot = path.resolve(__dirname, "../../../../../");
// const localSecretPath = findFileDeep(projectRoot, ".backend.env");
//   if (localSecretPath) {
//    console.log('loaded prod local');
//   dotenv.config({ path: localSecretPath });
//   } else {
//     console.log('loaded local');
//     dotenv.config();
//   }
// } else {
//   dotenv.config();
// }
const envPath = findFileDeep(path.resolve(__dirname, "../../../"), ".env")
if (envPath) {
  dotenv.config({path: envPath})
} else {
  dotenv.config()
}
const zEnv = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().min(1),
  HOST_ENV: z.enum(['local', 'production']).default('local'),
  DEBUG: z
  .string()
  .optional()
  .refine(
    (val) => process.env.HOST_ENV === 'local' || process.env.NODE_ENV !== 'production' || (!!val && val.length > 0),
    'Required on not local host on production'
  ),
  FRONTEND_URL: zEnvNonemptyTrimmed,
  JWT_SECRET: zEnvNonemptyTrimmed
});

export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/components/Navigation.tsx">
import React, { useState, useEffect } from "react";
import { Link, useLocation } from "react-router-dom";
import Login from "./Login";
import {
  LogoutIcon,
  ParonymsLogo,
  SignInLogo,
  StressLogo,
  SymbolLogo,
} from "./svg/svgNative";
import { useMe } from "../utils/ctx";
import { useStats } from "../utils/statsContext";
import { GetLogOut, GetParonymsPractice, GetStressPractice, GetPersonalDictionary } from "../utils/routes";

export default function Navigation() {
  const location = useLocation();
  const [isLoginOpen, setIsLoginOpen] = useState(false);
  const me = useMe();
  const { toggleStats } = useStats();

  // –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∏ –≤–≤–µ—Ä—Ö—É, –∏ –≤–Ω–∏–∑—É
  const navigationContent = (
    <>
      <Link
        to={GetStressPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetStressPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <StressLogo />
          <span className="hidden md:inline">–£–¥–∞—Ä–µ–Ω–∏—è</span>
        </div>
      </Link>
      <Link
        to={GetParonymsPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetParonymsPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <ParonymsLogo />
          <span className="hidden md:inline">–ü–∞—Ä–æ–Ω–∏–º—ã</span>
        </div>
      </Link>
      <Link
        to={GetPersonalDictionary()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetPersonalDictionary()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-5 w-5 mr-2"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
          </svg>
          <span className="hidden md:inline">–õ–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å</span>
        </div>
      </Link>
    </>
  );

  return (
    <>
      {/* –í–µ—Ä—Ö–Ω—è—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è - –≤–∏–¥–Ω–∞ —Ç–æ–ª—å–∫–æ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–∞—Ö */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10 hidden md:block">
        <div className="container mx-auto flex justify-between items-center">
          <div className="text-xl font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            –†—É—Å—Å–∫–∏–π —è–∑—ã–∫: –¢—Ä–µ–Ω–∞–∂–µ—Ä—ã
          </div>
          <div className="flex items-center space-x-2">
            {navigationContent}
            {me ? (
              <div className="flex items-center">
                <div className="px-4 py-2 rounded-lg bg-indigo-100 text-indigo-700 flex items-center">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-5 w-5 mr-2"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"
                      clipRule="evenodd"
                    />
                  </svg>
                  {me.name || me.email}
                  <div className="ml-3 p-1 bg-white rounded-lg">
                    <Link to={GetLogOut()}>
                      <button
                        className="px-3 py-1 rounded-md bg-red-100 text-red-700 hover:bg-red-200 transition-colors duration-200 flex items-center"
                      >
                        <LogoutIcon />
                      </button>
                    </Link>
                  </div>
                </div>
              </div>
            ) : (
              <div className="flex">
                <button
                  onClick={() => setIsLoginOpen(true)}
                  className="ml-4 px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors duration-200 flex items-center"
                >
                  <SignInLogo />
                  –í–æ–π—Ç–∏
                </button>
              </div>
            )}
          </div>
        </div>
      </nav>

      {/* –í–µ—Ä—Ö–Ω—è—è –º–∏–Ω–∏-–Ω–∞–≤–∏–≥–∞—Ü–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö - —Ç–æ–ª—å–∫–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –∫–Ω–æ–ø–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-3 px-4 sticky top-0 z-10 md:hidden">
        <div className="flex justify-between items-center">
          <div className="text-lg font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            <span className="ml-1">–¢—Ä–µ–Ω–∞–∂–µ—Ä—ã</span>
          </div>
          <button 
            id="stats-toggle-button"
            onClick={toggleStats}
            className="p-2 rounded-lg bg-slate-100 text-slate-700"
            aria-label="–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
          </button>
        </div>
      </nav>

      {/* –ù–∏–∂–Ω—è—è –Ω–∞–≤–∏–≥–∞—Ü–∏—è - –≤–∏–¥–Ω–∞ —Ç–æ–ª—å–∫–æ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */}
      <nav className="bg-white shadow-lg border-t border-slate-200 text-slate-700 py-2 px-4 fixed bottom-0 left-0 right-0 z-10 md:hidden">
        <div className="flex justify-around items-center">
          {navigationContent}
          {me ? (
            <Link to={GetLogOut()} className="px-3 py-2 rounded-lg text-red-600">
              <LogoutIcon />
            </Link>
          ) : (
            <button
              onClick={() => setIsLoginOpen(true)}
              className="px-3 py-2 rounded-lg text-indigo-600"
            >
              <SignInLogo />
            </button>
          )}
        </div>
      </nav>

      <Login isOpen={isLoginOpen} onClose={() => setIsLoginOpen(false)} />
    </>
  );
}
</file>

<file path="frontend/src/components/PersonalDictionaryButton/index.tsx">
import React, { useState, useEffect } from "react";
import { BookmarkIcon as BookmarkOutlineIcon } from "@heroicons/react/24/outline";
import { BookmarkIcon as BookmarkSolidIcon } from "@heroicons/react/24/solid";
import trpc from "../../utils/trpc";

interface PersonalDictionaryButtonProps {
  type: "STRESS" | "PARONYM";
  id: number | undefined;
  initialIsPersonal?: boolean;
  onToggle?: (isPersonal: boolean) => void;
}

const PersonalDictionaryButton: React.FC<PersonalDictionaryButtonProps> = ({
  type,
  id,
  initialIsPersonal,
  onToggle,
}) => {
  const [isPersonal, setIsPersonal] = useState(initialIsPersonal || false);
  const utils = trpc.useUtils(); // –ü–æ–ª—É—á–∞–µ–º utils –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —É—Ä–æ–≤–Ω–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —ç–ª–µ–º–µ–Ω—Ç –≤ –ª–∏—á–Ω–æ–º —Å–ª–æ–≤–∞—Ä–∏–∫–µ
  const { data: checkResult } = trpc.CheckPersonalItem.useQuery(
    { type, id: id! },
    { enabled: id !== undefined && initialIsPersonal === undefined }
  );

  // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–≥–¥–∞ –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏
  useEffect(() => {
    if (checkResult) {
      setIsPersonal(checkResult.isPersonal);
    }
  }, [checkResult]);

  // –ú—É—Ç–∞—Ü–∏–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è/—É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
  const togglePersonalWord = trpc.TogglePersonalWord.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–µ—à –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
      utils.GetPersonalDictionary.invalidate();
      utils.CheckPersonalItem.invalidate();
    },
  });

  const togglePersonalParonym = trpc.TogglePersonalParonym.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–µ—à –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞
      utils.GetPersonalDictionary.invalidate();
      utils.CheckPersonalItem.invalidate();
    },
  });

  const handleToggle = () => {
    if (!id) return;
    if (type === "STRESS") {
      togglePersonalWord.mutate({
        wordId: id,
        isPersonal: !isPersonal,
      });
    } else if (type === "PARONYM") {
      togglePersonalParonym.mutate({
        paronymPairId: id,
        isPersonal: !isPersonal,
      });
    }
  };

  return (
    <>
      <button
        onClick={handleToggle}
        className="p-2 rounded-full hover:bg-slate-100 transition-colors"
        title={
          isPersonal
            ? "–£–¥–∞–ª–∏—Ç—å –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞"
            : "–î–æ–±–∞–≤–∏—Ç—å –≤ –ª–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä–∏–∫"
        }
      >
        {isPersonal ? (
          <BookmarkSolidIcon className="h-5 w-5 text-indigo-600" />
        ) : (
          <BookmarkOutlineIcon className="h-5 w-5 text-slate-500" />
        )}
      </button>
    </>
  );
};

export default PersonalDictionaryButton;
</file>

<file path="frontend/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { GoogleOAuthProvider } from "@react-oauth/google";
import { env } from "./utils/env";
import "./index.css";

const rootElement = document.getElementById("root");
if (rootElement) {
  ReactDOM.createRoot(rootElement).render(
    <GoogleOAuthProvider clientId={env.VITE_GOOGLE_CLIENT_ID}>
      <React.StrictMode>
        <App />
      </React.StrictMode>
    </GoogleOAuthProvider>
  );
} else {
  console.error("Root element not found");
}
</file>

<file path="frontend/src/pages/ParonymsPage/ParonymsInterface.tsx">
import React, { useState, useEffect } from "react";
import { shuffleArray } from "../../utils/utils";
import { Paronym, ParonymGroup } from "../../types/nodes";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface ParonymsInterfaceProps {
  paronymGroups: ParonymGroup[];
  isLoading: boolean;
  statsPeriod: number | undefined;
  setStatsPeriod: (period?: number) => void;
  recordPractice: (paronymId: number, selectedWord: string, correct: boolean) => void;
  isPersonalDictionary: boolean;
}

export default function ParonymsInterface({
  paronymGroups,
  isLoading,
  statsPeriod,
  setStatsPeriod,
  recordPractice,
  isPersonalDictionary,
}: ParonymsInterfaceProps) {
  // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const { isStatsVisible } = useStats();

  // State for the current paronym group being practiced
  const [currentParonymGroup, setCurrentParonymGroup] = useState<ParonymGroup | null>(null);

  // State to track the user's selected paronym
  const [selectedParonym, setSelectedParonym] = useState<string | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to track if all paronyms are completed
  const [allCompleted, setAllCompleted] = useState(false);

  // Add state to track the correct word for the current task
  const [correctWord, setCorrectWord] = useState<string | null>(null);

  // Load a random paronym group
  const loadRandomParonymGroup = () => {
    if (paronymGroups.length === 0) {
      setCurrentParonymGroup(null);
      setAllCompleted(true);
      return;
    }

    // Get a random paronym group
    const randomIndex = Math.floor(Math.random() * paronymGroups.length);
    const randomGroup = paronymGroups[randomIndex];

    // Shuffle the paronyms in the group
    const shuffledParonyms = shuffleArray([...randomGroup.paronyms]);
    
    // Randomly select one paronym as the correct one for this task
    const correctIndex = Math.floor(Math.random() * shuffledParonyms.length);
    const correctParonym = shuffledParonyms[correctIndex];
    
    // Create a task from the selected paronym's explanation
    const task = `–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–≤–æ, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏—é: ${correctParonym.explanation}`;
    
    // Store the correct word for this task
    setCorrectWord(correctParonym.word);
    
    setCurrentParonymGroup({
      ...randomGroup,
      context: task,
      paronyms: shuffledParonyms,
    });
    
    setSelectedParonym(null);
    setFeedback("");
  };

  // Handle user selecting a paronym
  const handleSelect = (paronym: Paronym) => {
    // Only allow selection if no feedback is currently shown
    if (feedback) return;

    // Guard against no current paronym group or no correct word
    if (!currentParonymGroup || !correctWord) return;

    setSelectedParonym(paronym.word);

    // Check if the selected paronym is correct
    const isCorrect = paronym.word === correctWord;
    
    // Find the correct paronym object
    const correctParonymObj = currentParonymGroup.paronyms.find(p => p.word === correctWord);
    
    if (!correctParonymObj) {
      console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–∞—Ä–æ–Ω–∏–º");
      return;
    }

    // Record practice attempt to backend with both selected word and correct word
    if (currentParonymGroup.id) {
      recordPractice(
        currentParonymGroup.id, 
        correctParonymObj.word, // –ü–µ—Ä–µ–¥–∞–µ–º —Å–ª–æ–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–∞—Ä–æ–Ω–∏–º–∞
        isCorrect
      );
    }

    if (isCorrect) {
      setFeedback("‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ! " + paronym.explanation);
    } else {
      // Find the correct paronym for the explanation
      const correctParonym = currentParonymGroup.paronyms.find(p => p.word === correctWord);
      setFeedback(`‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: ${correctParonym?.word}. ${correctParonym?.explanation}`);
    }
  };

  // Load initial paronym group
  useEffect(() => {
    if (paronymGroups.length > 0 && !currentParonymGroup) {
      loadRandomParonymGroup();
    } else if (paronymGroups.length === 0 && !isLoading) {
      setAllCompleted(true);
    }
  }, [paronymGroups, isLoading]);

  // –ï—Å–ª–∏ –Ω–∞ –º–æ–±–∏–ª—å–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –æ—Ç–∫—Ä—ã—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for stats - —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–æ–≤ */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="PARONYM"
          period={statsPeriod}
          onPeriodChange={setStatsPeriod}
        />
        
        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            –í—ã –ø—Ä–∞–∫—Ç–∏–∫—É–µ—Ç–µ –ø–∞—Ä–æ–Ω–∏–º—ã –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            –¢—Ä–µ–Ω–∞–∂–µ—Ä –ø–∞—Ä–æ–Ω–∏–º–æ–≤
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : allCompleted ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {paronymGroups.length === 0 
                  ? (isPersonalDictionary 
                    ? "–í –≤–∞—à–µ–º —Å–ª–æ–≤–∞—Ä–µ –Ω–µ—Ç –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏" 
                    : "–°–ø–∏—Å–æ–∫ –ø–∞—Ä–æ–Ω–∏–º–æ–≤ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø—É—Å—Ç")
                  : "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!"}
              </h2>
              {paronymGroups.length === 0 ? (
                <p className="text-slate-600 mb-6">
                  {isPersonalDictionary
                    ? "–î–æ–±–∞–≤—å—Ç–µ –ø–∞—Ä–æ–Ω–∏–º—ã –≤ –ª–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –≤–æ –≤—Ä–µ–º—è –æ–±—ã—á–Ω–æ–π –ø—Ä–∞–∫—Ç–∏–∫–∏"
                    : "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–∞—Ä–æ–Ω–∏–º–æ–≤"}
                </p>
              ) : (
                <>
                  <p className="text-slate-600 mb-6">
                    –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞—Ä–æ–Ω–∏–º—ã. –•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—Ä–∞–∫—Ç–∏–∫—É?
                  </p>
                  <button
                    onClick={loadRandomParonymGroup}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    –ü—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å—Å—è –µ—â–µ
                  </button>
                </>
              )}
            </div>
          ) : currentParonymGroup ? (
            <>
               <div className="bg-white p-4 sm:p-6 md:p-8 pt-14 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* –ö–Ω–æ–ø–∫–∞ –¥–ª—è –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è (—Ç–æ–ª—å–∫–æ –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.PARONYM}
                      id={currentParonymGroup.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  {currentParonymGroup.context}
                </h2>
                
                {/* –í–∞—Ä–∏–∞–Ω—Ç—ã –ø–∞—Ä–æ–Ω–∏–º–æ–≤ */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                  {currentParonymGroup.paronyms.map((paronym) => (
                    <button
                      key={paronym.word}
                      onClick={() => handleSelect(paronym)}
                      disabled={!!feedback}
                      className={`
                        p-4 rounded-xl text-lg font-medium transition-all duration-200
                        ${!feedback ? 'hover:bg-indigo-50 hover:border-indigo-200 active:bg-indigo-100' : ''}
                        ${selectedParonym === paronym.word && paronym.word === correctWord ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        ${selectedParonym === paronym.word && paronym.word !== correctWord ? 'bg-rose-100 border-rose-300 text-rose-800' : ''}
                        ${!selectedParonym ? 'bg-white border-slate-200 text-slate-700' : ''}
                        ${feedback && paronym.word === correctWord && selectedParonym !== paronym.word ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        border-2
                      `}
                    >
                      {paronym.word}
                    </button>
                  ))}
                </div>
                
                {/* –°–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 p-4 rounded-xl mx-auto
                    ${feedback.includes('–ü—Ä–∞–≤–∏–ª—å–Ω–æ') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg mb-2 font-medium">
                      {feedback.includes('–ü—Ä–∞–≤–∏–ª—å–Ω–æ') ? '‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!' : '‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ!'}
                    </p>
                    
                    {/* –û–±—ä—è—Å–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Å–ª–æ–≤ –≤ –≥—Ä—É–ø–ø–µ */}
                    <div className="mt-3 space-y-2">
                      {currentParonymGroup?.paronyms.map((paronym) => (
                        <div key={paronym.id} className={`p-2 rounded ${
                          paronym.word === correctWord 
                            ? 'bg-white border border-emerald-100' 
                            : 'bg-white border border-slate-100'
                        }`}>
                          <p className="font-medium">{paronym.word}</p>
                          <p className="text-sm">{paronym.explanation}</p>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
                
                {/* –ö–Ω–æ–ø–∫–∞ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –ø–∞—Ä–æ–Ω–∏–º—ã */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadRandomParonymGroup}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      –°–ª–µ–¥—É—é—â–∏–π –ø–∞—Ä–æ–Ω–∏–º
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
} from "../../utils/utils";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface StressPracticeInterfaceProps {
  words: Word[];
  isLoading: boolean;
  statsParams: UserStatsParams;
  changeStatsPeriod: (period?: number) => void;
  recordPractice: (wordId: number, correct: boolean) => void;
  isPersonalDictionary: boolean;
  stats?: UserStats;
  isStatsLoading: boolean;
  vowels: string[];
  today: Date;
  setWords?: (updater: (prevWords: Word[]) => Word[]) => void;
}

export default function StressPracticeInterface({
  words,
  isLoading,
  statsParams,
  changeStatsPeriod,
  recordPractice,
  isPersonalDictionary,
  stats,
  isStatsLoading,
  vowels,
  today,
  setWords,
}: StressPracticeInterfaceProps) {
  // –ü–æ–ª—É—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const { isStatsVisible } = useStats();

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState<Word | null>(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState<number | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);
  const [isInitialWordLoadPending, setIsInitialWordLoadPending] =
    useState(false);

  // –î–æ–±–∞–≤–∏–º –Ω–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—É—Å—Ç–æ–≥–æ —Å–ø–∏—Å–∫–∞ —Å–ª–æ–≤
  const [emptyWordsList, setEmptyWordsList] = useState(false);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter((w) => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split("") : [];

  // Load the next word to practice
  const loadNextWord = (): void => {
    const due = getDueWords(words, today);
    // console.log(
    //   "Loading next word. Due words:",
    //   due.length,
    //   "Total words:",
    //   words.length
    // );

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else if (words.length > 0) {
      // –ï—Å–ª–∏ –µ—Å—Ç—å —Å–ª–æ–≤–∞, –Ω–æ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ —Å–µ–≥–æ–¥–Ω—è
      setCurrentWord(null);
      setAllLearned(true);
    } else {
      // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –ø—É—Å—Ç
      setCurrentWord(null);
      setAllLearned(false);
    }

    setSelected(null);
    setFeedback("");
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx: number): void => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–≤–µ—Ç
    const isCorrect = idx === currentWord.accentIdx;

    // Record practice attempt to backend
    if (currentWord.id) {
      recordPractice(currentWord.id, isCorrect);
    }

    if (isCorrect) {
      // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Å–ø–µ—Ö
      setFeedback("‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!");

      // Update the word's learning metadata locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak += 1;

            // If streak reaches 4, retire the word
            if (word.correctStreak >= 4) {
              word.retired = true;
            } else {
              // Otherwise, schedule next review based on streak
              word.nextReview = computeNextReview(word.correctStreak, today);
            }
          });
        });
      }
    } else {
      // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
      setFeedback("‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç –≤—ã–¥–µ–ª–µ–Ω.");

      // Reset the word's streak locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak = 0;
            word.wrongCount += 1;
            word.nextReview = addDays(today, 1); // Review again tomorrow
          });
        });
      }
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = (): void => {
    setShowAllWords((prev) => !prev);
  };

  // Load initial word when words are loaded
  useEffect(() => {
    if (words.length > 0 && !currentWord) {
      loadNextWord();
      setEmptyWordsList(false);
    } else if (words.length === 0 && !isLoading) {
      // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –ø—É—Å—Ç, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ñ–ª–∞–≥
      setEmptyWordsList(true);
      setAllLearned(false);
    }
  }, [words, isLoading]);

  // –ï—Å–ª–∏ –Ω–∞ –º–æ–±–∏–ª—å–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –æ—Ç–∫—Ä—ã—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats - —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–æ–≤ */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="STRESS"
          period={statsParams.period}
          onPeriodChange={changeStatsPeriod}
        />

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-4 px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? "–ü–æ–∫–∞–∑–∞—Ç—å –∏–∑—É—á–∞–µ–º—ã–µ" : "–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ —Å–ª–æ–≤–∞"}
        </button>

        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            –í—ã –ø—Ä–∞–∫—Ç–∏–∫—É–µ—Ç–µ —Å–ª–æ–≤–∞ –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            –¢—Ä–µ–Ω–∞–∂–µ—Ä —É–¥–∞—Ä–µ–Ω–∏–π
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : emptyWordsList ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {isPersonalDictionary
                  ? "–í –≤–∞—à–µ–º —Å–ª–æ–≤–∞—Ä–µ –Ω–µ—Ç —Å–ª–æ–≤ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏"
                  : "–°–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏ –ø—É—Å—Ç"}
              </h2>
              <p className="text-slate-600 mb-6">
                {isPersonalDictionary
                  ? "–î–æ–±–∞–≤—å—Ç–µ —Å–ª–æ–≤–∞ –≤ –ª–∏—á–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –≤–æ –≤—Ä–µ–º—è –æ–±—ã—á–Ω–æ–π –ø—Ä–∞–∫—Ç–∏–∫–∏"
                  : "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–ª–æ–≤"}
              </p>
            </div>
          ) : allLearned ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!
              </h2>
              <p className="text-slate-600 mb-6">
                –í—ã –ø–æ–≤—Ç–æ—Ä–∏–ª–∏ –≤—Å–µ —Å–ª–æ–≤–∞ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è. –í–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ—Å—å –∑–∞–≤—Ç—Ä–∞ –¥–ª—è
                –Ω–æ–≤–æ–π –ø—Ä–∞–∫—Ç–∏–∫–∏!
              </p>
              <button
                onClick={() => setAllLearned(false)}
                className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
              >
                –ü—Ä–∞–∫—Ç–∏–∫–æ–≤–∞—Ç—å—Å—è –µ—â–µ
              </button>
            </div>
          ) : currentWord ? (
            <>
              <div className="bg-white p-4 sm:p-6 md:p-8 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* –ö–Ω–æ–ø–∫–∞ –¥–ª—è –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è (—Ç–æ–ª—å–∫–æ –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.STRESS}
                      id={currentWord.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  –í—ã–±–µ—Ä–∏—Ç–µ —É–¥–∞—Ä–Ω—ã–π —Å–ª–æ–≥
                </h2>
                
                {/* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ª–æ–≤–∞ */}
                <div className="w-full overflow-x-auto mb-6 sm:mb-8 py-2">
                  <div className="flex justify-center items-center space-x-1 sm:space-x-2 text-3xl sm:text-4xl md:text-5xl min-w-min mx-auto">
                    {letters.map((letter, idx) => {
                      const isVowel = vowels.includes(letter.toLowerCase());
                      const isCorrect = idx === currentWord?.accentIdx;
                      const isSelected = selected === idx;
                      const showCorrect = feedback && isCorrect;

                      return (
                        <span
                          key={idx}
                          onClick={() => handleSelect(idx)}
                          className={`
                            relative cursor-pointer px-1 sm:px-2 py-1 rounded-lg transition-all duration-200
                            ${isVowel ? 'hover:bg-slate-100 hover:transform hover:scale-110 active:bg-slate-200 active:scale-105' : 'cursor-default'}
                            ${isSelected && isCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                            ${isSelected && !isCorrect ? 'bg-rose-500 text-white' : ''}
                            ${showCorrect && !isSelected ? 'bg-emerald-500 text-white transform scale-110' : ''}
                          `}
                        >
                          {letter}
                          {isVowel && (
                            <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                          )}
                        </span>
                      );
                    })}
                  </div>
                </div>
                
                {/* –°–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 text-center py-2 sm:py-3 px-3 sm:px-4 rounded-xl mx-auto max-w-md
                    ${feedback.includes('–ü—Ä–∞–≤–∏–ª—å–Ω–æ') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg flex items-center justify-center">
                      {feedback}
                    </p>
                  </div>
                )}
                
                {/* –ö–Ω–æ–ø–∫–∞ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–ª–æ–≤—É */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadNextWord}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      –°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils/utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["—Ç–ï—Å—Ç", "–ø—Ä–∏–º–ï—Ä"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("—Ç–µ—Å—Ç");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("–ø—Ä–∏–º–µ—Ä");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "—Ç–µ—Å—Ç", accentIdx: 1, correctStreak: 0 },
      { word: "–ø—Ä–∏–º–µ—Ä", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "—Ç–µ—Å—Ç", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("—Ç–µ—Å—Ç");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "—Ç–µ—Å—Ç", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "—Ç–µ—Å—Ç", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "—Ç–µ—Å—Ç1", nextReview: yesterday, retired: false },
      { word: "—Ç–µ—Å—Ç2", nextReview: today, retired: false },
      { word: "—Ç–µ—Å—Ç3", nextReview: tomorrow, retired: false },
      { word: "—Ç–µ—Å—Ç4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "—Ç–µ—Å—Ç1")).toBe(true);
    expect(result.some(w => w.word === "—Ç–µ—Å—Ç2")).toBe(true);
    expect(result.some(w => w.word === "—Ç–µ—Å—Ç3")).toBe(false);
    expect(result.some(w => w.word === "—Ç–µ—Å—Ç4")).toBe(false);
  });
});
</file>

<file path="frontend/src/utils/env.ts">
import { z } from "zod";
import zEnvNonemptyTrimmed, {zEnvHost} from '@russian-stress-practice/shared/src/zod'
 
export const zEnv = z.object({
  VITE_BACKEND_TRPC_URL: zEnvNonemptyTrimmed,
  VITE_WEBAPP_URL: zEnvNonemptyTrimmed,
  HOST_ENV: zEnvHost,
  VITE_GOOGLE_CLIENT_ID: zEnvNonemptyTrimmed,
  VITE_GOOGLE_REDIRECT_URI: zEnvNonemptyTrimmed,
  NODE_ENV: z.enum(["development", "production"]),
  VITE_PORT: zEnvNonemptyTrimmed
});

// eslint-disable-next-line no-restricted-syntax
export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/utils/routes.ts">
import { pgr } from "./pumpGetRoute";

export const GetStressPractice = pgr(() => "/");
export const GetParonymsPractice = pgr(() => "/paronyms");
export const GetLogOut = pgr(() => "/logout");
export const GetPersonalDictionary = () => "/personal-dictionary";
</file>

<file path="frontend/src/utils/trpc.tsx">
import { env } from "./env";
import React from 'react'
import { createTRPCReact } from "@trpc/react-query";
import type { TrpcRouter } from "@russian-stress-practice/backend/src/router";
import Cookies from "js-cookie";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { httpBatchLink, loggerLink } from "@trpc/react-query";
import { SuperJSON } from "superjson";

const trpc = createTRPCReact<TrpcRouter>();

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
    },
  },
});
const trpcClient = trpc.createClient({
  transformer: SuperJSON,
  links: [
    loggerLink({
      enabled: () => env.NODE_ENV === 'development',
    }),
    httpBatchLink({
      url: env.VITE_BACKEND_TRPC_URL,
      headers: () => {
        const token = Cookies.get('token');
        console.log('Using token for request:', token ? 'Token exists' : 'No token');
        return {
          ...(token && { Authorization: `Bearer ${token}` })
        };
      },
      fetch: (url, options) => {
        console.log('Making TRPC request to:', url);
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});

export const TrpcProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
};

export default trpc;
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "jsx": "react",
    "allowJs": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "../shared/src/zod.ts"]
}
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "frontend"
  - "backend"
  - "shared"
</file>

<file path="backend/package.json">
{
  "name": "@russian-stress-practice/backend",
  "version": "0.0.0",
  "private": "true",
  "devDependencies": {
    "@prisma/client": "^6.6.0",
    "@sentry/cli": "^2.43.0",
    "@types/cors": "^2.8.17",
    "@types/debug": "^4.1.12",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/lodash": "^4.17.15",
    "@types/node": "^22.10.7",
    "@types/passport": "^1.0.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/triple-beam": "^1.3.5",
    "@typescript-eslint/eslint-plugin": "^8.26.1",
    "@typescript-eslint/parser": "^8.26.1",
    "dotenv-cli": "^8.0.0",
    "eslint-plugin-import": "^2.31.0",
    "prisma": "^6.6.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0"
  },
  "scripts": {
    "dev": "ts-node-dev --rs --exit-child ./src/index.ts",
    "build": "rimraf ./dist && tsc --build ./tsconfig.build.json",
    "start": "NODE_ENV=production ts-node -r tsconfig-paths/register ./dist/backend/src/index.js",
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache .",
    "pmd": "prisma migrate dev",
    "pmt": "dotenv -e ./.env.test prisma migrate deploy",
    "pgc": "prisma generate",
    "test": "jest --runInBand",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "preset-db": "ts-node src/scripts/presetDB.ts",
    "preset-paronyms": "ts-node src/scripts/importParonyms.ts"
  },
  "prisma": {
    "schema": "./src/prisma/schema.prisma"
  },
  "dependencies": {
    "@russian-stress-practice/frontend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@trpc/server": "^10.45.2",
    "axios": "^1.8.4",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "cron": "^4.1.3",
    "cross-env": "^7.0.3",
    "date-fns": "^4.1.0",
    "debug": "^4.4.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "fast-glob": "^3.3.3",
    "handlebars": "^4.7.8",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "picocolors": "^1.1.1",
    "randomstring": "^1.3.1",
    "serialize-error": "^8.1.0",
    "superjson": "1.13.1",
    "triple-beam": "^1.4.1",
    "trpc-playground": "^1.0.4",
    "tsconfig-paths": "^4.2.0",
    "winston": "^3.17.0",
    "yaml": "^2.7.1",
    "zod": "^3.24.2"
  }
}
</file>

<file path="backend/src/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  name          String?
  score         Int       @default(0)
  provider      Provider  
  providerId    String    
  accessToken   String? 
  refreshToken  String?  
  tokenExpires  DateTime?
  practices     Practice[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  personalWords PersonalWord[] // –°–≤—è–∑—å —Å –ª–∏—á–Ω—ã–º —Å–ª–æ–≤–∞—Ä–∏–∫–æ–º —Å–ª–æ–≤
  personalParonyms PersonalParonym[] // –°–≤—è–∑—å —Å –ª–∏—á–Ω—ã–º —Å–ª–æ–≤–∞—Ä–∏–∫–æ–º –ø–∞—Ä–æ–Ω–∏–º–æ–≤

  @@unique([provider, providerId])
  ParonymPractice ParonymPractice[]
}

enum Provider {
  GOOGLE
  YANDEX
}

model Word {
  id          Int        @id @default(autoincrement())
  word        String
  stress      Int        // –ü–æ–∑–∏—Ü–∏—è —É–¥–∞—Ä–µ–Ω–∏—è
  description String?    // –û–ø–∏—Å–∞–Ω–∏–µ —Å–ª–æ–≤–∞ (–¥–ª—è –ø–∞—Ä–æ–Ω–∏–º–æ–≤)
  practices   Practice[]
  type        PracticeType @default(STRESS)
  paronymPairs ParonymPair[] @relation("ParonymWords")
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  personalWords PersonalWord[] // –°–≤—è–∑—å —Å –ª–∏—á–Ω—ã–º —Å–ª–æ–≤–∞—Ä–∏–∫–æ–º
}

enum PracticeType {
  STRESS   
  PARONYM  
}

model Practice {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  correct   Boolean
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([wordId])
}

model ParonymPair {
  id          Int      @id @default(autoincrement())
  words       Word[]   @relation("ParonymWords")
  description String?  // –û–ø–∏—Å–∞–Ω–∏–µ —Ä–∞–∑–ª–∏—á–∏—è –º–µ–∂–¥—É –ø–∞—Ä–æ–Ω–∏–º–∞–º–∏
  practices   ParonymPractice[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  personalParonyms PersonalParonym[] // –°–≤—è–∑—å —Å –ª–∏—á–Ω—ã–º —Å–ª–æ–≤–∞—Ä–∏–∫–æ–º
}

model ParonymPractice {
  id           Int         @id @default(autoincrement())
  user         User        @relation(fields: [userId], references: [id])
  userId       Int
  paronymPair  ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  selectedWordId Int       // ID –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞
  correctWordId Int        // ID –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–ª–æ–≤–∞
  correct      Boolean     // –ü—Ä–∞–≤–∏–ª—å–Ω–æ –ª–∏ –≤—ã–±—Ä–∞–Ω–æ —Å–ª–æ–≤–æ
  createdAt    DateTime    @default(now())

  @@index([userId])
  @@index([paronymPairId])
}

// –ú–æ–¥–µ–ª—å –¥–ª—è –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞ —Å–ª–æ–≤
model PersonalWord {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  createdAt DateTime @default(now())

  @@unique([userId, wordId]) // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-—Å–ª–æ–≤–æ
  @@index([userId])
  @@index([wordId])
}

// –ú–æ–¥–µ–ª—å –¥–ª—è –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä–∏–∫–∞ –ø–∞—Ä–æ–Ω–∏–º–æ–≤
model PersonalParonym {
  id            Int         @id @default(autoincrement())
  user          User        @relation(fields: [userId], references: [id])
  userId        Int
  paronymPair   ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  createdAt     DateTime    @default(now())

  @@unique([userId, paronymPairId]) // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –¥–ª—è –ø–∞—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å-–ø–∞—Ä–æ–Ω–∏–º
  @@index([userId])
  @@index([paronymPairId])
}
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>–¢—Ä–µ–Ω–∞–∂–µ—Ä —É–¥–∞—Ä–µ–Ω–∏–π</title>
    <meta
      http-equiv="Cross-Origin-Opener-Policy"
      content="same-origin-allow-popups"
    />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/App.tsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './pages/StressPracticePage';
import ParonymsPage from './pages/ParonymsPage';
import PersonalDictionaryPage from './pages/PersonalDictionaryPage';
import { TrpcProvider } from './utils/trpc';
import { AppContextProvider } from './utils/ctx';
import { StatsProvider } from './utils/statsContext';
import { GetLogOut, GetParonymsPractice, GetPersonalDictionary, GetStressPractice } from './utils/routes';
import { LogOutPage } from './pages/LogOutPage';
import Navigation from './components/Navigation';

export default function App() {
  return (
    <TrpcProvider>
      <AppContextProvider>
        <StatsProvider>
          <Router basename="/russian-stress-practice">
            <div className="flex flex-col min-h-screen">
              <Navigation />
              <div className="flex-grow pb-16 md:pb-0"> {/* –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É –¥–ª—è –º–æ–±–∏–ª—å–Ω–æ–π –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ */}
                <Routes>
                  <Route path={GetStressPractice()} element={<StressPracticePage />} />
                  <Route path={GetParonymsPractice()} element={<ParonymsPage />} />
                  <Route path={GetPersonalDictionary()} element={<PersonalDictionaryPage />} />
                  <Route path={GetLogOut()} element={<LogOutPage />} />
                  <Route path="*" element={<div>404</div>} />
                </Routes>
              </div>
            </div>
          </Router>
        </StatsProvider>
      </AppContextProvider>
    </TrpcProvider>
  );
}
</file>

<file path="frontend/src/pages/ParonymsPage/index.tsx">
import React, { useEffect, useState } from "react";
import { useSearchParams } from "react-router-dom";
import ParonymsInterface from "./ParonymsInterface";
import { useStats } from "../../utils/statsContext";
import trpc from "../../utils/trpc";
import PracticeStats from "../../components/PracticeStats";

export default function ParonymsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const isPersonalDictionary = searchParams.get("personal") === "true";
  const [statsPeriod, setStatsPeriod] = useState<number | undefined>(undefined);
  
  // –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç—å—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const { isStatsVisible, toggleStats } = useStats();

  // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–æ–Ω–∏–º—ã
  const { data: paronymsData, isLoading: isParonymsLoading } = trpc.GetParonyms.useQuery(
    undefined,
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  const { data: statsData, isLoading: isStatsLoading, refetch: refetchStats } = trpc.GetUserStats.useQuery(
    { type: "PARONYM", period: statsPeriod },
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–ø–∏—Å–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏
  const recordPracticeMutation = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏
      refetchStats();
    },
  });

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–≤–µ—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const handleRecordPractice = async (paronymId: number, selectedWord: string, isCorrect: boolean) => {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –ø–∞—Ä–æ–Ω–∏–º–∞—Ö
      const paronymPair = paronymsData?.paronyms.find(p => p.id === paronymId);
      if (!paronymPair) {
        console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–∞—Ä—É –ø–∞—Ä–æ–Ω–∏–º–æ–≤ —Å ID:", paronymId);
        return;
      }
      
      // –ù–∞—Ö–æ–¥–∏–º ID –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞
      const selectedParonym = paronymPair.paronyms.find(p => p.word === selectedWord);
      if (!selectedParonym) {
        console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–µ —Å–ª–æ–≤–æ:", selectedWord);
        return;
      }
      
      // –ù–∞—Ö–æ–¥–∏–º ID –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —Å–ª–æ–≤–∞ (—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –∑–∞–¥–∞–Ω–∏—é)
      // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ ParonymsInterface –ø–µ—Ä–µ–¥–∞–µ—Ç –Ω–∞–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ isCorrect
      const correctParonym = paronymPair.paronyms.find(p => 
        isCorrect ? p.word === selectedWord : p.word !== selectedWord
      );
      
      if (!correctParonym) {
        console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–ª–æ–≤–æ");
        return;
      }
      
      await recordPracticeMutation.mutateAsync({
        type: "PARONYM",
        paronymPairId: paronymId,
        selectedWordId: selectedParonym.id,
        correctWordId: correctParonym.id,
        correct: isCorrect
      });
    } catch (error) {
      console.error("Failed to record practice:", error);
    }
  };

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–∏–æ–¥–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const handlePeriodChange = (period?: number) => {
    setStatsPeriod(period);
  };


  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* –ú–æ–±–∏–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ isStatsVisible=true */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="PARONYM"
            period={statsPeriod}
            onPeriodChange={handlePeriodChange}
          />
        </div>
      )}
      
      {/* Main content - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤—Å–µ–≥–¥–∞ –Ω–∞ –¥–µ—Å–∫—Ç–æ–ø–µ –∏ –∫–æ–≥–¥–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∫—Ä—ã—Ç–∞ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */}
      <div className={isStatsVisible ? 'hidden md:block' : ''}>
        <ParonymsInterface
          paronymGroups={(paronymsData?.paronyms || []).map(pg => ({ ...pg, context: "" }))}
          isLoading={isParonymsLoading}
          statsPeriod={statsPeriod}
          setStatsPeriod={handlePeriodChange}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/StressPracticePage/index.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  initializeWords,
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
  shuffleArray,
} from "../../utils/utils";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { PracticeType } from '../../types/practice';
import { useLocation, useNavigate } from "react-router-dom";
import StressPracticeInterface from "./StressPracticeInterface";
import { useStats } from "../../utils/statsContext";
import PracticeStats from "../../components/PracticeStats";

const vowels = ["–∞", "–µ", "—ë", "–∏", "–æ", "—É", "—ã", "—ç", "—é", "—è"];

// Calculate streak from history
const calculateStreak = (history: { correct: boolean; date: Date }[]) => {
  let streak = 0;
  // Count consecutive correct answers from most recent
  for (let i = 0; i < history.length; i++) {
    if (history[i].correct) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
};

// Calculate wrong count from history
const calculateWrongCount = (history: { correct: boolean; date: Date }[]) => {
  return history.filter(h => !h.correct).length;
};

export default function StressPracticePage() {
  const location = useLocation();
  const navigate = useNavigate();
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∑–∞–≥—Ä—É–∂–∞–µ–º –ª–∏ –º—ã —Å–ª–æ–≤–∞ –∏–∑ –ª–∏—á–Ω–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è
  const params = new URLSearchParams(location.search);
  const isPersonalDictionary = params.get("source") === "dictionary";
  
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState<Word[]>([]);

  // Loading state
  const [isLoadingState, setisLoadingState] = useState(true);
  
  // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const [statsParams, setStatsParams] = useState<UserStatsParams>({
    type: "STRESS",
    period: undefined // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
  });
  
  // –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç—å—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const { isStatsVisible, toggleStats } = useStats();
  
  // –ó–∞–ø—Ä–æ—Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å –±—ç–∫–µ–Ω–¥–∞
  const { 
    data: stats, 
    isLoading: isStatsLoading, 
    refetch: refetchStats 
  } = trpc.GetUserStats.useQuery(statsParams, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
  });

  // –ó–∞–º–µ–Ω—è–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–ª–æ–≤ –Ω–∞ –∑–∞–ø—Ä–æ—Å –∫ –±—ç–∫–µ–Ω–¥—É
  const { 
    data: fetchedWords, 
    isLoading: loadingWords 
  } = isPersonalDictionary
    ? trpc.GetPersonalDictionary.useQuery(
        { type: PracticeType.STRESS }, 
        { 
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch dictionary words:", error);
            setisLoadingState(false);
          }
        }
      )
    : trpc.GetPracticeWords.useQuery(
        { type: "STRESS" },
        {
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch practice words:", error);
            setisLoadingState(false);
          }
        }
      );

  // Record practice attempt
  const recordPractice = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏
      refetchStats();
    },
  });

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–∏–æ–¥–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const changeStatsPeriod = (period?: number) => {
    setStatsParams(prev => ({
      ...prev,
      period
    }));
  };

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–ø–∏—Å–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏
  const handleRecordPractice = (wordId: number, correct: boolean) => {
    recordPractice.mutate({
      type: "STRESS",
      wordId: wordId,
      correct: correct
    });
  };


  // Initialize words with learning metadata when fetched
  useEffect(() => {
    if (fetchedWords) {
      // Transform the fetched data to match the expected format
      const initializedWords = isPersonalDictionary
        ? (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }))
        : (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }));
      setWords(initializedWords);
      setisLoadingState(false);
    }
  }, [fetchedWords, today, isPersonalDictionary]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* –ú–æ–±–∏–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ isStatsVisible=true –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white fixed top-0 left-0 right-0 bottom-0 z-50 overflow-y-auto">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="STRESS"
            period={statsParams.period}
            onPeriodChange={changeStatsPeriod}
          />
        </div>
      )}
      
      {/* Main content - –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è, –Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–µ–∫—Ä—ã—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö */}
      <div>
        <StressPracticeInterface
          words={words}
          isLoading={isLoadingState || loadingWords}
          statsParams={statsParams}
          changeStatsPeriod={changeStatsPeriod}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
          stats={stats as unknown as UserStats}
          isStatsLoading={isStatsLoading}
          vowels={vowels}
          today={today}
          setWords={setWords}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/types/nodes.ts">
export interface Word {
  id?: number;
  word: string;
  accentIdx: number;
  retired?: boolean;
  correctStreak: number;
  wrongCount: number;
  nextReview: Date;
}

export interface PracticeHistory {
  correct: boolean;
  date: Date;
}

export interface UserStatsSummary {
  totalAttempts: number;
  correctAttempts: number;
  correctRate: number;
  recentStats?: {
    totalAttempts: number;
    correctAttempts: number;
  };
}

export interface DailyStats {
  date: string;
  total: number;
  correct: number;
  rate: number;
}

export interface ProblemWord {
  word: string;
  total: number;
  correct: number;
  type: string;
}

export interface UserStats {
  summary: UserStatsSummary;
  dailyStats: DailyStats[];
  problemWords: ProblemWord[];
}

export interface UserStatsParams {
  type: 'STRESS' | 'PARONYM';
  period?: number;
}

export interface Paronym {
  word: string;
  explanation: string;
  id: number
}

export interface ParonymGroup {
  id: number;
  group: string[];
  paronyms: Paronym[];
  context: string;
}
</file>

<file path="frontend/src/utils/utils.ts">
// Define interfaces for better type safety
import {Word} from "../types/nodes"

// Date utility functions
export function addDays(d: Date, n: number): Date {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak: number, today: Date = new Date()): Date {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords: string[]): Word[] {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx !== null ? accentIdx : -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words: Word[], targetWord: Word, updateFn: (word: Word) => void): Word[] {
  //console.log("Updating word:", targetWord.word);
  
  return words.map(word => {
    if (word.id === targetWord.id) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      //console.log("Word updated:", updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review today
export function getDueWords(words: Word[], today: Date): Word[] {
  //console.log("Getting due words from", words.length, "total words");
  //console.log("Today's date:", today);
  
  // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –ø—É—Å—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
  if (!words || words.length === 0) {
    //console.log("Words list is empty");
    return [];
  }
  
  // –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–æ–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–µ–≥–æ–¥–Ω—è
  const dueWords = words.filter(word => {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ nextReview - —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –¥–∞—Ç–∞
    if (!(word.nextReview instanceof Date)) {
      //console.log("Invalid nextReview date for word:", word);
      return true; // –ï—Å–ª–∏ –¥–∞—Ç–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞, —Å—á–∏—Ç–∞–µ–º —Å–ª–æ–≤–æ –¥–æ—Å—Ç—É–ø–Ω—ã–º –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏
    }
    
    const isDue = !word.retired && word.nextReview <= today;
    if (!isDue) {
      //console.log("Word not due:", word.word, "nextReview:", word.nextReview, "today:", today);
    }
    
    return isDue;
  });
  
  //console.log("Found", dueWords.length, "due words");
  return dueWords;
}

export const shuffleArray = (array: any[]) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
export function formatDate(date: Date): string {
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–∞—Ç—ã –±–µ–∑ –≤—Ä–µ–º–µ–Ω–∏
  const isToday = date.toDateString() === today.toDateString();
  const isTomorrow = date.toDateString() === tomorrow.toDateString();
  
  if (isToday) {
    return "–°–µ–≥–æ–¥–Ω—è";
  } else if (isTomorrow) {
    return "–ó–∞–≤—Ç—Ä–∞";
  } else {
    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –∫–∞–∫ "–î–î.–ú–ú.–ì–ì–ì–ì"
    return date.toLocaleDateString('ru-RU', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ—Ä–æ—Ç–∫–æ–π –¥–∞—Ç—ã –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–æ–≤
export function formatShortDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('ru-RU', {
    day: 'numeric',
    month: 'numeric'
  });
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), "");
  const publicEnv = Object.entries(env).reduce((acc, [key, value]) => {
    if (key.startsWith('VITE_') || ["HOST_ENV", "NODE_ENV"].includes(key) ) {
      return {
        ...acc,
        [key]: value,
      }
    }
    return acc
  }, {})

  return {
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
      outDir: "dist",
      emptyOutDir: true,
      rollupOptions: {
        input: "./index.html",
        output: {
          entryFileNames: `assets/[name].[hash].js`,
          chunkFileNames: `assets/[name].[hash].js`,
          assetFileNames: `assets/[name].[hash].[ext]`
        }
      }
    },
    publicDir: "public",
    server: {
      open: true,
      port: +env.VITE_PORT,
    },
    preview: {
      port: +env.VITE_PORT,
    },
    define: {
      'process.env': publicEnv,
    },
  };
});
</file>

<file path="Dockerfile">
# ---------------------- BASE IMAGE ----------------------
FROM node:22-slim AS base

RUN apt-get update && apt-get upgrade -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*
ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable

# ---------------------- PREPARE WORKSPACE (DEPS + SOURCE) ----------------------
FROM base AS prepare_workspace
WORKDIR /app

# –ö–æ–ø–∏—Ä—É–µ–º –º–∞–Ω–∏—Ñ–µ—Å—Ç—ã –≤–æ—Ä–∫—Å–ø–µ–π—Å–∞
COPY pnpm-workspace.yaml ./
COPY pnpm-lock.yaml ./
COPY package.json ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY shared/package.json ./shared/

# –ö–æ–ø–∏—Ä—É–µ–º –í–ï–°–¨ –æ—Å—Ç–∞–ª—å–Ω–æ–π –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞
# –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ .dockerignore –Ω–∞—Å—Ç—Ä–æ–µ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ, —á—Ç–æ–±—ã –Ω–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –ª–∏—à–Ω–µ–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ª–æ–∫–∞–ª—å–Ω—ã–µ node_modules)
COPY . .

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏, –≤–∫–ª—é—á–∞—è devDependencies, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω—É–∂–Ω—ã –¥–ª—è —Å–±–æ—Ä–∫–∏
RUN pnpm install --frozen-lockfile

# ---------------------- BUILD ----------------------
FROM prepare_workspace AS build
# WORKDIR /app —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑ prepare_workspace

# –ö–æ–ø–∏—Ä—É–µ–º .env —Ñ–∞–π–ª—ã, –µ—Å–ª–∏ –æ–Ω–∏ –Ω—É–∂–Ω—ã –Ω–∞ —ç—Ç–∞–ø–µ —Å–±–æ—Ä–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, VITE_* –≤ —Ñ—Ä–æ–Ω—Ç–µ)
# –≠—Ç–∏ –ø—É—Ç–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å–±–æ—Ä–∫–∏ Docker (–≥–¥–µ –ª–µ–∂–∏—Ç Dockerfile)
COPY etc/secrets/.frontend.env ./frontend/.env
COPY etc/secrets/.backend.env ./backend/.env

RUN pnpm b pgc
RUN pnpm build

# ---------------------- FINAL (PRODUCTION) ----------------------
FROM node:22-slim AS prod
WORKDIR /app

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"
RUN corepack enable
ENV NODE_ENV=production

# –ö–æ–ø–∏—Ä—É–µ–º package.json –∏ pnpm-workspace.yaml –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —á–µ—Ä–µ–∑ pnpm
COPY package.json pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
# –ï—Å–ª–∏ backend –∏–º–µ–µ—Ç –ø—Ä—è–º—ã–µ workspace-–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç shared, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≤—Å—Ç—Ä–æ–µ–Ω—ã –≤ bundle:
# COPY shared/package.json ./shared/

# –ö–æ–ø–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ production node_modules (–∏–ª–∏ –≤—Å–µ, –µ—Å–ª–∏ pnpm –∏—Ö –æ—Ç—Ñ–∏–ª—å—Ç—Ä—É–µ—Ç –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ)
# –∏ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Å–±–æ—Ä–∫–∏
COPY --from=prepare_workspace /app/node_modules ./node_modules
COPY --from=build /app/backend/dist ./backend/dist
COPY --from=build /app/frontend/dist ./frontend/dist 
# –ï—Å–ª–∏ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –Ω—É–∂–Ω–æ —Ä–∞–∑–¥–∞–≤–∞—Ç—å —Å —ç—Ç–æ–≥–æ –∂–µ —Å–µ—Ä–≤–µ—Ä–∞

# –ö–æ–ø–∏—Ä—É–µ–º .env –¥–ª—è runtime –±—ç–∫–µ–Ω–¥–∞
COPY etc/secrets/.backend.env ./backend/.env


HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:3000/ping || exit 1

EXPOSE 3000

CMD ["pnpm", "--filter", "@russian-stress-practice/backend", "start"]
</file>

<file path="package.json">
{
    "name": "russian-stress-practice",
    "version": "0.0.0",
    "private": "true",
    "dependencies": {
      "@tanstack/react-query": "4",
      "@trpc/client": "^10.45.2",
      "@trpc/next": "^10.45.2",
      "@trpc/react": "^9.27.4",
      "@trpc/server": "^10.45.2",
      "cors": "^2.8.5",
      "eslint": "^9.20.1",
      "eslint-plugin-node": "^11.1.0",
      "express": "^4.21.2",
      "react-dom": "^18.3.1",
      "react-router-dom": "^7.1.5",
      "w": "^1.1.0"
    },
    "pnpm": {
      "overrides": {
        "@tanstack/react-query": "4.36.1"
      }
    },
    "scripts": {
      "b": "pnpm --filter @russian-stress-practice/backend",
      "w": "pnpm --filter @russian-stress-practice/frontend",
      "sh": "pnpm --filter @russian-stress-practice/shared",
      "dev": "pnpm -r --parallel dev",
      "types": "pnpm -r --parallel types",
      "test": "pnpm -r test",
      "build": "pnpm w build && pnpm b build"

    },
    "devDependencies": {
      "@eslint/eslintrc": "^3.3.1",
      "@types/express": "^5.0.0",
      "@types/jest": "^29.5.14",
      "@types/node": "^22.10.7",
      "@typescript-eslint/eslint-plugin": "^8.24.0",
      "@typescript-eslint/parser": "^8.24.0",
      "eslint-config-prettier": "^10.0.1",
      "eslint-config-react-app": "^7.0.1",
      "eslint-config-standard-with-typescript": "^43.0.1",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jest": "^28.11.0",
      "husky": "^8.0.0",
      "jest": "^29.7.0",
      "lint-staged": "^15.4.3",
      "node": "link:@types\\node",
      "rimraf": "^6.0.1",
      "ts-jest": "^29.3.1",
      "ts-patch": "^3.3.0",
      "typescript": "^5.7.3",
      "typescript-transform-paths": "^3.5.5"
    },
    "type": "module",
    "packageManager": "pnpm@10.11.0" 
  }
</file>

<file path=".gitignore">
node_modules
.env
*.sql
*.xml
secrets
dist
</file>

<file path="frontend/package.json">
{
  "name": "@russian-stress-practice/frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "types": "tsc --noEmit --project ./tsconfig.json && tsc --noEmit --project ./tsconfig.node.json"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.2",
    "@heroicons/react": "^2.2.0",
    "@react-oauth/google": "^0.12.1",
    "@russian-stress-practice/backend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@tanstack/react-query": "4.36.1",
    "@trpc/client": "^10.45.2",
    "@trpc/react-query": "^10.45.2",
    "@trpc/server": "^10.45.2",
    "classnames": "^2.5.1",
    "date-fns": "^4.1.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-react": "^7.37.5",
    "formik": "^2.4.6",
    "formik-validator-zod": "^2.2.0",
    "heroicons": "^2.2.0",
    "js-cookie": "^3.0.5",
    "ldrs": "^1.1.7",
    "lodash": "^4.17.21",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2",
    "serve": "^14.2.4",
    "superjson": "1.13.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/js-cookie": "^3.0.6",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

</files>
