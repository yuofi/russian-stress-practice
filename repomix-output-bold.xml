analyse the styles of repomix-output-bold.xml - it contains the design on StressPracticePage and ParonymPracticePage then make the styles of my oproject simillar


This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.envrc
.github/workflows/deploy.yml
index.html
package.json
postcss.config.js
public/index.js
public/phonetics.txt
public/vite.svg
README.md
src/App.jsx
src/components/Navigation.jsx
src/index.css
src/main.jsx
src/main.ts
src/paronyms.js
src/ParonymsPage.jsx
src/StressPracticePage.jsx
src/style.css
src/style.d.ts
src/utils.js
src/utils.test.js
src/words.js
tailwind.config.js
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".envrc">
use flake
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>

<file path="public/phonetics.txt">
аэропОрты
бАнты
бОроду
бухгАлтеров
вероисповЕдание
водопровОд
газопровОд
граждАнство
дефИс
дешевИзна
диспансЕр
договорЁнность
докумЕнт
досУг
еретИк
жалюзИ
знАчимость
Иксы
каталОг
квартАл
киломЕтр
кОнусов
корЫсть
крАны
кремЕнь; кремнЯ
лЕкторов
лОктя
лыжнЯ
мЕстностей
намЕрение
нарОст
нЕдруг
недУг
некролОг
нЕнависть
нефтепровОд
новостЕй
нОгтя
Отзыв
отзЫв
Отрочество
партЕр
портфЕль
пОручни
придАное
призЫв
свЁкла
сирОты
созЫв
сосредотОчение
срЕдства
стАтуя
столЯр
тамОжня
тОрты
тУфля
цемЕнт
цЕнтнер
цепОчка
шАрфы
шофЁр
экспЕрт
вернА
знАчимый
красИвее; красИвейший
кУхонный
ловкА
мозаИчный
оптОвый
прозорлИвый; прозорлИва
слИвовый
бралА
бралАсь
взялА
взялАсь
влилАсь
ворвалАсь
воспринЯть; воспринялА
воссоздалА
вручИт
гналА
гналАсь
добралА
добралАсь
дождалАсь
дозвонИтся
дозИровать
ждалА
жилОсь
закУпорить
занЯть
заперлА
запломбировАть
защемИт
звалА
звонИт
кАшлянуть
клАла
клЕить
крАлась
кровоточИть
лгалА
лилА
лилАсь
навралА
наделИт
надорвалАсь
назвалАсь
накренИтся
налилА
нарвалА
начАть
обзвонИт
облегчИть; облегчИт
облилАсь
обнялАсь
обогналА
ободралА
ободрИть; ободрИт
ободрИться; ободрИтся
обострИть
одолжИть; одолжИт
озлОбить
оклЕить
окружИт
опОшлить
освЕдомиться; освЕдомится
отбылА
отдалА
откУпорить
отозвалА
отозвалАсь
перезвонИт
перелилА
плодоносИть
пломбировАть
повторИт
позвалА
позвонИть
полилА
положИть
понЯть; понялА
послАла
прибЫть; прИбыл, прибылА, прИбыли
принЯть; прИнял, принялА, прИняли
рвалА
сверлИт
снялА
совралА
создалА
сорвалА
сорИт
убралА
углубИть
укрепИт
чЕрпать
щемИт
щЁлкать
довезЁнный
зАгнутый
зАнятый; занятА
зАпертый
заселЁнный; заселенА
кормЯщий
кровоточАщий
нажИвший
налИвший
нанЯвшийся
начАвший
нАчатый
низведЁнный
облегчЁнный
ободрЁнный
обострЁнный
отключЁнный
повторЁнный
поделЁнный
понЯвший
прИнятый; принятА
приручЁнный
прожИвший
снятА
сОгнутый
углублЁнный
закУпорив
начАв
начАвшись
отдАв
поднЯв
понЯв
прибЫв
создАв
вОвремя
дОверху
донЕльзя
дОнизу
дОсуха
зАсветло
зАтемно
красИвее
надОлго
ненадОлго
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/paronyms.js">
// Data structure for paronyms
const paronymData = [
    {
        group: ["АДРЕСАТ", "АДРЕСАНТ"],
        paronyms: [
            { word: "АДРЕСАТ", explanation: "получатель" },
            { word: "АДРЕСАНТ", explanation: "отправитель" }
        ]
    },
    {
        group: ["АРТИСТИЧНЫЙ", "АРТИСТИЧЕСКАЯ"],
        paronyms: [
            { word: "АРТИСТИЧНЫЙ", explanation: "человек, исполнение" },
            { word: "АРТИСТИЧЕСКАЯ", explanation: "внешность, среда, подъезд, карьера, способности, артистическая натура" }
        ]
    },
    {
        group: ["АКАДЕМИЧЕСКИЙ", "АКАДЕМИЧНЫЙ"],
        paronyms: [
            { word: "АКАДЕМИЧЕСКИЙ", explanation: "оркестр" },
            { word: "АКАДЕМИЧНЫЙ", explanation: "подход" }
        ]
    },
    {
        group: ["АВТОРИТАРНЫЙ", "АВТОРИТЕТНЫЙ"],
        paronyms: [
            { word: "АВТОРИТАРНЫЙ", explanation: "основанный на диктатуре" },
            { word: "АВТОРИТЕТНЫЙ", explanation: "уважаемый" }
        ]
    },
    {
        group: ["БЕДНАЯ", "БЕДСТВЕННОЕ"],
        paronyms: [
            { word: "БЕДНАЯ", explanation: "девушка. Жил в БЕДНОСТИ." },
            { word: "БЕДСТВЕННОЕ", explanation: "положение" }
        ]
    },
    {
        group: ["БЕЗОТВЕТНАЯ", "БЕЗОТВЕТСТВЕННОЕ"],
        paronyms: [
            { word: "БЕЗОТВЕТНАЯ", explanation: "любовь" },
            { word: "БЕЗОТВЕТСТВЕННОЕ", explanation: "отношение, человек" }
        ]
    },
    {
        group: ["БУДНИЙ", "БУДНИЧНЫЙ"],
        paronyms: [
            { word: "БУДНИЙ", explanation: "день" },
            { word: "БУДНИЧНЫЙ", explanation: "(обыденный): дело, событие, заботы, платье, костюм; а также: однообразный, беспросветный, серый, безрадостный: голос, атмосфера, ответ, жизнь" }
        ]
    },
    // Add more paronym groups here...
    {
        group: ["БОЛОТИСТАЯ", "БОЛОТНАЯ"],
        paronyms: [
            { word: "БОЛОТИСТАЯ", explanation: "почва" },
            { word: "БОЛОТНАЯ", explanation: "птица, грязь" }
        ]
    },
    {
        group: ["БЛАГОДАРНЫЙ", "БЛАГОДАРСТВЕННЫЙ"],
        paronyms: [
            { word: "БЛАГОДАРНЫЙ", explanation: "человек, занятие" },
            { word: "БЛАГОДАРСТВЕННЫЙ", explanation: "молебен, письмо" }
        ]
    },
    {
        group: ["BЛАГОТВОРИТЕЛЬНЫЙ", "БЛАГОТВОРНОЕ"],
        paronyms: [
            { word: "БЛАГОТВОРИТЕЛЬНЫЙ", explanation: "фонд" },
            { word: "БЛАГОТВОРНОЕ", explanation: "влияние" }
        ]
    }
];

export default paronymData;
</file>

<file path="src/style.css">
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f4f4f4;
    margin: 0;
}

.container {
    background-color: #fff;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    max-width: 500px;
    width: 90%;
}

h1 {
    color: #333;
    margin-bottom: 25px;
}

.word-display {
    font-size: 2.5em; /* Make word prominent */
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    min-height: 60px; /* Ensure space even when loading */
    letter-spacing: 2px; /* Easier clicking on letters */
    user-select: none; /* Prevent text selection interfering */
}

.word-display span.vowel {
    cursor: pointer;
    padding: 0 2px; /* Add slight padding for easier clicking */
    border-radius: 3px;
    transition: background-color 0.2s ease;
}

.word-display span.vowel:hover {
    background-color: #e0e0e0;
}

/* Class added after an answer is given */
.word-display.answered span.vowel:hover {
    background-color: transparent; /* Disable hover effect after answer */
    cursor: default;
}

.feedback {
    min-height: 50px; /* Reserve space for feedback */
    margin-bottom: 20px;
    font-size: 1.1em;
    font-weight: bold;
}

.feedback.correct {
    color: #28a745; /* Green */
}

.feedback.incorrect {
    color: #dc3545; /* Red */
}

/* Style for highlighting the correct stress after feedback */
.word-display span.correct-stress {
    color: #28a745; /* Green */
    font-weight: bold;
    /* Optional: Add subtle background or underline */
    /* background-color: #d4edda; */
}

/* Style for highlighting the incorrect guess (optional) */
.word-display span.incorrect-guess {
    text-decoration: line-through;
    color: #dc3545; /* Red */
}

.controls button {
    padding: 10px 20px;
    font-size: 1em;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    transition: background-color 0.2s ease;
}

.controls button:hover {
    background-color: #0056b3;
}

.controls button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.stats {
    margin-top: 20px;
    color: #555;
    font-size: 0.9em;
}
</file>

<file path="src/style.d.ts">
declare module '*.css' {
  const content: Record<string, string>;
  export default content;
}
</file>

<file path="src/utils.js">
// Date utility functions
export function addDays(d, n) {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak, today = new Date()) {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords) {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: null,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words, targetWord, updateFn) {
  return words.map(word => {
    if (word.word === targetWord.word) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review
export function getDueWords(words, today = new Date()) {
  return words
    .filter(w => !w.retired && w.nextReview <= today)
    .sort(() => Math.random() - 0.5); // Simple shuffle
}
</file>

<file path="src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["тЕст", "примЕр"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("пример");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 },
      { word: "пример", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "тест1", nextReview: yesterday, retired: false },
      { word: "тест2", nextReview: today, retired: false },
      { word: "тест3", nextReview: tomorrow, retired: false },
      { word: "тест4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "тест1")).toBe(true);
    expect(result.some(w => w.word === "тест2")).toBe(true);
    expect(result.some(w => w.word === "тест3")).toBe(false);
    expect(result.some(w => w.word === "тест4")).toBe(false);
  });
});
</file>

<file path="src/words.js">
// Raw list with uppercase marking the stressed vowel
const rawWords = [
  "Августовский",
  "агЕнт",
  "алфавИт",
  "алкогОль",
  "аэропОрты",
  "аристокрАтия",
  "апострОф",
  "агронОмия",
  "асимметрИя",
  // Б
  "балОванный",
  "баловАть",
  "баловАться",
  "балУясь",
  "бАнты",
  "безУдержный",
  "бОроду",
  "бОчковый",
  "бухгАлтеров",
  "благоволИть",
  "блАговест",
  "бряцАть",
  "бУнгало",
  "брОня на билеты",
  "бронЯ у танка",
  "бюрокрАтия",
  "брюшкО",
  "бракОвщик",
  // В
  "вЕчеря",
  "вероисповЕдание",
  "взбешЕнный",
  "ворожеЯ",
  "вОзрастов",
  "втрИдешева",
  // Г
  "гЕнезис",
  "гЕрбовый",
  "граждАнство",
  "грУшевый",
  "граффИти",
  "гастронОмия",
  "грАблями",
  // Д
  "давнИшний",
  "дефИс",
  "деньгАх",
  "дешевИзна",
  "дозИровать",
  "долбЯщий",
  "докраснА",
  "донЕльзя",
  "дОнизу",
  "досУг",
  "дОсуха",
  "доЯр",
  "духовнИк",
  "домОвая книга",
  // Е
  "еретИк",
  // Ж
  "жалюзИ",
  "жилОсь",
  "жерлОз",
  // З
  "завсегдАтай",
  "завИдно",
  "зАгодя",
  "закУпорив",
  "зАтемно",
  "знАчимый",
  "зимОвщик",
  "зубчАтый",
  "знАмение",
  // И
  "ирИс",
  "Ирис",
  "искрА зажигания",
  "Иконопись",
  "Исподволь",
  "избалОванный",
  "издрЕвле",
  "Иксы с Иксом",
  "исключИт",
  "Исстари",
  "исчЕрпав",
  "исчЕрпать",
  // К
  "каталОг",
  "кАмбала",
  "крапИва",
  "кАшлянуть",
  "квартАл",
  "киломЕтр",
  "клАла",
  "кремЕнь",
  "кремнЯ",
  "крЕмы",
  "костюмирОванный",
  "кулинАрия",
  "коклЮш",
  "красИвее",
  "крАны",
  "корЫсть",
  "кровоточИть",
  "кровоточАщий",
  "кУхонный",
  "кладовАя",
  "опОшлят",
  "оптОвый",
  "освЕдомиться",
  "отзЫв",
  "откУпорил",
  "отрочество",
  "oполОснутый",
  "озвУчение",
  "одновремЕнно",
  "крАдучись",
  "куркУма",
  "кичИться",
  "кедрОвый",
  // Л
  "лЕкторов",
  "ловкА",
  "лососЕвый",
  "лыжнЯ",
  // М
  "мастерскИ",
  "мЕстностей",
  "мозаИчный",
  "мещанИн",
  "молЯщий",
  "мусоропровОд",
  "мытАрство",
  "мЕльком",
  // Н
  "наделИт",
  "надОлго",
  "намЕрение",
  "нарОст",
  "насорИт",
  "нЕдруг",
  "недУг",
  "насквОзь",
  "назвАный брат",
  "наговОр",
  "ненадОлго",
  "низведЕн",
  "нОвости",
  "новостЕй",
  "нОгтя",
  "нормировАть",
  // О
  "обеспЕчение",
  "ободрИть",
  "ободренА",
  "одолжИт",
  "озлОбить",
  "окружИт",
  "опломбировАть",
  // П
  "партЕр",
  "пАмятуя",
  "пЕрчит",
  "плЕсневеть",
  "плодоносИть",
  "пОручни",
  "послАла",
  "прИбыл",
  "придАное",
  "принУдить",
  "прИнятый",
  "принялсЯ",
  "прозорлИва",
  "прожОрлива",
  "подчАс",
  "тОтчас",
  "пЕтля",
  "пЕтелька",
  "пЕня",
  "простынЯ",
  "пУрпур",
  "платО",
  "прИкус",
  "пулОвер",
  "поутрУ",
  "пригУбить",
  "плешИна",
  // Р
  "ржавЕть",
  "расклЕшенный",
  // С
  "свЕкла",
  "сверлИт",
  "сверлИшь",
  "серА",
  "сЕры",
  "сЕтчатый",
  "сирОты",
  "слИвовый",
  "сОгнутый",
  "созЫв",
  "сорИт",
  "срЕдства",
  "срЕдствами",
  "стАтуя",
  "столЯр",
  "сосредотОчение",
  "скулА",
  "скобА",
  "страхОвщик",
  // Т
  "тЕплится",
  "тОрты",
  "тОтчас",
  "танцОвщица",
  "толИка",
  "тУфля",
  // У
  "убыстрИть",
  "углубИть",
  "украИнский",
  "укрепИт",
  "умЕрший",
  "усугубИт",
  "упрОчение",
  // Ф
  "фенОмен",
  "фОрзац",
  "фетИш",
  "факсИмиле",
  // Х
  "ходАтайствовать",
  "христианИн",
  "хозЯева",
  "хОленный",
  // Ц
  "цемЕнт",
  "цЕнтнер",
  "цепОчка",
  "цыгАн",
  // Ч
  "чЕлюстей",
  "чЕрпать",
  // Ш
  "шАрфы",
  "шофЕр",
  "шпрИцы",
  // Щ
  "щавЕль",
  "щемИт",
  "щЕлкать",
  "щепА",
  // Э
  "экспЕрт",
  "эпилОг"
];

export default rawWords;
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="src/components/Navigation.jsx">
import React from 'react';
import { Link, useLocation } from 'react-router-dom';

export default function Navigation() {
  const location = useLocation();

  return (
    <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10">
      <div className="container mx-auto flex justify-between items-center">
        <div className="text-xl font-bold text-indigo-600 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
          </svg>
          Русский язык: Тренажеры
        </div>
        <div className="flex space-x-2">
          <Link
            to="/"
            className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
              location.pathname === '/'
                ? 'bg-indigo-100 text-indigo-700 shadow-sm'
                : 'text-slate-600 hover:bg-slate-100 hover:text-indigo-600'
            }`}
          >
            <div className="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
              </svg>
              Ударения
            </div>
          </Link>
          <Link
            to="/paronyms"
            className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
              location.pathname === '/paronyms'
                ? 'bg-indigo-100 text-indigo-700 shadow-sm'
                : 'text-slate-600 hover:bg-slate-100 hover:text-indigo-600'
            }`}
          >
            <div className="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
              Паронимы
            </div>
          </Link>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="src/ParonymsPage.jsx">
import React, { useState, useEffect } from 'react';
import paronymData from './paronyms';

export default function ParonymsPage() {
    const [currentParonymGroup, setCurrentParonymGroup] = useState(null);
    const [correctAnswer, setCorrectAnswer] = useState(null);
    const [score, setScore] = useState(0);
    const [showFeedback, setShowFeedback] = useState(false);
    const [isCorrect, setIsCorrect] = useState(false);
    const [selectedAnswer, setSelectedAnswer] = useState(null);
    const [showExplanation, setShowExplanation] = useState(false);

    // Function to shuffle an array
    const shuffleArray = (array) => {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; // Swap elements
        }
        return newArray;
    };

    // Function to display a new question
    const displayNewQuestion = () => {
        // Clear previous feedback and explanations
        setShowFeedback(false);
        setShowExplanation(false);
        setSelectedAnswer(null);

        // Select a random paronym group
        const randomGroup = paronymData[Math.floor(Math.random() * paronymData.length)];
        setCurrentParonymGroup(randomGroup);

        // Select a random paronym from the group as the correct answer
        const correctParonymObject = randomGroup.paronyms[Math.floor(Math.random() * randomGroup.paronyms.length)];
        setCorrectAnswer(correctParonymObject.word);
    };

    // Function to handle user's answer
    const handleAnswer = (answer) => {
        setSelectedAnswer(answer);
        setShowFeedback(true);

        if (answer === correctAnswer) {
            setIsCorrect(true);
            setScore(score + 1);
        } else {
            setIsCorrect(false);
        }

        setShowExplanation(true);
    };

    // Initialize with a question on component mount
    useEffect(() => {
        displayNewQuestion();
    }, []);

    if (!currentParonymGroup) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
                <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md w-full mx-auto text-center">
                    <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500 mx-auto mb-4"></div>
                    <p className="text-slate-700 text-lg">Загрузка паронимов...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg max-w-2xl w-full mx-auto my-auto overflow-hidden">
                <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">Тренажер паронимов</h1>

                <div className="flex flex-col items-center">
                    {currentParonymGroup && correctAnswer && (
                        <>
                            <div className="bg-slate-50 p-5 rounded-xl mb-6 w-full">
                                <p className="text-lg text-center text-slate-700 leading-relaxed">
                                    Выберите подходящее слово, соответствующее значению:
                                    <span className="font-medium block mt-2 text-indigo-700">
                                        "{currentParonymGroup.paronyms.find(p => p.word === correctAnswer)?.explanation}"
                                    </span>
                                </p>
                            </div>

                            <div className="flex flex-wrap justify-center gap-3 mb-6 w-full">
                                {shuffleArray(currentParonymGroup.paronyms).map((paronym) => (
                                    <button
                                        key={paronym.word}
                                        onClick={() => handleAnswer(paronym.word)}
                                        disabled={showFeedback}
                                        className={`
                                            py-3 px-6 rounded-xl font-medium text-lg transition-all duration-200 break-words max-w-full
                                            ${showFeedback && paronym.word === correctAnswer
                                                ? 'bg-emerald-500 text-white shadow-md transform scale-105'
                                                : ''}
                                            ${showFeedback && paronym.word === selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-rose-500 text-white'
                                                : ''}
                                            ${!showFeedback
                                                ? 'bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 hover:border-indigo-300 hover:text-indigo-600 hover:shadow-md hover:transform hover:scale-105 active:bg-indigo-50'
                                                : ''}
                                            ${showFeedback && paronym.word !== selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-slate-100 text-slate-400 border border-slate-200'
                                                : ''}
                                            focus:outline-none focus:ring-0
                                        `}
                                    >
                                        {paronym.word}
                                    </button>
                                ))}
                            </div>
                        </>
                    )}

                    {/* Feedback message - always reserve space for it */}
                    <div className={`text-center font-medium text-lg mb-6 py-4 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[80px] flex items-center justify-center
                        ${!showFeedback ? 'opacity-0' : ''}
                        ${showFeedback && isCorrect
                            ? 'bg-emerald-50 text-emerald-700 border border-emerald-200'
                            : showFeedback ? 'bg-rose-50 text-rose-700 border border-rose-200' : ''}`}>
                        {showFeedback ? (
                            isCorrect
                                ? (
                                    <div className="flex items-center justify-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        Правильно!
                                    </div>
                                )
                                : (
                                    <div>
                                        <div className="flex items-center justify-center mb-1">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-rose-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg>
                                            Неправильно
                                        </div>
                                        <div className="text-sm mt-1">
                                            Правильный ответ: <span className="font-semibold">{correctAnswer}</span>
                                        </div>
                                    </div>
                                )
                        ) : (
                            <span className="invisible">Placeholder for feedback</span>
                        )}
                    </div>

                    {/* Explanation section - always reserve space with min-height */}
                    <div className={`mt-6 border-t border-slate-100 pt-6 w-full transition-opacity duration-300 ${!showExplanation ? 'opacity-0 h-0 overflow-hidden' : ''}`}>
                        <h3 className="text-xl font-semibold mb-4 text-slate-700 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Объяснения:
                        </h3>
                        <div className="bg-slate-50 rounded-xl p-4 divide-y divide-slate-200">
                            {currentParonymGroup?.paronyms.map((paronym) => (
                                <div key={paronym.word} className="py-3 first:pt-0 last:pb-0">
                                    <p className="text-slate-700">
                                        <span className="font-semibold text-indigo-700">{paronym.word}:</span> {paronym.explanation}
                                    </p>
                                </div>
                            ))}
                        </div>
                    </div>

                    {showFeedback && (
                        <div className="flex justify-center w-full mt-8">
                            <button
                                onClick={displayNewQuestion}
                                className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                            >
                                Следующее слово
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/StressPracticePage.jsx">
import React, { useState, useEffect, useMemo } from 'react';
import { initializeWords, updateWord, getDueWords, computeNextReview, addDays } from './utils';
import rawWords from './words';

// List of Russian vowels
const vowels = ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я'];

export default function StressPracticePage() {
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState(() => initializeWords(rawWords));

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState('');

  // State to track the number of incorrect answers
  const [incorrectCount, setIncorrectCount] = useState(0);

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);

  // Get due words and set the first one as current on mount
  useEffect(() => {
    loadNextWord();
  }, []);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter(w => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split('') : [];

  // Load the next word to practice
  const loadNextWord = () => {
    const due = getDueWords(words, today);

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else {
      setCurrentWord(null);
      setAllLearned(true);
    }

    setSelected(null);
    setFeedback('');
    setRequireRetry(false);
  };

  // Handle first correct answer
  const handleFirstCorrect = () => {
    setFeedback('✅ Правильно! Попробуй ещё раз.');
    setRequireRetry(true);
    // Don't reset selected state here - we want to show the green highlight
  };

  // Handle first wrong answer
  const handleFirstWrong = (selectedIdx) => {
    setFeedback('❌ Неправильно. Попробуй ещё раз.');
    setRequireRetry(true);
    setIncorrectCount(prev => prev + 1);
  };

  // Handle the retry attempt
  const finalizeRetry = (selectedIdx) => {
    if (selectedIdx === currentWord.accentIdx) {
      // Correct on retry
      setFeedback('✅ Правильно!');

      // Update the word's learning metadata
      setWords(prevWords => {
        return updateWord(prevWords, currentWord, (word) => {
          word.correctStreak += 1;

          // If streak reaches 4, retire the word
          if (word.correctStreak >= 4) {
            word.retired = true;
          } else {
            // Otherwise, schedule next review based on streak
            word.nextReview = computeNextReview(word.correctStreak, today);
          }
        });
      });
    } else {
      // Wrong on retry
      setFeedback('❌ Неправильно. Правильный ответ выделен.');

      // Reset the word's streak
      setWords(prevWords => {
        return updateWord(prevWords, currentWord, (word) => {
          word.correctStreak = 0;
          word.wrongCount += 1;
          word.nextReview = addDays(today, 1); // Review again tomorrow
        });
      });

      setIncorrectCount(prev => prev + 1);
    }

    // No longer require retry
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx) => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback && !requireRetry) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // Handle based on whether this is first attempt or retry
    if (!requireRetry) {
      // First attempt
      if (idx === currentWord.accentIdx) {
        handleFirstCorrect();
      } else {
        handleFirstWrong(idx);
      }
    } else {
      // Retry attempt
      finalizeRetry(idx);
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = () => {
    setShowAllWords(prev => !prev);
  };

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats */}
      <div className="w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <div> {/* Container for the stats */}
          <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">Статистика</h2>

          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Всего слов</p>
                <p className="text-xl font-semibold text-slate-800">{words.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Выучено</p>
                <p className="text-xl font-semibold text-emerald-600">{retiredWords.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Осталось</p>
                <p className="text-xl font-semibold text-indigo-600">{words.length - retiredWords.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Ошибок</p>
                <p className="text-xl font-semibold text-amber-600">{incorrectCount}</p>
              </div>
            </div>
          </div>

          <h3 className="text-lg font-semibold mb-3 text-slate-700 flex items-center">
            <span className="mr-2">{showAllWords ? 'Все слова' : 'Слова на изучении'}</span>
            <span className="text-xs px-2 py-1 bg-slate-100 rounded-full text-slate-600">
              {(showAllWords ? words : words.filter(w => !w.retired)).length}
            </span>
          </h3>

          <ul className="max-h-96 overflow-y-auto mb-4 bg-white rounded-xl shadow-sm divide-y divide-slate-100">
            {(showAllWords ? words : words.filter(w => !w.retired)).map((wordObj, i) => (
              <li key={i} className="py-2 px-3 flex justify-between items-center hover:bg-slate-50 transition-colors">
                <span className="text-slate-700">{wordObj.word}</span>
                <span className={`px-2 py-1 rounded-full text-xs font-medium ${wordObj.retired ? 'bg-emerald-100 text-emerald-700' : 'bg-indigo-100 text-indigo-700'}`}>
                  {wordObj.retired ? '✓' : `${wordObj.correctStreak}/4`}
                </span>
              </li>
            ))}
          </ul>
        </div>

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-auto px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? 'Показать изучаемые' : 'Показать все слова'}
        </button>
      </div>

      {/* Main content area */}
      <div className="w-3/4 p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">Тренажер ударений</h1>

          {allLearned ? (
            // Show congratulations message when all words are learned
            <div className="text-center py-12 px-8 bg-white rounded-2xl shadow-lg">
              <div className="w-20 h-20 bg-emerald-100 rounded-full flex items-center justify-center mx-auto mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-10 w-10 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
              </div>
              <h2 className="text-2xl font-bold text-emerald-600 mb-4">Поздравляем!</h2>
              <p className="text-lg mb-4 text-slate-700">Вы выучили все слова на сегодня.</p>
              <p className="text-md text-slate-500">Приходите завтра для повторения.</p>
            </div>
          ) : (
            // Regular practice UI
            <>
              {/* Progress display */}
              <div className="mb-6 flex justify-between text-slate-600 bg-white px-4 py-3 rounded-xl shadow-sm">
                <span className="flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-emerald-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Выучено: <span className="font-semibold ml-1">{retiredWords.length}/{words.length}</span>
                </span>
                <span className="flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Осталось сегодня: <span className="font-semibold ml-1">{dueWords.length}</span>
                </span>
              </div>

              {/* Word display */}
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg mb-4 flex flex-col items-center w-full max-w-full">
                  {/* Word display with overflow handling */}
                  <div className="w-full overflow-x-auto mb-8 py-2">
                    <div className="flex justify-center items-center space-x-2 text-4xl md:text-5xl min-w-min mx-auto">
                      {letters.map((letter, idx) => {
                        const isVowel = vowels.includes(letter.toLowerCase());
                        const isCorrect = idx === currentWord?.accentIdx;
                        const isSelected = selected === idx;
                        const showCorrect = requireRetry === false && feedback && isCorrect;

                        return (
                          <span
                            key={idx}
                            onClick={() => handleSelect(idx)}
                            className={`
                            relative cursor-pointer px-2 py-1 rounded-lg transition-all duration-200
                            ${isVowel ? 'hover:bg-slate-100 hover:transform hover:scale-110' : ''}
                            ${isSelected && isCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                            ${isSelected && !isCorrect ? 'bg-rose-500 text-white' : ''}
                            ${showCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                          `}
                          >
                            {letter}
                            {isVowel && (
                              <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                            )}
                          </span>
                        );
                      })}
                    </div>
                  </div>

                  {/* Feedback message - always reserve space for it */}
                  <div className={`text-center my-6 text-lg font-medium py-3 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[60px] flex items-center justify-center
                  ${!feedback ? 'opacity-0' : ''}
                  ${feedback && feedback.includes('Правильно')
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200'
                      : feedback ? 'bg-rose-50 text-rose-700 border border-rose-200' : ''}`}>
                    {feedback || 'Placeholder for feedback'}
                  </div>

                {/* Next word button - changes text based on retry state */}
                <div className="flex justify-center w-full mt-6">
                  {requireRetry ? (
                    <button
                      onClick={() => {
                        // Clear feedback and reset selected state to prepare for retry
                        setFeedback('');
                        setSelected(null);
                      }}
                        className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                    >
                      Попробуй ещё раз
                    </button>
                  ) : (
                    <button
                      onClick={loadNextWord}
                          className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                      disabled={feedback !== '' && requireRetry}
                    >
                      Следующее слово
                    </button>
                  )}
                </div>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="package.json">
{
  "name": "russian-stress-practice",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1997.5 2000" style="enable-background:new 0 0 1997.5 2000" xml:space="preserve"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="498.781" y1="2229.557" x2="1666.593" y2="643.575" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#41d1ff"/><stop offset="1" style="stop-color:#bd34fe"/></linearGradient><path d="m1990.9 296-938.3 1677.9c-19.4 34.6-69.1 34.8-88.8.4L6.8 296.2c-21.4-37.6 10.7-83.1 53.3-75.5l939.3 167.9c6 1.1 12.1 1.1 18.1 0L1937.2 221c42.4-7.8 74.7 37.4 53.7 75z" style="fill:url(#a)"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="1049.466" y1="1988.58" x2="1260.718" y2="539.417" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#ffea83"/><stop offset=".083" style="stop-color:#ffdd35"/><stop offset="1" style="stop-color:#ffa800"/></linearGradient><path d="M1446.9.5 752.5 136.6c-11.4 2.2-19.9 11.9-20.6 23.5l-42.7 721.4c-1 17 14.6 30.2 31.2 26.4l193.3-44.6c18.1-4.2 34.4 11.8 30.7 30L887 1174.4c-3.9 18.9 13.9 35.1 32.4 29.5l119.4-36.3c18.5-5.6 36.3 10.6 32.4 29.6L979.9 1639c-5.7 27.6 31 42.7 46.4 19l10.2-15.8L1602.4 513c9.5-18.9-6.9-40.5-27.6-36.5l-199 38.4c-18.7 3.6-34.6-13.8-29.3-32.1l129.9-450.3c5.2-18.2-10.8-35.7-29.5-32z" style="fill:url(#b)"/></svg>
</file>

<file path="src/App.jsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './StressPracticePage';
import ParonymsPage from './ParonymsPage';
import Navigation from './components/Navigation';

export default function App() {
  return (
    <Router basename="/russian-stress-practice">
      <div className="flex flex-col min-h-screen">
        <Navigation />
        <div className="flex-grow">
          <Routes>
            <Route path="/" element={<StressPracticePage />} />
            <Route path="/paronyms" element={<ParonymsPage />} />
          </Routes>
        </div>
      </div>
    </Router>
  );
}
</file>

<file path="README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"вОвремя"` (stress on the first 'о')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="src/main.ts">
import "./style.css";

// Add global declaration for the appLoaded flag
declare global {
    interface Window {
        appLoaded: boolean;
    }
}

interface WordData {
    word: string;
    stressedIndex: number;
    stressedWord: string;
}

// Set flag to indicate the script has successfully loaded
window.appLoaded = true;

document.addEventListener("DOMContentLoaded", () => {
    const wordDisplay = document.getElementById(
        "word-display",
    ) as HTMLDivElement;
    const feedback = document.getElementById("feedback") as HTMLDivElement;
    const nextButton = document.getElementById(
        "next-button",
    ) as HTMLButtonElement;
    const scoreDisplay = document.getElementById("score") as HTMLSpanElement;
    const attemptsDisplay = document.getElementById(
        "attempts",
    ) as HTMLSpanElement;

    const VOWELS: string = "аеёиоуыэюя";
    let wordsData: WordData[] = [];
    let currentWordIndex: number = -1;
    let score: number = 0;
    let attempts: number = 0;
    let isAnswered: boolean = false;

    async function loadWords(): Promise<void> {
        try {
            // Use the base URL from Vite environment
            const basePath = (import.meta as any).env.BASE_URL || '/';
            const response: Response = await fetch(`${basePath}phonetics.txt`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text: string = await response.text();
            parseAndStoreWords(text);
            if (wordsData.length > 0) {
                shuffleArray(wordsData);
                displayNextWord();
            } else {
                wordDisplay.textContent = "No words found in file.";
                nextButton.disabled = true;
            }
        } catch (error) {
            console.error("Error loading or parsing words file:", error);
            wordDisplay.textContent = "Error loading words.";
            feedback.textContent =
                "Could not load phonetics.txt. Please check the file and console.";
            feedback.className = "feedback incorrect";
            nextButton.disabled = true;
        }
    }

    function parseAndStoreWords(text: string): void {
        // First split by lines, then process each line
        const lines = text
            .trim()
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0);

        // Process each line, handling semicolon-separated forms
        const processedWords: WordData[] = [];

        for (const line of lines) {
            // Split by semicolon to handle multiple forms
            const wordForms = line.split(";").map((form) => form.trim());

            for (const stressedWord of wordForms) {
                // Skip empty forms
                if (stressedWord.length === 0) continue;

                // Process comma-separated forms (like "прИбыл, прибылА, прИбыли")
                const commaSeparatedForms = stressedWord
                    .split(",")
                    .map((form) => form.trim());

                for (const form of commaSeparatedForms) {
                    if (form.length === 0) continue;

                    const wordLower: string = form.toLowerCase();
                    let stressedIndex: number = -1;

                    for (let i: number = 0; i < form.length; i++) {
                        if (
                            form[i] !== wordLower[i] &&
                            VOWELS.includes(wordLower[i])
                        ) {
                            stressedIndex = i;
                            break;
                        }
                    }

                    if (stressedIndex === -1) {
                        console.warn(
                            `Could not find stressed vowel in: "${form}"`,
                        );
                        continue;
                    }

                    processedWords.push({
                        word: wordLower,
                        stressedIndex: stressedIndex,
                        stressedWord: form,
                    });
                }
            }
        }

        wordsData = processedWords;
    }

    function displayNextWord(): void {
        if (wordsData.length === 0) return;

        isAnswered = false;
        currentWordIndex = (currentWordIndex + 1) % wordsData.length;
        const currentWord: WordData = wordsData[currentWordIndex];

        wordDisplay.innerHTML = "";
        wordDisplay.classList.remove("answered");
        feedback.textContent = "";
        feedback.className = "feedback";
        nextButton.disabled = true;

        currentWord.word.split("").forEach((char: string, index: number) => {
            const span: HTMLSpanElement = document.createElement("span");
            span.textContent = char;
            if (VOWELS.includes(char.toLowerCase())) {
                span.classList.add("vowel");
                span.dataset.index = index.toString(); // Store as string
                span.addEventListener("click", handleVowelClick);
            }
            wordDisplay.appendChild(span);
        });
    }

    function handleVowelClick(event: Event): void {
        if (isAnswered) return;

        isAnswered = true;
        wordDisplay.classList.add("answered");
        const target = event.target as HTMLSpanElement; // Type assertion
        const clickedIndex: number = parseInt(target.dataset.index || "", 10); // Handle potential null
        const correctIndex: number = wordsData[currentWordIndex].stressedIndex;
        const correctWord: string = wordsData[currentWordIndex].stressedWord;

        attempts++;
        attemptsDisplay.textContent = attempts.toString();

        // Remove click listeners from all vowels after answering
        wordDisplay.querySelectorAll("span.vowel").forEach((vowelSpan) => {
            // Clone and replace to remove listeners cleanly
            const newSpan = vowelSpan.cloneNode(true) as HTMLSpanElement;
            vowelSpan.parentNode?.replaceChild(newSpan, vowelSpan);
        });

        // Find the span elements again after replacement
        const vowelSpans = Array.from(
            wordDisplay.querySelectorAll("span"),
        ) as HTMLSpanElement[];

        if (clickedIndex === correctIndex) {
            score++;
            scoreDisplay.textContent = score.toString();
            feedback.textContent = "Correct!";
            feedback.className = "feedback correct";

            const correctSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === correctIndex,
            );
            if (correctSpan) {
                correctSpan.classList.add("correct-stress");
            }
        } else {
            feedback.textContent = `Incorrect. Correct: ${correctWord}`;
            feedback.className = "feedback incorrect";

            const correctSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === correctIndex,
            );
            const incorrectSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === clickedIndex,
            );

            if (correctSpan) {
                correctSpan.classList.add("correct-stress");
            }
            if (incorrectSpan) {
                incorrectSpan.classList.add("incorrect-guess");
            }
        }

        nextButton.disabled = false;
    }

    function shuffleArray<T>(array: T[]): void {
        for (let i: number = array.length - 1; i > 0; i--) {
            const j: number = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    nextButton.addEventListener("click", displayNextWord);
    nextButton.disabled = true;
    loadWords();
});
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
        outDir: "dist",
        emptyOutDir: true,
        rollupOptions: {
            input: "./index.html",
            output: {
                entryFileNames: `assets/[name].[hash].js`,
                chunkFileNames: `assets/[name].[hash].js`,
                assetFileNames: `assets/[name].[hash].[ext]`
            }
        }
    },
    publicDir: "public",
    server: {
        open: true
    }
});
</file>

<file path="index.html">
<!doctype html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="./vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Russian Stress Practice</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="./src/main.jsx"></script>
    </body>
</html>
</file>

</files>
