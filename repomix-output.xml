This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
.lintstagedrc.yml
backend/.gitignore
backend/.lintstagedrc.yml
backend/eslint.config.mjs
backend/jest.config.cjs
backend/package.json
backend/src/index.ts
backend/src/lib/ctx.ts
backend/src/lib/prisma.ts
backend/src/lib/trpc.ts
backend/src/prisma/migrations/20250427152613_initial/migration.sql
backend/src/prisma/migrations/migration_lock.toml
backend/src/prisma/schema.prisma
backend/src/router/auth/GetAuth/index.ts
backend/src/router/auth/GetAuth/input.ts
backend/src/router/auth/GetMe/index.ts
backend/src/router/index.ts
backend/src/utils/deepMap.ts
backend/src/utils/env.ts
backend/src/utils/error.ts
backend/src/utils/logger.ts
backend/src/utils/models.ts
backend/src/utils/types.ts
backend/tsconfig.json
eslint.config.mjs
frontend/.envrc
frontend/.github/workflows/deploy.yml
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/public/index.js
frontend/public/phonetics.txt
frontend/public/vite.svg
frontend/README.md
frontend/src/App.tsx
frontend/src/components/Loader/index.tsx
frontend/src/components/Login/index.tsx
frontend/src/components/Navigation.tsx
frontend/src/components/svg/svgNative.tsx
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/ParonymsPage/index.tsx
frontend/src/pages/ParonymsPage/paronyms.js
frontend/src/pages/StressPracticePage/index.tsx
frontend/src/style.css
frontend/src/style.d.ts
frontend/src/utils.test.js
frontend/src/utils/ctx.tsx
frontend/src/utils/env.ts
frontend/src/utils/googleAuth.ts
frontend/src/utils/pumpGetRoute.ts
frontend/src/utils/routes.ts
frontend/src/utils/trpc.tsx
frontend/src/utils/utils.js
frontend/src/words.js
frontend/tailwind.config.js
frontend/tsconfig.json
frontend/vite.config.ts
jest.config.cjs
package.json
pnpm-workspace.yaml
shared/.lintstagedrc.yml
shared/jest.config.js
shared/package.json
shared/src/getKeysAsArray.ts
shared/src/omit.ts
shared/src/pick.ts
shared/src/tryCatch.ts
shared/src/zod.ts
shared/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/index.ts">
import { env } from "./utils/env";
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import cors from "cors";
import express from "express";
// import { createContext } from "./lib/trpc";
import { AppContext, createAppContext } from "./lib/ctx";
import { ApplyTrpcToExpressApp, getCreateTrpcContext } from "./lib/trpc";
import { trpcRouter } from "./router";
import { logger } from "./utils/logger";
const app = express();

void (async () => {
  let ctx: AppContext | null = null;
  try {
    const app = express();
    ctx = createAppContext();
    // await presetDb(ctx);
    app.use(cors({
      origin: ['http://localhost:5173'], // Explicitly allow your frontend origin
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
      allowedHeaders: [
        'Content-Type', 
        'Authorization', 
        'x-trpc-source',
        'Access-Control-Allow-Origin',
        'Access-Control-Allow-Credentials',
      ],
    }));
    app.options('*', cors());
    app.get("/ping", (req, res) => {
      res.send("pong");
    });
    app.use((error: unknown, req: express.Request, res: express.Response, next: express.NextFunction) => {
      logger.error('express', error)
      if (res.headersSent) {
        next(error)
        return
      }
      res.status(500).send('Internal server error')
    })

    await ApplyTrpcToExpressApp(app, ctx, trpcRouter);
    
    app.listen(env.PORT, () => {
      logger.info("app", `listening on http://localhost:${env.PORT}`);
    });
  } catch (error) {
    logger.error("app", error);
    await ctx?.stop();
  }
})();
</file>

<file path="backend/src/lib/ctx.ts">
import { createPrismaClient } from "./prisma";

export const createAppContext = () => {
  const prisma = createPrismaClient();
  return {
    prisma,
    stop: async () => {
      await prisma.$disconnect();
    },
  };
};

export type AppContext = ReturnType<typeof createAppContext>;
</file>

<file path="backend/src/lib/prisma.ts">
import { env } from "../utils/env";
import { PrismaClient } from "@prisma/client";
import { logger } from "../utils/logger";

export const createPrismaClient = () => {
  const prisma = new PrismaClient({
    log: [
      {
        emit: "event",
        level: "query",
      },
      {
        emit: "event",
        level: "info",
      },
    ],
  });

  prisma.$on("query", (e) => {
    logger.info("prisma:low:query", "Successfull request", {
      query: e.query,
      duration: e.duration,
      params: env.HOST_ENV === "local" ? e.params : "***",
    });
  });

  prisma.$on("info", (e) => {
    logger.info("prisma:low:info", e.message);
  });

  const extendedPrisma = prisma.$extends({
    client: {},
    query: {
      $allModels: {
        $allOperations: async ({ model, operation, args, query }) => {
          const start = Date.now();
          try {
            const result = await query(args);
            const durationMs = Date.now() - start;
            logger.info("prisma:high", "Successfull request", {
              model,
              operation,
              args,
              durationMs,
            });
            return result;
          } catch (error) {
            const durationMs = Date.now() - start;
            logger.error("prisma:high", error, {
              model,
              operation,
              args,
              durationMs,
            });
            throw error;
          }
        },
      },
    },
  });

  return extendedPrisma;
};
</file>

<file path="backend/src/lib/trpc.ts">
import { inferAsyncReturnType, initTRPC } from "@trpc/server";
import * as trpcExpress from "@trpc/server/adapters/express";
import { type Express } from "express";
import { SuperJSON } from "superjson";
import { expressHandler } from "trpc-playground/handlers/express";
import { TrpcRouter, type trpcRouter } from "../router";
// import { AppContext } from "./ctx";
import { ExpectedError } from "../utils/error";
import { logger } from "../utils/logger";
import { ExpressRequest } from "../utils/types";
import { AppContext } from "./ctx";

export const getTrpcContext = ({ appContext, req }: {appContext: AppContext, req: ExpressRequest}) => ({
  ...appContext,
  me: (req as ExpressRequest).user || null,
})


export const getCreateTrpcContext =
  (appContext: AppContext) =>
  ({ req }: trpcExpress.CreateExpressContextOptions) =>
    getTrpcContext({ appContext, req: req as ExpressRequest })

type TrpcContext = inferAsyncReturnType<
  ReturnType<typeof getCreateTrpcContext>
>;

const trpc = initTRPC.context<TrpcContext>().create({
  transformer: SuperJSON,
  errorFormatter: ({shape, error}) => {
    const orginalError = error.cause as Error
    const expected = orginalError instanceof ExpectedError
    return {
      ...shape,
      data: {
        ...shape.data,
        expected
      }
    }
  }
});

export const createTrpcRouter = trpc.router

export const trpcLoggedProcedure = trpc.procedure.use(
  trpc.middleware(async ({ path, type, next, ctx, rawInput }) => {
    const start = Date.now()
    const result = await next()
    const durationMs = Date.now() - start
    // const meta = {
    //   path,
    //   type,
    //   userId: ctx.me?.id || null,
    //   durationMs,
    //   rawInput: rawInput || null,
    // }
    const meta = {'meta': 'meta'}
    if (result.ok) {
      logger.info(`trpc:${type}:success`, 'Successfull request', { ...meta, output: result.data })
    } else {
      logger.error(`trpc:${type}:error`, result.error)
    }
    return result
  })
)

export const ApplyTrpcToExpressApp = async (
  app: Express,
  ctx: AppContext,
  trpcRouter: TrpcRouter,
) => {
  app.use(
    "/trpc",
    trpcExpress.createExpressMiddleware({
      router: trpcRouter,
      createContext: getCreateTrpcContext(ctx),
    }),
  );

  app.use(
    "/trpc-playground",
    await expressHandler({
      trpcApiEndpoint: "/trpc",
      playgroundEndpoint: "/trpc-playground",
      router: trpcRouter,
      request: {
        superjson: true,
      },
    }),
  );
};
</file>

<file path="backend/src/router/auth/GetAuth/index.ts">
import { Provider } from "@prisma/client";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { ExpectedError } from "../../../utils/error";
import { zOAuthLogin } from "./input";

export const GetAuthTrpcRoute = trpcLoggedProcedure
  .input(zOAuthLogin)
  .mutation(async ({ ctx, input }) => {
    const { provider, credentials } = input;

    try {
      // Try to find existing user
      const existingUser = await ctx.prisma.user.findUnique({
        where: {
          provider_providerId: {
            provider: provider as Provider,
            providerId: credentials.providerId,
          },
        },
      });

      if (existingUser) {
        // Update existing user's tokens
        return await ctx.prisma.user.update({
          where: { id: existingUser.id },
          data: {
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
            name: credentials.name || existingUser.name,
          },
        });
      }

      // Create new user
      return await ctx.prisma.user.create({
        data: {
          email: credentials.email,
          name: credentials.name,
          provider: provider as Provider,
          providerId: credentials.providerId,
          accessToken: credentials.accessToken,
          refreshToken: credentials.refreshToken,
          tokenExpires: credentials.tokenExpires,
        },
      });
    } catch (error) {
      throw new ExpectedError("Failed to process authentication");
    }
  });
</file>

<file path="backend/src/router/auth/GetAuth/input.ts">
import { z } from "zod";

export const zOAuthCredentials = z.object({
  email: z.string().email(),
  name: z.string().optional(),
  providerId: z.string(),
  accessToken: z.string(),
  refreshToken: z.string().optional(),
  tokenExpires: z.string().optional().transform(val => val ? new Date(val) : undefined),
});

export const zOAuthLogin = z.object({
  provider: z.enum(['GOOGLE', 'YANDEX']),
  credentials: zOAuthCredentials,
});
</file>

<file path="backend/src/router/auth/GetMe/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { toClientMe } from "../../../utils/models";

export const GetMeTrpcRoute = trpcLoggedProcedure.query(({ ctx }) => {
  return { me: toClientMe(ctx.me) };
});
</file>

<file path="backend/src/router/index.ts">
import { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { createTrpcRouter } from "../lib/trpc";
// @index('./**/index.ts', f => `import { ${f.path.split('/').slice(0, -1).pop()}TrpcRoute } from '${f.path.split('/').slice(0, -1).join('/')}'`)
import { GetAuthTrpcRoute } from './auth/GetAuth'
import { GetMeTrpcRoute } from './auth/GetMe'
// @endindex


export const trpcRouter = createTrpcRouter({
    // @index('./**/index.ts', f => `${f.path.split('/').slice(0, -1).pop()}: ${f.path.split('/').slice(0, -1).pop()}TrpcRoute,`)
    GetAuth: GetAuthTrpcRoute,
    GetMe: GetMeTrpcRoute,
    // @endindex
})


export type TrpcRouter = typeof trpcRouter;
export type TrpcRouterInput = inferRouterInputs<TrpcRouter>;
export type TrpcRouterOutput = inferRouterOutputs<TrpcRouter>;
</file>

<file path="backend/src/utils/deepMap.ts">
import _ from "lodash";

type ReplaceFn = ({
  path,
  key,
  value,
}: {
  path: string;
  key: string;
  value: Value;
}) => Value;
type Value =
  | Object
  | number
  | string
  | boolean
  | null
  | undefined
  | Function
  | Symbol
  | any[];

const recursion = ({
  input,
  replaceFn,
  seen,
  pathStartsWith,
  parentKey,
}: {
  input: Value;
  replaceFn: ReplaceFn;
  seen: WeakSet<any>;
  pathStartsWith: string;
  parentKey: string;
}): Value => {
  if (
    ["object", "function", "symbol"].includes(typeof input) &&
    input !== null
  ) {
    if (seen.has(input)) {
      return "!!!CIRCULAR!!!";
    } else {
      seen.add(input);
    }
  }
  const result = replaceFn({
    path: pathStartsWith.replace(/\.$/, ""),
    key: parentKey,
    value: input,
  });
  if (!result) {
    return result;
  }
  if (_.isArray(result)) {
    return result.map((item, index) =>
      recursion({
        input: item,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${index}.`,
        parentKey: index.toString(),
      }),
    );
  }
  if (_.isObject(result)) {
    const object: any = {};
    for (const [key, value] of Object.entries(result)) {
      object[key] = recursion({
        input: value,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${key}.`,
        parentKey: key,
      });
    }
    return object;
  }
  return result;
};

export const deepMap = <T = Value>(input: Value, replaceFn: ReplaceFn): T => {
  const seen = new WeakSet();
  const mappedObject = recursion({
    input,
    replaceFn,
    seen,
    pathStartsWith: "",
    parentKey: "",
  });
  const clonedMappedObject = _.cloneDeep(mappedObject);
  return clonedMappedObject as T;
};
</file>

<file path="backend/src/utils/env.ts">
import fs from 'fs';
import path from 'path';
import {zEnvNonemptyTrimmed} from '@russian-stress-practice/shared/src/zod'
import * as dotenv from "dotenv";
import { z } from "zod";

const findEnvFilePath = (dir: string): string | null => {
  const maybeEnvFilePath = path.join(dir, '.env')
  if (fs.existsSync(maybeEnvFilePath)) {
    return maybeEnvFilePath
  }
  if (dir === '/') {
    return null
  }
  return findEnvFilePath(path.dirname(dir))
}

const envFilePath = findEnvFilePath(__dirname)
if (envFilePath) {
  dotenv.config({ path: envFilePath })
  dotenv.config({ path: `${envFilePath}.${process.env.NODE_ENV}` })
}

const zEnv = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().min(1),
  HOST_ENV: z.enum(['local', 'production']).default('local'),
  DEBUG: z
  .string()
  .optional()
  .refine(
    (val) => process.env.HOST_ENV === 'local' || process.env.NODE_ENV !== 'production' || (!!val && val.length > 0),
    'Required on not local host on production'
  ),
  FRONTEND_URL: zEnvNonemptyTrimmed
});

export const env = zEnv.parse(process.env);
</file>

<file path="backend/src/utils/error.ts">
export class ExpectedError extends Error {
  isExpected = true as const;
}
</file>

<file path="backend/src/utils/logger.ts">
import { env } from "./env";
import { EOL } from "os";
import {omit} from "@russian-stress-practice/shared/src/omit"
import { TRPCError } from "@trpc/server";
import debug from "debug";
import _ from "lodash";
import pc from "picocolors";
import { serializeError } from "serialize-error";
import { MESSAGE } from "triple-beam";
import winston from "winston";
import * as yaml from "yaml";
import { deepMap } from "./deepMap";
import { ExpectedError } from "./error";
// import { sentryCaptureException } from "./sentry";

export const winstonLogger = winston.createLogger({
  level: "debug",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  defaultMeta: { service: "backend", hostEnv: env.HOST_ENV },
  transports: [
    new winston.transports.Console({
      format:
        env.HOST_ENV !== "local"
          ? winston.format.json()
          : winston.format((logData) => {
              const setColor = {
                info: (str: string) => pc.blue(str),
                error: (str: string) => pc.red(str),
                debug: (str: string) => pc.cyan(str),
              }[logData.level as "info" | "error" | "debug"];
              const levelAndType = `${logData.level} ${logData.logType}`;
              const timestamp =
                typeof logData.timestamp === "string" ? logData.timestamp : "";
              const topMessage = `[${setColor(levelAndType)}] ${pc.green(timestamp)}${EOL}${logData.message}`;

              const visibleMessageTags = omit(logData, [
                "level",
                "logType",
                "timestamp",
                "message",
                "service",
                "hostEnv",
              ]);

              const stringifyedLogData = _.trim(
                yaml.stringify(visibleMessageTags, (_k, v) =>
                  _.isFunction(v) ? "Function" : v,
                ),
              );

              const resultLogData = {
                ...logData,
                [MESSAGE]:
                  [
                    topMessage,
                    Object.keys(visibleMessageTags).length > 0
                      ? `${EOL}${stringifyedLogData}`
                      : "",
                  ]
                    .filter(Boolean)
                    .join("") + EOL,
              };

              return resultLogData;
            })(),
    }),
  ],
});

export type LoggerMetaData = Record<string, any> | undefined;
const prettifyMeta = (meta: LoggerMetaData): LoggerMetaData => {
  return deepMap(meta, ({ key, value }) => {
    if (
      [
        "email",
        "password",
        "newPassword",
        "oldPassword",
        "token",
        "text",
        "description",
      ].includes(key)
    ) {
      return "🙈";
    }
    return value;
  });
};

export const logger = {
  info: (logType: string, message: string, meta?: LoggerMetaData) => {
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    winstonLogger.info(message, { logType, ...prettifyMeta(meta) });
  },
  error: (logType: string, error: any, meta?: LoggerMetaData) => {
    // const isNativeExpectedError = error instanceof ExpectedError
    // const isTrpcExpectedError = error instanceof TRPCError && error.cause instanceof ExpectedError
    const prettifiedMetaData = prettifyMeta(meta)
    // if (!isNativeExpectedError && !isTrpcExpectedError) {
    //   sentryCaptureException(error, prettifiedMetaData)
    // }
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    const serializedError = serializeError(error);
    winstonLogger.error(serializedError.message || "Unknown error", {
      logType,
      error,
      errorStack: serializedError.stack,
      ...prettifiedMetaData,
    });
  },
};
</file>

<file path="backend/src/utils/models.ts">
import type { User } from "@prisma/client";
import {pick} from "@russian-stress-practice/shared/src/pick"

export const toClientMe = (user: User | null) => {
  return user && pick(user, ["id", "name", "email", "score", "provider", "providerId"]);
};
</file>

<file path="backend/src/utils/types.ts">
import { type User } from "@prisma/client";
import { type Request } from "express";

export type ExpressRequest = Request & {
  user: User | undefined;
};
</file>

<file path="frontend/src/components/Loader/index.tsx">
import { Bouncy } from "ldrs/react";
import React from "react";
import "ldrs/react/Bouncy.css";

interface LoaderProps {
    size: string
    speed: string
    color: string
}

export const Loader = ({size, speed, color}: LoaderProps) => {
  return (
    <>
      <Bouncy size={size} speed={speed} color={color} />
    </>
  );
};
</file>

<file path="frontend/src/components/Login/index.tsx">
import React, { useEffect } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";
import { useGoogleAuth  } from "../../utils/googleAuth";

interface LoginProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function Login({ isOpen, onClose }: LoginProps) {
  const login = useGoogleAuth();
  const handleGoogleLoginClick = async () => {
    try {
      login();
      onClose();
    } catch (error) {
      console.error('Failed to login with Google:', error);
    }
  };

  const handleYandexLogin = async () => {
    // TODO: Implement Yandex OAuth
    console.log("Yandex login clicked");
  };

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 backdrop-blur-sm" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <Dialog.Title
                  as="h3"
                  className="text-lg font-medium leading-6 text-gray-900 text-center mb-4"
                >
                  Войти в аккаунт
                </Dialog.Title>

                <div className="mt-4 space-y-3">
                  <button
                    onClick={handleGoogleLoginClick}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://www.google.com/favicon.ico"
                      alt="Google logo"
                    />
                    Войти через Google
                  </button>

                  <button
                    onClick={handleYandexLogin}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://yastatic.net/s3/home-static/_/7c/7ccf30cd11b00c2eb4f79f698da24aa2.png"
                      alt="Yandex logo"
                    />
                    Войти через Яндекс
                  </button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
}
</file>

<file path="frontend/src/components/Navigation.tsx">
import React, { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import Login from "./Login";
import { ParonymsLogo, SignInLogo, StressLogo, SymbolLogo } from "./svg/svgNative";
import { useMe } from "../utils/ctx";

export default function Navigation() {
  const location = useLocation();
  const [isLoginOpen, setIsLoginOpen] = useState(false);
  const me = useMe();
  console.log(me)
  return (
    <>
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10">
        <div className="container mx-auto flex justify-between items-center">
          <div className="text-xl font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            Русский язык: Тренажеры
          </div>
          <div className="flex items-center space-x-2">
            <Link
              to="/"
              className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
                location.pathname === "/"
                  ? "bg-indigo-100 text-indigo-700 shadow-sm"
                  : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
              }`}
            >
              <div className="flex items-center">
                <StressLogo />
                Ударения
              </div>
            </Link>
            <Link
              to="/paronyms"
              className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
                location.pathname === "/paronyms"
                  ? "bg-indigo-100 text-indigo-700 shadow-sm"
                  : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
              }`}
            >
              <div className="flex items-center">
                <ParonymsLogo />
                Паронимы
              </div>
            </Link>
            {me ? (
              <div className="ml-4 px-4 py-2 rounded-lg bg-indigo-100 text-indigo-700 flex items-center">
                <svg 
                  xmlns="http://www.w3.org/2000/svg" 
                  className="h-5 w-5 mr-2" 
                  viewBox="0 0 20 20" 
                  fill="currentColor"
                >
                  <path 
                    fillRule="evenodd" 
                    d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" 
                    clipRule="evenodd" 
                  />
                </svg>
                {me.name || me.email}
              </div>
            ) : (
              <button
                onClick={() => setIsLoginOpen(true)}
                className="ml-4 px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors duration-200 flex items-center"
              >
                <SignInLogo />
                Войти
              </button>
            )}
          </div>
        </div>
      </nav>

      <Login isOpen={isLoginOpen} onClose={() => setIsLoginOpen(false)} />
    </>
  );
}
</file>

<file path="frontend/src/components/svg/svgNative.tsx">
import React from "react";

export const SymbolLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-6 w-6 mr-2"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
      />
    </svg>
  );
};

export const StressLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"
      />
    </svg>
  );
};

export const ParonymsLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
      />
    </svg>
  );
};

export const SignInLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"
      />
    </svg>
  );
};
</file>

<file path="frontend/src/pages/ParonymsPage/index.tsx">
import React, { useState, useEffect } from 'react';
import paronymData from './paronyms';

export default function ParonymsPage() {
    const [currentParonymGroup, setCurrentParonymGroup] = useState<{ group: string[]; paronyms: { word: string; explanation: string; }[]; } | null>(null);
    const [correctAnswer, setCorrectAnswer] = useState<string | null>(null);
    const [score, setScore] = useState(0);
    const [showFeedback, setShowFeedback] = useState(false);
    const [isCorrect, setIsCorrect] = useState(false);
    const [selectedAnswer, setSelectedAnswer] = useState<string | null>(null);
    const [showExplanation, setShowExplanation] = useState(false);

    // Function to shuffle an array
    const shuffleArray = (array: any[]) => {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; // Swap elements
        }
        return newArray;
    };

    // Function to display a new question
    const displayNewQuestion = () => {
        // Clear previous feedback and explanations
        setShowFeedback(false);
        setShowExplanation(false);
        setSelectedAnswer(null);

        // Select a random paronym group
        const randomGroup = paronymData[Math.floor(Math.random() * paronymData.length)];
        setCurrentParonymGroup(randomGroup);

        // Select a random paronym from the group as the correct answer
        const correctParonymObject = randomGroup.paronyms[Math.floor(Math.random() * randomGroup.paronyms.length)];
        setCorrectAnswer(correctParonymObject.word);
    };

    // Function to handle user's answer
    interface Paronym {
        word: string;
        explanation: string;
    }

    interface ParonymGroup {
        group: string[];
        paronyms: Paronym[];
    }

    const handleAnswer = (answer: string) => {
        setSelectedAnswer(answer);
        setShowFeedback(true);

        if (answer === correctAnswer) {
            setIsCorrect(true);
            setScore(score + 1);
        } else {
            setIsCorrect(false);
        }

        setShowExplanation(true);
    };

    // Initialize with a question on component mount
    useEffect(() => {
        displayNewQuestion();
    }, []);

    if (!currentParonymGroup) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
                <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md w-full mx-auto text-center">
                    <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500 mx-auto mb-4"></div>
                    <p className="text-slate-700 text-lg">Загрузка паронимов...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg max-w-2xl w-full mx-auto my-auto overflow-hidden">
                <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">Тренажер паронимов</h1>

                <div className="flex flex-col items-center">
                    {currentParonymGroup && correctAnswer && (
                        <>
                            <div className="bg-slate-50 p-5 rounded-xl mb-6 w-full">
                                <p className="text-lg text-center text-slate-700 leading-relaxed">
                                    Выберите подходящее слово, соответствующее значению:
                                    <span className="font-medium block mt-2 text-indigo-700">
                                        "{currentParonymGroup.paronyms.find(p => p.word === correctAnswer)?.explanation}"
                                    </span>
                                </p>
                            </div>

                            <div className="flex flex-wrap justify-center gap-3 mb-6 w-full">
                                {shuffleArray(currentParonymGroup.paronyms).map((paronym) => (
                                    <button
                                        key={paronym.word}
                                        onClick={() => handleAnswer(paronym.word)}
                                        disabled={showFeedback}
                                        className={`
                                            py-3 px-6 rounded-xl font-medium text-lg transition-all duration-200 break-words max-w-full
                                            ${showFeedback && paronym.word === correctAnswer
                                                ? 'bg-emerald-500 text-white shadow-md transform scale-105'
                                                : ''}
                                            ${showFeedback && paronym.word === selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-rose-500 text-white'
                                                : ''}
                                            ${!showFeedback
                                                ? 'bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 hover:border-indigo-300 hover:text-indigo-600 hover:shadow-md hover:transform hover:scale-105 active:bg-indigo-50'
                                                : ''}
                                            ${showFeedback && paronym.word !== selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-slate-100 text-slate-400 border border-slate-200'
                                                : ''}
                                            focus:outline-none focus:ring-0
                                        `}
                                    >
                                        {paronym.word}
                                    </button>
                                ))}
                            </div>
                        </>
                    )}

                    {/* Feedback message - always reserve space for it */}
                    <div className={`text-center font-medium text-lg mb-6 py-4 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[80px] flex items-center justify-center
                        ${!showFeedback ? 'opacity-0' : ''}
                        ${showFeedback && isCorrect
                            ? 'bg-emerald-50 text-emerald-700 border border-emerald-200'
                            : showFeedback ? 'bg-rose-50 text-rose-700 border border-rose-200' : ''}`}>
                        {showFeedback ? (
                            isCorrect
                                ? (
                                    <div className="flex items-center justify-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        Правильно!
                                    </div>
                                )
                                : (
                                    <div>
                                        <div className="flex items-center justify-center mb-1">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-rose-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg>
                                            Неправильно
                                        </div>
                                        <div className="text-sm mt-1">
                                            Правильный ответ: <span className="font-semibold">{correctAnswer}</span>
                                        </div>
                                    </div>
                                )
                        ) : (
                            <span className="invisible">Placeholder for feedback</span>
                        )}
                    </div>

                    {/* Explanation section - always reserve space with min-height */}
                    <div className={`mt-6 border-t border-slate-100 pt-6 w-full transition-opacity duration-300 ${!showExplanation ? 'opacity-0 h-0 overflow-hidden' : ''}`}>
                        <h3 className="text-xl font-semibold mb-4 text-slate-700 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Объяснения:
                        </h3>
                        <div className="bg-slate-50 rounded-xl p-4 divide-y divide-slate-200">
                            {currentParonymGroup?.paronyms.map((paronym) => (
                                <div key={paronym.word} className="py-3 first:pt-0 last:pb-0">
                                    <p className="text-slate-700">
                                        <span className="font-semibold text-indigo-700">{paronym.word}:</span> {paronym.explanation}
                                    </p>
                                </div>
                            ))}
                        </div>
                    </div>

                    {showFeedback && (
                        <div className="flex justify-center w-full mt-8">
                            <button
                                onClick={displayNewQuestion}
                                className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                            >
                                Следующее слово
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
</file>

<file path="frontend/src/pages/ParonymsPage/paronyms.js">
// Data structure for paronyms
const paronymData = [
    {
        group: ["АДРЕСАТ", "АДРЕСАНТ"],
        paronyms: [
            { word: "АДРЕСАТ", explanation: "получатель" },
            { word: "АДРЕСАНТ", explanation: "отправитель" }
        ]
    },
    {
        group: ["АРТИСТИЧНЫЙ", "АРТИСТИЧЕСКАЯ"],
        paronyms: [
            { word: "АРТИСТИЧНЫЙ", explanation: "человек, исполнение" },
            { word: "АРТИСТИЧЕСКАЯ", explanation: "внешность, среда, подъезд, карьера, способности, артистическая натура" }
        ]
    },
    {
        group: ["АКАДЕМИЧЕСКИЙ", "АКАДЕМИЧНЫЙ"],
        paronyms: [
            { word: "АКАДЕМИЧЕСКИЙ", explanation: "оркестр" },
            { word: "АКАДЕМИЧНЫЙ", explanation: "подход" }
        ]
    },
    {
        group: ["АВТОРИТАРНЫЙ", "АВТОРИТЕТНЫЙ"],
        paronyms: [
            { word: "АВТОРИТАРНЫЙ", explanation: "основанный на диктатуре" },
            { word: "АВТОРИТЕТНЫЙ", explanation: "уважаемый" }
        ]
    },
    {
        group: ["БЕДНАЯ", "БЕДСТВЕННОЕ"],
        paronyms: [
            { word: "БЕДНАЯ", explanation: "девушка. Жил в БЕДНОСТИ." },
            { word: "БЕДСТВЕННОЕ", explanation: "положение" }
        ]
    },
    {
        group: ["БЕЗОТВЕТНАЯ", "БЕЗОТВЕТСТВЕННОЕ"],
        paronyms: [
            { word: "БЕЗОТВЕТНАЯ", explanation: "любовь" },
            { word: "БЕЗОТВЕТСТВЕННОЕ", explanation: "отношение, человек" }
        ]
    },
    {
        group: ["БУДНИЙ", "БУДНИЧНЫЙ"],
        paronyms: [
            { word: "БУДНИЙ", explanation: "день" },
            { word: "БУДНИЧНЫЙ", explanation: "(обыденный): дело, событие, заботы, платье, костюм; а также: однообразный, беспросветный, серый, безрадостный: голос, атмосфера, ответ, жизнь" }
        ]
    },
    // Add more paronym groups here...
    {
        group: ["БОЛОТИСТАЯ", "БОЛОТНАЯ"],
        paronyms: [
            { word: "БОЛОТИСТАЯ", explanation: "почва" },
            { word: "БОЛОТНАЯ", explanation: "птица, грязь" }
        ]
    },
    {
        group: ["БЛАГОДАРНЫЙ", "БЛАГОДАРСТВЕННЫЙ"],
        paronyms: [
            { word: "БЛАГОДАРНЫЙ", explanation: "человек, занятие" },
            { word: "БЛАГОДАРСТВЕННЫЙ", explanation: "молебен, письмо" }
        ]
    },
    {
        group: ["BЛАГОТВОРИТЕЛЬНЫЙ", "БЛАГОТВОРНОЕ"],
        paronyms: [
            { word: "БЛАГОТВОРИТЕЛЬНЫЙ", explanation: "фонд" },
            { word: "БЛАГОТВОРНОЕ", explanation: "влияние" }
        ]
    }
];

export default paronymData;
</file>

<file path="frontend/src/pages/StressPracticePage/index.tsx">
import React, { useState, useEffect, useMemo } from "react";
import {
  initializeWords,
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
} from "../../utils/utils";
import rawWords from "../../words";

// Define interfaces for better type safety
interface Word {
  word: string;
  accentIdx: number;
  retired?: boolean;
  correctStreak: number;
  wrongCount: number;
  nextReview: Date;
}

// List of Russian vowels
const vowels = ["а", "е", "ё", "и", "о", "у", "ы", "э", "ю", "я"];

export default function StressPracticePage() {
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState<Word[]>(() => initializeWords(rawWords));

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState<Word | null>(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState<number | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to track the number of incorrect answers
  const [incorrectCount, setIncorrectCount] = useState(0);

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);

  // Get due words and set the first one as current on mount
  useEffect(() => {
    loadNextWord();
  }, []);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter((w) => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split("") : [];

  // Load the next word to practice
  const loadNextWord = (): void => {
    const due = getDueWords(words, today);

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else {
      setCurrentWord(null);
      setAllLearned(true);
    }

    setSelected(null);
    setFeedback("");
    setRequireRetry(false);
  };

  // Handle first correct answer
  const handleFirstCorrect = (): void => {
    setFeedback("✅ Правильно! Попробуй ещё раз.");
    setRequireRetry(true);
  };

  // Handle first wrong answer
  const handleFirstWrong = (selectedIdx: number): void => {
    setFeedback("❌ Неправильно. Попробуй ещё раз.");
    setRequireRetry(true);
    setIncorrectCount((prev) => prev + 1);
  };

  // Handle the retry attempt
  const finalizeRetry = (selectedIdx: number): void => {
    if (!currentWord) return;

    if (selectedIdx === currentWord.accentIdx) {
      // Correct on retry
      setFeedback("✅ Правильно!");

      // Update the word's learning metadata
      setWords((prevWords: Word[]) => {
        return updateWord(prevWords, currentWord, (word: Word) => {
          word.correctStreak += 1;

          // If streak reaches 4, retire the word
          if (word.correctStreak >= 4) {
            word.retired = true;
          } else {
            // Otherwise, schedule next review based on streak
            word.nextReview = computeNextReview(word.correctStreak, today);
          }
        });
      });
    } else {
      // Wrong on retry
      setFeedback("❌ Неправильно. Правильный ответ выделен.");

      // Reset the word's streak
      setWords((prevWords: Word[]) => {
        return updateWord(prevWords, currentWord, (word: Word) => {
          word.correctStreak = 0;
          word.wrongCount += 1;
          word.nextReview = addDays(today, 1); // Review again tomorrow
        });
      });

      setIncorrectCount((prev) => prev + 1);
    }

    // No longer require retry
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx: number): void => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback && !requireRetry) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // Handle based on whether this is first attempt or retry
    if (!requireRetry) {
      // First attempt
      if (idx === currentWord.accentIdx) {
        handleFirstCorrect();
      } else {
        handleFirstWrong(idx);
      }
    } else {
      // Retry attempt
      finalizeRetry(idx);
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = (): void => {
    setShowAllWords((prev) => !prev);
  };

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats */}
      <div className="w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <div>
          {" "}
          {/* Container for the stats */}
          <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">
            Статистика
          </h2>
          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Всего слов</p>
                <p className="text-xl font-semibold text-slate-800">
                  {words.length}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Выучено</p>
                <p className="text-xl font-semibold text-emerald-600">
                  {retiredWords.length}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Осталось</p>
                <p className="text-xl font-semibold text-indigo-600">
                  {words.length - retiredWords.length}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Ошибок</p>
                <p className="text-xl font-semibold text-amber-600">
                  {incorrectCount}
                </p>
              </div>
            </div>
          </div>
          <h3 className="text-lg font-semibold mb-3 text-slate-700 flex items-center">
            <span className="mr-2">
              {showAllWords ? "Все слова" : "Слова на изучении"}
            </span>
            <span className="text-xs px-2 py-1 bg-slate-100 rounded-full text-slate-600">
              {(showAllWords ? words : words.filter((w) => !w.retired)).length}
            </span>
          </h3>
          <ul className="max-h-96 overflow-y-auto mb-4 bg-white rounded-xl shadow-sm divide-y divide-slate-100">
            {(showAllWords ? words : words.filter((w) => !w.retired)).map(
              (wordObj, i) => (
                <li
                  key={i}
                  className="py-2 px-3 flex justify-between items-center hover:bg-slate-50 transition-colors"
                >
                  <span className="text-slate-700">{wordObj.word}</span>
                  <span
                    className={`px-2 py-1 rounded-full text-xs font-medium ${
                      wordObj.retired
                        ? "bg-emerald-100 text-emerald-700"
                        : "bg-indigo-100 text-indigo-700"
                    }`}
                  >
                    {wordObj.retired ? "✓" : `${wordObj.correctStreak}/4`}
                  </span>
                </li>
              )
            )}
          </ul>
        </div>

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-auto px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? "Показать изучаемые" : "Показать все слова"}
        </button>
      </div>

      {/* Main content area */}
      <div className="w-3/4 p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">
            Тренажер ударений
          </h1>

          {allLearned ? (
            // Show congratulations message when all words are learned
            <div className="text-center py-12 px-8 bg-white rounded-2xl shadow-lg">
              <div className="w-20 h-20 bg-emerald-100 rounded-full flex items-center justify-center mx-auto mb-6">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  className="h-10 w-10 text-emerald-600"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M5 13l4 4L19 7"
                  />
                </svg>
              </div>
              <h2 className="text-2xl font-bold text-emerald-600 mb-4">
                Поздравляем!
              </h2>
              <p className="text-lg mb-4 text-slate-700">
                Вы выучили все слова на сегодня.
              </p>
              <p className="text-md text-slate-500">
                Приходите завтра для повторения.
              </p>
            </div>
          ) : (
            // Regular practice UI
            <>
              {/* Progress display */}
              <div className="mb-6 flex justify-between text-slate-600 bg-white px-4 py-3 rounded-xl shadow-sm">
                <span className="flex items-center">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-5 w-5 mr-2 text-emerald-500"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                    />
                  </svg>
                  Выучено:{" "}
                  <span className="font-semibold ml-1">
                    {retiredWords.length}/{words.length}
                  </span>
                </span>
                <span className="flex items-center">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-5 w-5 mr-2 text-indigo-500"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                    />
                  </svg>
                  Осталось сегодня:{" "}
                  <span className="font-semibold ml-1">{dueWords.length}</span>
                </span>
              </div>

              {/* Word display */}
              <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg mb-4 flex flex-col items-center w-full max-w-full">
                {/* Word display with overflow handling */}
                <div className="w-full overflow-x-auto mb-8 py-2">
                  <div className="flex justify-center items-center space-x-2 text-4xl md:text-5xl min-w-min mx-auto">
                    {letters.map((letter, idx) => {
                      const isVowel = vowels.includes(letter.toLowerCase());
                      const isCorrect = idx === currentWord?.accentIdx;
                      const isSelected = selected === idx;
                      const showCorrect =
                        requireRetry === false && feedback && isCorrect;

                      return (
                        <span
                          key={idx}
                          onClick={() => handleSelect(idx)}
                          className={`
                            relative cursor-pointer px-2 py-1 rounded-lg transition-all duration-200
                            ${
                              isVowel
                                ? "hover:bg-slate-100 hover:transform hover:scale-110"
                                : ""
                            }
                            ${
                              isSelected && isCorrect
                                ? "bg-emerald-500 text-white transform scale-110"
                                : ""
                            }
                            ${
                              isSelected && !isCorrect
                                ? "bg-rose-500 text-white"
                                : ""
                            }
                            ${
                              showCorrect
                                ? "bg-emerald-500 text-white transform scale-110"
                                : ""
                            }
                          `}
                        >
                          {letter}
                          {isVowel && (
                            <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                          )}
                        </span>
                      );
                    })}
                  </div>
                </div>

                {/* Feedback message - always reserve space for it */}
                <div
                  className={`text-center my-6 text-lg font-medium py-3 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[60px] flex items-center justify-center
                  ${!feedback ? "opacity-0" : ""}
                  ${
                    feedback && feedback.includes("Правильно")
                      ? "bg-emerald-50 text-emerald-700 border border-emerald-200"
                      : feedback
                      ? "bg-rose-50 text-rose-700 border border-rose-200"
                      : ""
                  }`}
                >
                  {feedback || "Placeholder for feedback"}
                </div>

                {/* Next word button - changes text based on retry state */}
                <div className="flex justify-center w-full mt-6">
                  {requireRetry ? (
                    <button
                      onClick={() => {
                        // Clear feedback and reset selected state to prepare for retry
                        setFeedback("");
                        setSelected(null);
                      }}
                      className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                    >
                      Попробуй ещё раз
                    </button>
                  ) : (
                    <button
                      onClick={loadNextWord}
                      className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                      disabled={feedback !== "" && requireRetry}
                    >
                      Следующее слово
                    </button>
                  )}
                </div>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/utils/ctx.tsx">
import type { TrpcRouterOutput } from "@russian-stress-practice/backend/src/router";
import React, { createContext, useContext, useEffect } from "react";
import trpc from "./trpc";
import { Loader } from "../components/Loader";

export type AppContext = {
  me: TrpcRouterOutput["GetMe"]["me"];
};

const AppReactContext = createContext<AppContext>({
  me: null,
});

export const AppContextProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const { data, error, isLoading, isFetching, isError } = trpc.GetMe.useQuery();
  
  useEffect(() => {
    console.log("GetMe query state:", { 
      data, 
      error, 
      isLoading, 
      isFetching, 
      isError 
    })
  }, [data, error, isLoading, isFetching, isError]);
  
  return (
    <AppReactContext.Provider
      value={{
        me: data?.me || null,
      }}
    >
      {isLoading || isFetching ? (
        <Loader size="45px" speed="1.2s" color="rgb(67, 73, 233)" />
      ) : isError ? (
        <p>Error: {error?.message}</p>
      ) : (
        children
      )}
    </AppReactContext.Provider>
  );
};

export const useAppContext = () => {
  return useContext(AppReactContext);
};

export const useMe = () => {
  const { me } = useAppContext();
  return me;
};
</file>

<file path="frontend/src/utils/env.ts">
import { z } from "zod";
import zEnvNonemptyTrimmed, {zEnvHost} from '@russian-stress-practice/shared/src/zod'
 
export const zEnv = z.object({
  VITE_BACKEND_TRPC_URL: zEnvNonemptyTrimmed,
  VITE_WEBAPP_URL: zEnvNonemptyTrimmed,
  HOST_ENV: zEnvHost,
  VITE_GOOGLE_CLIENT_ID: zEnvNonemptyTrimmed,
  VITE_GOOGLE_REDIRECT_URI: zEnvNonemptyTrimmed,
  NODE_ENV: z.enum(["development", "production"]),
});

// eslint-disable-next-line no-restricted-syntax
export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/utils/googleAuth.ts">
import { useGoogleLogin } from '@react-oauth/google';
import trpc from '../utils/trpc';
import { useQueryClient } from '@tanstack/react-query';
import Cookies from 'js-cookie';

interface GoogleCredentials {
  email: string;
  name?: string;
  providerId: string;
  accessToken: string;
  refreshToken?: string;
  tokenExpires?: string;
}

/**
 * Кастомный хук для Google OAuth: переводим хук мутации наружу
 */
export function useGoogleAuth() {
  const { mutateAsync } = trpc.GetAuth.useMutation();
  const queryClient = useQueryClient();

  return useGoogleLogin({
    flow: 'implicit',
    scope: 'openid email profile',
    onSuccess: async (tokenResponse) => {
      try {
        const userInfo = await fetch(
          'https://www.googleapis.com/oauth2/v3/userinfo',
          { 
            headers: { Authorization: `Bearer ${tokenResponse.access_token}` },
            mode: 'cors'
          }
        ).then(res => res.json());

        const creds: GoogleCredentials = {
          email: userInfo.email,
          name: userInfo.name,
          providerId: userInfo.sub,
          accessToken: tokenResponse.access_token,
          refreshToken: tokenResponse.access_token,
          tokenExpires: new Date(Date.now() + tokenResponse.expires_in * 1000).toISOString(),
        };

        await mutateAsync({
          provider: 'GOOGLE',
          credentials: creds,
        });
        Cookies.set('token', tokenResponse.access_token);
        queryClient.invalidateQueries(['GetMe']);
        window.location.reload()
      } catch (error) {
        console.error('Ошибка Google OAuth:', error);
      }
    },
    onError: (error) => {
      console.error('Не удалось войти через Google:', error);
    },
  });
}
</file>

<file path="frontend/src/utils/pumpGetRoute.ts">
import { useParams as useReactRouterParams } from "react-router-dom";

const baseUrl = process.env.VITE_WEBAPP_URL || process.env.WEBAPP_URL;

type PumpedGetRouteInputBase = {
  abs?: boolean;
};

function pumpGetRoute<T extends Record<string, boolean>>(
  routeParamsDefinition: T,
  getRoute: (routeParams: Record<keyof T, string>) => string,
): {
  (routeParams: Record<keyof T, string> & PumpedGetRouteInputBase): string;
  placeholders: Record<keyof T, string>;
  useParams: () => Record<keyof T, string>;
  definition: string;
};

function pumpGetRoute(getRoute: () => string): {
  (routeParams?: PumpedGetRouteInputBase): string;
  placeholders: {};
  useParams: () => {};
  definition: string;
};

function pumpGetRoute(routeParamsOrGetRoute?: any, maybeGetRoute?: any) {
  const routeParamsDefinition =
    typeof routeParamsOrGetRoute === "function" ? {} : routeParamsOrGetRoute;
  const getRoute =
    typeof routeParamsOrGetRoute === "function"
      ? routeParamsOrGetRoute
      : maybeGetRoute;
  const placeholders = Object.keys(routeParamsDefinition).reduce(
    (acc, key) => ({ ...acc, [key]: `:${key}` }),
    {},
  );
  const definition = getRoute(placeholders);
  const pumpedGetRoute = (routeParams?: PumpedGetRouteInputBase) => {
    const route = getRoute(routeParams);
    if (routeParams?.abs) {
      return `${baseUrl}${route}`;
    } else {
      return route;
    }
  };
  pumpedGetRoute.placeholders = placeholders;
  pumpedGetRoute.definition = definition;
  pumpedGetRoute.useParams = useReactRouterParams as any;
  return pumpedGetRoute;
}

export type RouteParams<T extends { placeholders: Record<string, string> }> =
  T["placeholders"];

export const pgr = pumpGetRoute;
</file>

<file path="frontend/src/utils/routes.ts">
import { pgr } from "./pumpGetRoute";

export const GetAuth = ''
</file>

<file path="frontend/src/utils/trpc.tsx">
import { env } from "./env";
import React from 'react'
import { createTRPCReact } from "@trpc/react-query";
import type { TrpcRouter } from "@russian-stress-practice/backend/src/router";
import Cookies from "js-cookie";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { httpBatchLink, loggerLink } from "@trpc/react-query";
import { SuperJSON } from "superjson";

const trpc = createTRPCReact<TrpcRouter>();

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
    },
  },
});

const trpcClient = trpc.createClient({
  transformer: SuperJSON,
  links: [
    loggerLink({
      enabled: () => env.NODE_ENV === 'development'
    }),
    httpBatchLink({
      url: env.VITE_BACKEND_TRPC_URL,
      headers: () => {
        const token = Cookies.get("token");
        console.log(token)
        return {
          ...(token && { authorization: `Bearer ${token}` }),
          'Access-Control-Allow-Origin': '*',
        };
      },
      fetch: (url, options) => {
        return fetch(url, {
          ...options,
          credentials: 'include', // Important for CORS
        });
      },
    }),
  ],
});

export const TrpcProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
};

export default trpc;
</file>

<file path="frontend/src/utils/utils.js">
// Date utility functions
export function addDays(d, n) {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak, today = new Date()) {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords) {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: null,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words, targetWord, updateFn) {
  return words.map(word => {
    if (word.word === targetWord.word) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review
export function getDueWords(words, today = new Date()) {
  return words
    .filter(w => !w.retired && w.nextReview <= today)
    .sort(() => Math.random() - 0.5); // Simple shuffle
}
</file>

<file path="shared/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix
  - prettier --loglevel warn --cache --write
"*.{json,yml,scss}": prettier --loglevel warn --cache --write
</file>

<file path="shared/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.js'),
  }
</file>

<file path="shared/package.json">
{
  "name": "@russian-stress-practice/shared",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --ext .ts .",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "test": "jest"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/lodash": "^4.17.15"
  }
}
</file>

<file path="shared/src/getKeysAsArray.ts">
import lodashKeys from 'lodash/keys'

// https://catchts.com/union-array
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type UnionToOvlds<U> = UnionToIntersection<U extends any ? (f: U) => void : never>
type PopUnion<U> = UnionToOvlds<U> extends (a: infer A) => void ? A : never
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true
type UnionToArray<T, A extends unknown[] = []> = IsUnion<T> extends true
  ? UnionToArray<Exclude<T, PopUnion<T>>, [PopUnion<T>, ...A]>
  : [T, ...A]

export const getKeysAsArray = <T>(obj: T): UnionToArray<keyof T> => {
  return lodashKeys(obj) as UnionToArray<keyof T>
}
</file>

<file path="shared/src/omit.ts">
import lodashOmit from 'lodash/omit'

export const omit = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Omit<TObject, TKeys> => {
  return lodashOmit(obj, keys)
}
</file>

<file path="shared/src/pick.ts">
import lodashPick from 'lodash/pick'

export const pick = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Pick<TObject, TKeys> => {
  return lodashPick(obj, keys)
}
</file>

<file path="shared/src/tryCatch.ts">
type Success<T> = {
    data: T;
    error: null;
  };
  
  type Failure<E> = {
    data: null;
    error: E;
  };
  
  type Result<T, E = Error> = Success<T> | Failure<E>;
  
  export async function tryCatch<T, E = Error>(
    promise: Promise<T>,
  ): Promise<Result<T, E>> {
    try {
      const data = await promise;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error as E };
    }
}
</file>

<file path="shared/src/zod.ts">
import { z } from "zod";

export const zEnvNonemptyTrimmed = z.string().trim().min(1);
export default zEnvNonemptyTrimmed;
export const zEnvNonemptyTrimmedRequiredOnNotLocal = zEnvNonemptyTrimmed
  .optional()
  .refine(
    // eslint-disable-next-line node/no-process-env
    (val) => `${process.env.HOST_ENV}` === "local" || !!val,
    "Required on not local host",
  );
export const zEnvHost = z.enum(["local", "production"]);

export const zStringRequired = z
  .string({ required_error: "Please, fill it" })
  .min(1, "Please, fill it");
export const zStringOptional = z.string().optional();
export const zEmailRequired = zStringRequired.email();
export const zNickRequired = zStringRequired.regex(
  /^[a-z0-9-]+$/,
  "Nick may contain only lowercase letters, numbers and dashes",
);
export const zStringMin = (min: number) =>
  zStringRequired.min(min, `Text should be at least ${min} characters long`);
export const zPasswordsMustBeTheSame =
  (passwordFieldName: string, passwordAgainFieldName: string) =>
  (val: any, ctx: z.RefinementCtx) => {
    if (val[passwordFieldName] !== val[passwordAgainFieldName]) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Passwords must be the same",
        path: [passwordAgainFieldName],
      });
    }
  };
</file>

<file path="shared/tsconfig.json">
{
  "extends": "../backend/tsconfig.json",
  "include": ["src"]
}
</file>

<file path=".lintstagedrc.yml">
'*.{ts,js,json,yml}': 'prettier --loglevel warn --cache --write'
</file>

<file path="backend/.gitignore">
node-modules
dist
.DS_Store
.env
</file>

<file path="backend/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix"
  - "prettier --loglevel warn --cache --write"
"*.{json,yml,scss}": "prettier --loglevel warn --cache --write"
</file>

<file path="backend/eslint.config.mjs">
import { defineConfig } from "eslint/config";
import path from 'path';
import tsParser from '@typescript-eslint/parser';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import importPlugin from 'eslint-plugin-import';

export default defineConfig([{
    files: ['**/*.ts', '**/*.tsx', '**/*.js'],
    ignores: ['jest.config.js'],
    plugins: {
        '@typescript-eslint': tsPlugin,
        'import': importPlugin
      },
    languageOptions: {
        ecmaVersion: 5,
        sourceType: "script",
        parser: tsParser,
        parserOptions: {
            project: "./tsconfig.json",
        },
    },

    settings: {
        "import/resolver": {
            node: {
                extensions: [".js", ".ts", ".tsx"],
            },
        },
    },

    rules: {
        "no-console": "error",

        "no-restricted-imports": ["error", {
        patterns: [{
          group: [
            path.join(process.cwd(), "src/test/**"),
            `!${path.join(process.cwd(), "src/**/*.integration.test.ts")}`
          ],
          message: "Import from test dir is only allowed in integration test files",
        }]
      }],

      "import/order": ["error", {
            groups: ["builtin", "external", "parent", "sibling", "index"],

            pathGroups: [{
                pattern: "{.,..}/**/env\n",
                group: "builtin",
                position: "before",
            }, {
                pattern: "{.,..}/**/test/integration\n",
                group: "builtin",
                position: "before",
            }],

            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],
    },
}]);
</file>

<file path="backend/jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.cjs'),
  }
</file>

<file path="backend/package.json">
{
  "name": "@russian-stress-practice/backend",
  "version": "0.0.0",
  "private": "true",
  "devDependencies": {
    "@sentry/cli": "^2.43.0",
    "@types/cors": "^2.8.17",
    "@types/debug": "^4.1.12",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/lodash": "^4.17.15",
    "@types/node": "^22.10.7",
    "@types/triple-beam": "^1.3.5",
    "@typescript-eslint/eslint-plugin": "^8.26.1",
    "@typescript-eslint/parser": "^8.26.1",
    "dotenv-cli": "^8.0.0",
    "eslint-plugin-import": "^2.31.0",
    "prisma": "^6.6.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0"
  },
  "scripts": {
    "dev": "ts-node-dev --rs --exit-child ./src/index.ts",
    "build-emails": "rimraf \"./src/emails/dist\" && mkdir \"./src/emails/dist\" && mjml \"./src/emails/[!_]*.mjml\" -o \"./src/emails/dist\"",
    "copy-emails": "copyfiles ./src/emails/dist/*.html ./dist/backend",
    "watch-emails": "mjml -w ./src/emails/[!_]*.mjml -o ./src/emails/dist",
    "build-ts": "rimraf ./dist && tsc --build ./tsconfig.build.json",
    "build": "pnpm build-emails && pnpm build-ts && pnpm copy-emails",
    "start": "cross-env NODE_ENV=production node ./dist/backend/src/index.js",
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache .",
    "pmd": "prisma migrate dev",
    "pmt": "dotenv -e ./.env.test prisma migrate deploy",
    "pgc": "prisma generate",
    "test": "jest --runInBand",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "prepare": "pnpm pgc && ts-patch install -s",
    "sentry-release": "dotenv -- bash -c 'sentry-cli releases new ${SOURCE_VERSION} --finalize --org no-lox --project backend --auth-token ${SENTRY_AUTH_TOKEN}'",
    "sentry-sourcemaps": "dotenv -- bash -c 'sentry-cli releases files ${SOURCE_VERSION} upload-sourcemaps ./dist --org no-lox --project backend'",
    "sentry": "pnpm sentry-release && pnpm sentry-sourcemaps"
  },
  "prisma": {
    "schema": "./src/prisma/schema.prisma"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0",
    "@russian-stress-practice/frontend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@trpc/server": "^10.45.2",
    "axios": "^1.8.4",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "cron": "^4.1.3",
    "date-fns": "^4.1.0",
    "debug": "^4.4.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "fast-glob": "^3.3.3",
    "handlebars": "^4.7.8",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "picocolors": "^1.1.1",
    "randomstring": "^1.3.1",
    "serialize-error": "^8.1.0",
    "superjson": "1.13.1",
    "triple-beam": "^1.4.1",
    "trpc-playground": "^1.0.4",
    "winston": "^3.17.0",
    "yaml": "^2.7.1",
    "zod": "^3.24.2"
  }
}
</file>

<file path="backend/src/prisma/migrations/20250427152613_initial/migration.sql">
-- CreateEnum
CREATE TYPE "Provider" AS ENUM ('GOOGLE', 'YANDEX');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "score" INTEGER NOT NULL DEFAULT 0,
    "provider" "Provider" NOT NULL,
    "providerId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "tokenExpires" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Word" (
    "id" SERIAL NOT NULL,
    "word" TEXT NOT NULL,
    "stress" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Word_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Practice" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "wordId" INTEGER NOT NULL,
    "correct" BOOLEAN NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Practice_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "User_provider_providerId_key" ON "User"("provider", "providerId");

-- CreateIndex
CREATE INDEX "Practice_userId_idx" ON "Practice"("userId");

-- CreateIndex
CREATE INDEX "Practice_wordId_idx" ON "Practice"("wordId");

-- AddForeignKey
ALTER TABLE "Practice" ADD CONSTRAINT "Practice_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Practice" ADD CONSTRAINT "Practice_wordId_fkey" FOREIGN KEY ("wordId") REFERENCES "Word"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/src/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="backend/src/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  name          String?
  score         Int       @default(0)
  // OAuth specific fields
  provider      Provider  // тип провайдера (Google, Yandex)
  providerId    String    // ID пользователя у провайдера
  accessToken   String?   // токен доступа от провайдера
  refreshToken  String?   // токен обновления от провайдера
  tokenExpires  DateTime? // время истечения токена
  practices     Practice[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([provider, providerId]) // Уникальный индекс для связки провайдер + providerId
}

enum Provider {
  GOOGLE
  YANDEX
}

model Word {
  id        Int        @id @default(autoincrement())
  word      String
  stress    Int        // Позиция ударения
  practices Practice[]
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
}

model Practice {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  correct   Boolean
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([wordId])
}
</file>

<file path="backend/tsconfig.json">
{
  "ts-node": {
    "files": true,
    "transpile0nly": true
  },
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "downlevelIteration": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "inlineSources": true,
    "isolatedModules": false,
    "lib": ["ES2021"],
    "module": "commonjs",
    "moduleResolution": "Node",
    "target": "ES2021",
  },
  "include": ["src"]
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import node from "eslint-plugin-node";
import jest from "eslint-plugin-jest";
import path from "node:path";
import { fileURLToPath } from "node:url";
import js from "@eslint/js";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
    baseDirectory: __dirname,
    recommendedConfig: js.configs.recommended,
    allConfig: js.configs.all
});

export default defineConfig([globalIgnores(["**/node_modules", "**/dist", "**/*.config.js"]), {
    extends: compat.extends("standard-with-typescript", "prettier", "plugin:jest/recommended"),

    plugins: {
        node,
        jest,
    },

    rules: {
        "no-new": "off",

        "import/order": ["error", {
            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],

        "@typescript-eslint/consistent-type-definitions": ["error", "type"],
        "@typescript-eslint/strict-boolean-expressions": "off",
        "@typescript-eslint/prefer-nullish-coalescing": "off",
        "@typescript-eslint/explicit-function-return-type": "off",
        "@typescript-eslint/restrict-template-expressions": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/consistent-type-assertions": "off",
        "jsx-a11y/anchor-is-valid": "off",
        curly: ["error", "all"],

        "no-irregular-whitespace": ["error", {
            skipTemplates: true,
            skipStrings: true,
        }],

        "node/no-process-env": "error",

        "no-restricted-syntax": ["error", {
            selector: "[object.type=MetaProperty][property.name=env]",
            message: "Use instead import { env } from \"lib/env\"",
        }],
    },
}]);
</file>

<file path="frontend/.envrc">
use flake
</file>

<file path="frontend/.github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cross-Origin-Opener-Policy"
      content="same-origin-allow-popups"
    />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <title>Russian Stress Practice</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>

<file path="frontend/public/phonetics.txt">
аэропОрты
бАнты
бОроду
бухгАлтеров
вероисповЕдание
водопровОд
газопровОд
граждАнство
дефИс
дешевИзна
диспансЕр
договорЁнность
докумЕнт
досУг
еретИк
жалюзИ
знАчимость
Иксы
каталОг
квартАл
киломЕтр
кОнусов
корЫсть
крАны
кремЕнь; кремнЯ
лЕкторов
лОктя
лыжнЯ
мЕстностей
намЕрение
нарОст
нЕдруг
недУг
некролОг
нЕнависть
нефтепровОд
новостЕй
нОгтя
Отзыв
отзЫв
Отрочество
партЕр
портфЕль
пОручни
придАное
призЫв
свЁкла
сирОты
созЫв
сосредотОчение
срЕдства
стАтуя
столЯр
тамОжня
тОрты
тУфля
цемЕнт
цЕнтнер
цепОчка
шАрфы
шофЁр
экспЕрт
вернА
знАчимый
красИвее; красИвейший
кУхонный
ловкА
мозаИчный
оптОвый
прозорлИвый; прозорлИва
слИвовый
бралА
бралАсь
взялА
взялАсь
влилАсь
ворвалАсь
воспринЯть; воспринялА
воссоздалА
вручИт
гналА
гналАсь
добралА
добралАсь
дождалАсь
дозвонИтся
дозИровать
ждалА
жилОсь
закУпорить
занЯть
заперлА
запломбировАть
защемИт
звалА
звонИт
кАшлянуть
клАла
клЕить
крАлась
кровоточИть
лгалА
лилА
лилАсь
навралА
наделИт
надорвалАсь
назвалАсь
накренИтся
налилА
нарвалА
начАть
обзвонИт
облегчИть; облегчИт
облилАсь
обнялАсь
обогналА
ободралА
ободрИть; ободрИт
ободрИться; ободрИтся
обострИть
одолжИть; одолжИт
озлОбить
оклЕить
окружИт
опОшлить
освЕдомиться; освЕдомится
отбылА
отдалА
откУпорить
отозвалА
отозвалАсь
перезвонИт
перелилА
плодоносИть
пломбировАть
повторИт
позвалА
позвонИть
полилА
положИть
понЯть; понялА
послАла
прибЫть; прИбыл, прибылА, прИбыли
принЯть; прИнял, принялА, прИняли
рвалА
сверлИт
снялА
совралА
создалА
сорвалА
сорИт
убралА
углубИть
укрепИт
чЕрпать
щемИт
щЁлкать
довезЁнный
зАгнутый
зАнятый; занятА
зАпертый
заселЁнный; заселенА
кормЯщий
кровоточАщий
нажИвший
налИвший
нанЯвшийся
начАвший
нАчатый
низведЁнный
облегчЁнный
ободрЁнный
обострЁнный
отключЁнный
повторЁнный
поделЁнный
понЯвший
прИнятый; принятА
приручЁнный
прожИвший
снятА
сОгнутый
углублЁнный
закУпорив
начАв
начАвшись
отдАв
поднЯв
понЯв
прибЫв
создАв
вОвремя
дОверху
донЕльзя
дОнизу
дОсуха
зАсветло
зАтемно
красИвее
надОлго
ненадОлго
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1997.5 2000" style="enable-background:new 0 0 1997.5 2000" xml:space="preserve"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="498.781" y1="2229.557" x2="1666.593" y2="643.575" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#41d1ff"/><stop offset="1" style="stop-color:#bd34fe"/></linearGradient><path d="m1990.9 296-938.3 1677.9c-19.4 34.6-69.1 34.8-88.8.4L6.8 296.2c-21.4-37.6 10.7-83.1 53.3-75.5l939.3 167.9c6 1.1 12.1 1.1 18.1 0L1937.2 221c42.4-7.8 74.7 37.4 53.7 75z" style="fill:url(#a)"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="1049.466" y1="1988.58" x2="1260.718" y2="539.417" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#ffea83"/><stop offset=".083" style="stop-color:#ffdd35"/><stop offset="1" style="stop-color:#ffa800"/></linearGradient><path d="M1446.9.5 752.5 136.6c-11.4 2.2-19.9 11.9-20.6 23.5l-42.7 721.4c-1 17 14.6 30.2 31.2 26.4l193.3-44.6c18.1-4.2 34.4 11.8 30.7 30L887 1174.4c-3.9 18.9 13.9 35.1 32.4 29.5l119.4-36.3c18.5-5.6 36.3 10.6 32.4 29.6L979.9 1639c-5.7 27.6 31 42.7 46.4 19l10.2-15.8L1602.4 513c9.5-18.9-6.9-40.5-27.6-36.5l-199 38.4c-18.7 3.6-34.6-13.8-29.3-32.1l129.9-450.3c5.2-18.2-10.8-35.7-29.5-32z" style="fill:url(#b)"/></svg>
</file>

<file path="frontend/README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"вОвремя"` (stress on the first 'о')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="frontend/src/App.tsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './pages/StressPracticePage';
import ParonymsPage from './pages/ParonymsPage';
import Navigation from './components/Navigation';
import { TrpcProvider } from './utils/trpc';

export default function App() {
  return (
    <TrpcProvider>
    <Router basename="/russian-stress-practice">
      <div className="flex flex-col min-h-screen">
        <Navigation />
        <div className="flex-grow">
          <Routes>
            <Route path="/" element={<StressPracticePage />} />
            <Route path="/paronyms" element={<ParonymsPage />} />
          </Routes>
        </div>
      </div>
    </Router>
    </TrpcProvider>
  );
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="frontend/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { GoogleOAuthProvider } from "@react-oauth/google";
import { env } from "./utils/env";
import "./index.css";

const rootElement = document.getElementById("root");
if (rootElement) {
  ReactDOM.createRoot(rootElement).render(
    <GoogleOAuthProvider clientId={env.VITE_GOOGLE_CLIENT_ID}>
      <React.StrictMode>
        <App />
      </React.StrictMode>
    </GoogleOAuthProvider>
  );
} else {
  console.error("Root element not found");
}
</file>

<file path="frontend/src/style.css">
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f4f4f4;
    margin: 0;
}

.container {
    background-color: #fff;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    max-width: 500px;
    width: 90%;
}

h1 {
    color: #333;
    margin-bottom: 25px;
}

.word-display {
    font-size: 2.5em; /* Make word prominent */
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    min-height: 60px; /* Ensure space even when loading */
    letter-spacing: 2px; /* Easier clicking on letters */
    user-select: none; /* Prevent text selection interfering */
}

.word-display span.vowel {
    cursor: pointer;
    padding: 0 2px; /* Add slight padding for easier clicking */
    border-radius: 3px;
    transition: background-color 0.2s ease;
}

.word-display span.vowel:hover {
    background-color: #e0e0e0;
}

/* Class added after an answer is given */
.word-display.answered span.vowel:hover {
    background-color: transparent; /* Disable hover effect after answer */
    cursor: default;
}

.feedback {
    min-height: 50px; /* Reserve space for feedback */
    margin-bottom: 20px;
    font-size: 1.1em;
    font-weight: bold;
}

.feedback.correct {
    color: #28a745; /* Green */
}

.feedback.incorrect {
    color: #dc3545; /* Red */
}

/* Style for highlighting the correct stress after feedback */
.word-display span.correct-stress {
    color: #28a745; /* Green */
    font-weight: bold;
    /* Optional: Add subtle background or underline */
    /* background-color: #d4edda; */
}

/* Style for highlighting the incorrect guess (optional) */
.word-display span.incorrect-guess {
    text-decoration: line-through;
    color: #dc3545; /* Red */
}

.controls button {
    padding: 10px 20px;
    font-size: 1em;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    transition: background-color 0.2s ease;
}

.controls button:hover {
    background-color: #0056b3;
}

.controls button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.stats {
    margin-top: 20px;
    color: #555;
    font-size: 0.9em;
}
</file>

<file path="frontend/src/style.d.ts">
declare module '*.css' {
  const content: Record<string, string>;
  export default content;
}
</file>

<file path="frontend/src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils/utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["тЕст", "примЕр"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("пример");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 },
      { word: "пример", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "тест1", nextReview: yesterday, retired: false },
      { word: "тест2", nextReview: today, retired: false },
      { word: "тест3", nextReview: tomorrow, retired: false },
      { word: "тест4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "тест1")).toBe(true);
    expect(result.some(w => w.word === "тест2")).toBe(true);
    expect(result.some(w => w.word === "тест3")).toBe(false);
    expect(result.some(w => w.word === "тест4")).toBe(false);
  });
});
</file>

<file path="frontend/src/words.js">
// Raw list with uppercase marking the stressed vowel
const rawWords = [
  "Августовский",
  "агЕнт",
  "алфавИт",
  "алкогОль",
  "аэропОрты",
  "аристокрАтия",
  "апострОф",
  "агронОмия",
  "асимметрИя",
  // Б
  "балОванный",
  "баловАть",
  "баловАться",
  "балУясь",
  "бАнты",
  "безУдержный",
  "бОроду",
  "бОчковый",
  "бухгАлтеров",
  "благоволИть",
  "блАговест",
  "бряцАть",
  "бУнгало",
  "брОня на билеты",
  "бронЯ у танка",
  "бюрокрАтия",
  "брюшкО",
  "бракОвщик",
  // В
  "вЕчеря",
  "вероисповЕдание",
  "взбешЕнный",
  "ворожеЯ",
  "вОзрастов",
  "втрИдешева",
  // Г
  "гЕнезис",
  "гЕрбовый",
  "граждАнство",
  "грУшевый",
  "граффИти",
  "гастронОмия",
  "грАблями",
  // Д
  "давнИшний",
  "дефИс",
  "деньгАх",
  "дешевИзна",
  "дозИровать",
  "долбЯщий",
  "докраснА",
  "донЕльзя",
  "дОнизу",
  "досУг",
  "дОсуха",
  "доЯр",
  "духовнИк",
  "домОвая книга",
  // Е
  "еретИк",
  // Ж
  "жалюзИ",
  "жилОсь",
  "жерлОз",
  // З
  "завсегдАтай",
  "завИдно",
  "зАгодя",
  "закУпорив",
  "зАтемно",
  "знАчимый",
  "зимОвщик",
  "зубчАтый",
  "знАмение",
  // И
  "ирИс",
  "Ирис",
  "искрА зажигания",
  "Иконопись",
  "Исподволь",
  "избалОванный",
  "издрЕвле",
  "Иксы с Иксом",
  "исключИт",
  "Исстари",
  "исчЕрпав",
  "исчЕрпать",
  // К
  "каталОг",
  "кАмбала",
  "крапИва",
  "кАшлянуть",
  "квартАл",
  "киломЕтр",
  "клАла",
  "кремЕнь",
  "кремнЯ",
  "крЕмы",
  "костюмирОванный",
  "кулинАрия",
  "коклЮш",
  "красИвее",
  "крАны",
  "корЫсть",
  "кровоточИть",
  "кровоточАщий",
  "кУхонный",
  "кладовАя",
  "опОшлят",
  "оптОвый",
  "освЕдомиться",
  "отзЫв",
  "откУпорил",
  "отрочество",
  "oполОснутый",
  "озвУчение",
  "одновремЕнно",
  "крАдучись",
  "куркУма",
  "кичИться",
  "кедрОвый",
  // Л
  "лЕкторов",
  "ловкА",
  "лососЕвый",
  "лыжнЯ",
  // М
  "мастерскИ",
  "мЕстностей",
  "мозаИчный",
  "мещанИн",
  "молЯщий",
  "мусоропровОд",
  "мытАрство",
  "мЕльком",
  // Н
  "наделИт",
  "надОлго",
  "намЕрение",
  "нарОст",
  "насорИт",
  "нЕдруг",
  "недУг",
  "насквОзь",
  "назвАный брат",
  "наговОр",
  "ненадОлго",
  "низведЕн",
  "нОвости",
  "новостЕй",
  "нОгтя",
  "нормировАть",
  // О
  "обеспЕчение",
  "ободрИть",
  "ободренА",
  "одолжИт",
  "озлОбить",
  "окружИт",
  "опломбировАть",
  // П
  "партЕр",
  "пАмятуя",
  "пЕрчит",
  "плЕсневеть",
  "плодоносИть",
  "пОручни",
  "послАла",
  "прИбыл",
  "придАное",
  "принУдить",
  "прИнятый",
  "принялсЯ",
  "прозорлИва",
  "прожОрлива",
  "подчАс",
  "тОтчас",
  "пЕтля",
  "пЕтелька",
  "пЕня",
  "простынЯ",
  "пУрпур",
  "платО",
  "прИкус",
  "пулОвер",
  "поутрУ",
  "пригУбить",
  "плешИна",
  // Р
  "ржавЕть",
  "расклЕшенный",
  // С
  "свЕкла",
  "сверлИт",
  "сверлИшь",
  "серА",
  "сЕры",
  "сЕтчатый",
  "сирОты",
  "слИвовый",
  "сОгнутый",
  "созЫв",
  "сорИт",
  "срЕдства",
  "срЕдствами",
  "стАтуя",
  "столЯр",
  "сосредотОчение",
  "скулА",
  "скобА",
  "страхОвщик",
  // Т
  "тЕплится",
  "тОрты",
  "тОтчас",
  "танцОвщица",
  "толИка",
  "тУфля",
  // У
  "убыстрИть",
  "углубИть",
  "украИнский",
  "укрепИт",
  "умЕрший",
  "усугубИт",
  "упрОчение",
  // Ф
  "фенОмен",
  "фОрзац",
  "фетИш",
  "факсИмиле",
  // Х
  "ходАтайствовать",
  "христианИн",
  "хозЯева",
  "хОленный",
  // Ц
  "цемЕнт",
  "цЕнтнер",
  "цепОчка",
  "цыгАн",
  // Ч
  "чЕлюстей",
  "чЕрпать",
  // Ш
  "шАрфы",
  "шофЕр",
  "шпрИцы",
  // Щ
  "щавЕль",
  "щемИт",
  "щЕлкать",
  "щепА",
  // Э
  "экспЕрт",
  "эпилОг"
];

export default rawWords;
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "jsx": "react",
    "allowJs": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "../shared/src/zod.ts"]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), "");
  const publicEnv = Object.entries(env).reduce((acc, [key, value]) => {
    if (key.startsWith('VITE_') || ["HOST_ENV", "NODE_ENV"].includes(key) ) {
      return {
        ...acc,
        [key]: value,
      }
    }
    return acc
  }, {})

  return {
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
      outDir: "dist",
      emptyOutDir: true,
      rollupOptions: {
        input: "./index.html",
        output: {
          entryFileNames: `assets/[name].[hash].js`,
          chunkFileNames: `assets/[name].[hash].js`,
          assetFileNames: `assets/[name].[hash].[ext]`
        }
      }
    },
    publicDir: "public",
    server: {
      open: true,
      port: +env.PORT,
    },
    preview: {
      port: +env.PORT,
    },
    define: {
      'process.env': publicEnv,
    },
  };
});
</file>

<file path="jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    passWithNoTests: true,
    verbose: true,
    prettierPath: null,
  }
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "frontend"
  - "backend"
  - "shared"
</file>

<file path="frontend/package.json">
{
  "name": "@russian-stress-practice/frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.2",
    "@react-oauth/google": "^0.12.1",
    "@russian-stress-practice/backend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@tanstack/react-query": "4.36.1",
    "@trpc/client": "^10.45.2",
    "@trpc/react-query": "^10.45.2",
    "@trpc/server": "^10.45.2",
    "classnames": "^2.5.1",
    "date-fns": "^4.1.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-react": "^7.37.5",
    "formik": "^2.4.6",
    "formik-validator-zod": "^2.2.0",
    "js-cookie": "^3.0.5",
    "ldrs": "^1.1.7",
    "lodash": "^4.17.21",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2",
    "superjson": "1.13.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/js-cookie": "^3.0.6",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

<file path=".gitignore">
node_modules
.env
</file>

<file path="package.json">
{
    "name": "russian-stress-practice",
    "version": "0.0.0",
    "private": "true",
    "dependencies": {
      "@tanstack/react-query": "4",
      "@trpc/client": "^10.45.2",
      "@trpc/next": "^10.45.2",
      "@trpc/react": "^9.27.4",
      "@trpc/server": "^10.45.2",
      "cors": "^2.8.5",
      "eslint": "^9.20.1",
      "eslint-plugin-node": "^11.1.0",
      "express": "^4.21.2",
      "react-dom": "^18.3.1",
      "react-router-dom": "^7.1.5",
      "w": "^1.1.0"
    },
    "pnpm": {
      "overrides": {
        "@tanstack/react-query": "4.36.1"
      }
    },
    "scripts": {
      "b": "pnpm --filter @russian-stress-practice/backend",
      "w": "pnpm --filter @russian-stress-practice/frontend",
      "sh": "pnpm --filter @russian-stress-practice/shared",
      "dev": "pnpm -r --parallel dev",
      "types": "pnpm -r --parallel types",
      "test": "pnpm -r test",
      "prepare": "husky && husky install"
    },
    "devDependencies": {
      "@eslint/eslintrc": "^3.3.1",
      "@types/express": "^5.0.0",
      "@types/jest": "^29.5.14",
      "@types/node": "^22.10.7",
      "@typescript-eslint/eslint-plugin": "^8.24.0",
      "@typescript-eslint/parser": "^8.24.0",
      "eslint-config-prettier": "^10.0.1",
      "eslint-config-react-app": "^7.0.1",
      "eslint-config-standard-with-typescript": "^43.0.1",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jest": "^28.11.0",
      "husky": "^8.0.0",
      "jest": "^29.7.0",
      "lint-staged": "^15.4.3",
      "node": "link:@types\\node",
      "rimraf": "^6.0.1",
      "ts-jest": "^29.3.1",
      "ts-patch": "^3.3.0",
      "typescript": "^5.7.3",
      "typescript-transform-paths": "^3.5.5"
    },
    "type": "module"
  }
</file>

</files>
