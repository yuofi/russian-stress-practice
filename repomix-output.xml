This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.lintstagedrc.yml
backend/.gitignore
backend/.lintstagedrc.yml
backend/eslint.config.mjs
backend/jest.config.cjs
backend/package.json
backend/src/data/paronyms.js
backend/src/data/words.js
backend/src/index.ts
backend/src/lib/ctx.ts
backend/src/lib/passport.ts
backend/src/lib/prisma.ts
backend/src/lib/trpc.ts
backend/src/prisma/migrations/20250427152613_initial/migration.sql
backend/src/prisma/migrations/20250507174003_added_new_practice_type_and_updated_word/migration.sql
backend/src/prisma/migrations/20250512144412_added_paronym_practice/migration.sql
backend/src/prisma/migrations/20250518144431_fixed_explanation/migration.sql
backend/src/prisma/migrations/20250518163901_added_personal_dictionary/migration.sql
backend/src/prisma/migrations/migration_lock.toml
backend/src/prisma/schema.prisma
backend/src/router/auth/GetAuth/index.ts
backend/src/router/auth/GetAuth/input.ts
backend/src/router/auth/GetMe/index.ts
backend/src/router/Dictionary/CheckPersonalItem/index.ts
backend/src/router/Dictionary/CheckPersonalItem/input.ts
backend/src/router/Dictionary/GetPersonalDictionary/index.ts
backend/src/router/Dictionary/GetPersonalDictionary/input.ts
backend/src/router/Dictionary/TogglePersonalParonym/index.ts
backend/src/router/Dictionary/TogglePersonalParonym/input.ts
backend/src/router/Dictionary/TogglePersonalWord/index.ts
backend/src/router/Dictionary/TogglePersonalWord/input.ts
backend/src/router/index.ts
backend/src/router/Practice/GetParonyms/index.ts
backend/src/router/Practice/GetPracticeWords/index.ts
backend/src/router/Practice/GetPracticeWords/input.ts
backend/src/router/Practice/GetUserStats/index.ts
backend/src/router/Practice/GetUserStats/input.ts
backend/src/router/Practice/RecordPractice/index.ts
backend/src/router/Practice/RecordPractice/input.ts
backend/src/routes/stats.ts
backend/src/scripts/importParonyms.ts
backend/src/scripts/presetDB.ts
backend/src/utils/deepMap.ts
backend/src/utils/env.ts
backend/src/utils/error.ts
backend/src/utils/logger.ts
backend/src/utils/models.ts
backend/src/utils/types.ts
backend/tsconfig.json
eslint.config.mjs
frontend/.envrc
frontend/.github/workflows/deploy.yml
frontend/index.html
frontend/package.json
frontend/postcss.config.js
frontend/public/index.js
frontend/public/vite.svg
frontend/README.md
frontend/src/App.tsx
frontend/src/components/Loader/index.tsx
frontend/src/components/Login/index.tsx
frontend/src/components/Navigation.tsx
frontend/src/components/PersonalDictionaryButton/index.tsx
frontend/src/components/PracticeStats/index.tsx
frontend/src/components/svg/svgNative.tsx
frontend/src/index.css
frontend/src/main.tsx
frontend/src/pages/LogOutPage/index.tsx
frontend/src/pages/ParonymsPage/index.tsx
frontend/src/pages/ParonymsPage/ParonymsInterface.tsx
frontend/src/pages/PersonalDictionaryPage/index.tsx
frontend/src/pages/StressPracticePage/index.tsx
frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx
frontend/src/types/nodes.ts
frontend/src/types/practice.ts
frontend/src/types/types.d.ts
frontend/src/utils.test.js
frontend/src/utils/ctx.tsx
frontend/src/utils/env.ts
frontend/src/utils/googleAuth.ts
frontend/src/utils/pumpGetRoute.ts
frontend/src/utils/routes.ts
frontend/src/utils/statsContext.tsx
frontend/src/utils/trpc.tsx
frontend/src/utils/utils.ts
frontend/tailwind.config.js
frontend/tsconfig.json
frontend/vite.config.ts
jest.config.cjs
package.json
pnpm-workspace.yaml
repomix-output-bold.xml
rupractice.session.sql
russian-practice dev.session.sql
shared/.lintstagedrc.yml
shared/jest.config.js
shared/package.json
shared/src/getKeysAsArray.ts
shared/src/omit.ts
shared/src/pick.ts
shared/src/tryCatch.ts
shared/src/zod.ts
shared/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/src/data/paronyms.js">
// Data structure for paronyms
const paronymData = [
    {
        group: ["АДРЕСАТ", "АДРЕСАНТ"],
        paronyms: [
            { word: "АДРЕСАТ", explanation: "получатель" },
            { word: "АДРЕСАНТ", explanation: "отправитель" }
        ]
    },
    {
        group: ["АРТИСТИЧНЫЙ", "АРТИСТИЧЕСКАЯ"],
        paronyms: [
            { word: "АРТИСТИЧНЫЙ", explanation: "человек, исполнение" },
            { word: "АРТИСТИЧЕСКАЯ", explanation: "внешность, среда, подъезд, карьера, способности, артистическая натура" }
        ]
    },
    {
        group: ["АКАДЕМИЧЕСКИЙ", "АКАДЕМИЧНЫЙ"],
        paronyms: [
            { word: "АКАДЕМИЧЕСКИЙ", explanation: "оркестр" },
            { word: "АКАДЕМИЧНЫЙ", explanation: "подход" }
        ]
    },
    {
        group: ["АВТОРИТАРНЫЙ", "АВТОРИТЕТНЫЙ"],
        paronyms: [
            { word: "АВТОРИТАРНЫЙ", explanation: "основанный на диктатуре" },
            { word: "АВТОРИТЕТНЫЙ", explanation: "уважаемый" }
        ]
    },
    {
        group: ["БЕДНАЯ", "БЕДСТВЕННОЕ"],
        paronyms: [
            { word: "БЕДНАЯ", explanation: "девушка. Жил в БЕДНОСТИ." },
            { word: "БЕДСТВЕННОЕ", explanation: "положение" }
        ]
    },
    {
        group: ["БЕЗОТВЕТНАЯ", "БЕЗОТВЕТСТВЕННОЕ"],
        paronyms: [
            { word: "БЕЗОТВЕТНАЯ", explanation: "любовь" },
            { word: "БЕЗОТВЕТСТВЕННОЕ", explanation: "отношение, человек" }
        ]
    },
    {
        group: ["БУДНИЙ", "БУДНИЧНЫЙ"],
        paronyms: [
            { word: "БУДНИЙ", explanation: "день" },
            { word: "БУДНИЧНЫЙ", explanation: "(обыденный): дело, событие, заботы, платье, костюм; а также: однообразный, беспросветный, серый, безрадостный: голос, атмосфера, ответ, жизнь" }
        ]
    },
    // Add more paronym groups here...
    {
        group: ["БОЛОТИСТАЯ", "БОЛОТНАЯ"],
        paronyms: [
            { word: "БОЛОТИСТАЯ", explanation: "почва" },
            { word: "БОЛОТНАЯ", explanation: "птица, грязь" }
        ]
    },
    {
        group: ["БЛАГОДАРНЫЙ", "БЛАГОДАРСТВЕННЫЙ"],
        paronyms: [
            { word: "БЛАГОДАРНЫЙ", explanation: "человек, занятие" },
            { word: "БЛАГОДАРСТВЕННЫЙ", explanation: "молебен, письмо" }
        ]
    },
    {
        group: ["BЛАГОТВОРИТЕЛЬНЫЙ", "БЛАГОТВОРНОЕ"],
        paronyms: [
            { word: "БЛАГОТВОРИТЕЛЬНЫЙ", explanation: "фонд" },
            { word: "БЛАГОТВОРНОЕ", explanation: "влияние" }
        ]
    }
];

export default paronymData;
</file>

<file path="backend/src/prisma/migrations/20250512144412_added_paronym_practice/migration.sql">
-- CreateTable
CREATE TABLE "ParonymPair" (
    "id" SERIAL NOT NULL,
    "description" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "ParonymPair_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ParonymPractice" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "paronymPairId" INTEGER NOT NULL,
    "selectedWordId" INTEGER NOT NULL,
    "correctWordId" INTEGER NOT NULL,
    "correct" BOOLEAN NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ParonymPractice_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_ParonymWords" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL,

    CONSTRAINT "_ParonymWords_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE INDEX "ParonymPractice_userId_idx" ON "ParonymPractice"("userId");

-- CreateIndex
CREATE INDEX "ParonymPractice_paronymPairId_idx" ON "ParonymPractice"("paronymPairId");

-- CreateIndex
CREATE INDEX "_ParonymWords_B_index" ON "_ParonymWords"("B");

-- AddForeignKey
ALTER TABLE "ParonymPractice" ADD CONSTRAINT "ParonymPractice_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ParonymPractice" ADD CONSTRAINT "ParonymPractice_paronymPairId_fkey" FOREIGN KEY ("paronymPairId") REFERENCES "ParonymPair"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ParonymWords" ADD CONSTRAINT "_ParonymWords_A_fkey" FOREIGN KEY ("A") REFERENCES "ParonymPair"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_ParonymWords" ADD CONSTRAINT "_ParonymWords_B_fkey" FOREIGN KEY ("B") REFERENCES "Word"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="backend/src/prisma/migrations/20250518144431_fixed_explanation/migration.sql">
-- AlterTable
ALTER TABLE "Word" ADD COLUMN     "description" TEXT;
</file>

<file path="backend/src/prisma/migrations/20250518163901_added_personal_dictionary/migration.sql">
-- CreateTable
CREATE TABLE "PersonalWord" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "wordId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "PersonalWord_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "PersonalParonym" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "paronymPairId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "PersonalParonym_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "PersonalWord_userId_idx" ON "PersonalWord"("userId");

-- CreateIndex
CREATE INDEX "PersonalWord_wordId_idx" ON "PersonalWord"("wordId");

-- CreateIndex
CREATE UNIQUE INDEX "PersonalWord_userId_wordId_key" ON "PersonalWord"("userId", "wordId");

-- CreateIndex
CREATE INDEX "PersonalParonym_userId_idx" ON "PersonalParonym"("userId");

-- CreateIndex
CREATE INDEX "PersonalParonym_paronymPairId_idx" ON "PersonalParonym"("paronymPairId");

-- CreateIndex
CREATE UNIQUE INDEX "PersonalParonym_userId_paronymPairId_key" ON "PersonalParonym"("userId", "paronymPairId");

-- AddForeignKey
ALTER TABLE "PersonalWord" ADD CONSTRAINT "PersonalWord_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PersonalWord" ADD CONSTRAINT "PersonalWord_wordId_fkey" FOREIGN KEY ("wordId") REFERENCES "Word"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PersonalParonym" ADD CONSTRAINT "PersonalParonym_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "PersonalParonym" ADD CONSTRAINT "PersonalParonym_paronymPairId_fkey" FOREIGN KEY ("paronymPairId") REFERENCES "ParonymPair"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zCheckPersonalItem } from "./input";

export const CheckPersonalItemTrpcRoute = trpcLoggedProcedure
  .input(zCheckPersonalItem)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type, id } = input;

    if (type === "STRESS") {
      // Проверяем, есть ли слово в личном словарике
      const personalWord = await ctx.prisma.personalWord.findUnique({
        where: {
          userId_wordId: {
            userId: ctx.me.id,
            wordId: id,
          },
        },
      });

      return { isPersonal: !!personalWord };
    } else if (type === "PARONYM") {
      // Проверяем, есть ли пара паронимов в личном словарике
      const personalParonym = await ctx.prisma.personalParonym.findUnique({
        where: {
          userId_paronymPairId: {
            userId: ctx.me.id,
            paronymPairId: id,
          },
        },
      });

      return { isPersonal: !!personalParonym };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Неподдерживаемый тип",
    });
  });
</file>

<file path="backend/src/router/Dictionary/CheckPersonalItem/input.ts">
import { z } from "zod";

export const zCheckPersonalItem = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  id: z.number(),
});
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPersonalDictionary } from "./input";

export const GetPersonalDictionaryTrpcRoute = trpcLoggedProcedure
  .input(zGetPersonalDictionary)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type } = input;

    if (type === "STRESS") {
      // Получаем слова с ударениями из личного словарика
      const personalWords = await ctx.prisma.personalWord.findMany({
        where: {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
        },
        include: {
          word: {
            include: {
              practices: {
                where: {
                  userId: ctx.me.id,
                },
                orderBy: {
                  createdAt: "desc",
                },
              },
            },
          },
        },
      });

      return {
        words: personalWords.map((entry) => ({
          id: entry.word.id,
          word: entry.word.word,
          accentIdx: entry.word.stress,
          history: entry.word.practices.map((practice) => ({
            correct: practice.correct,
            date: practice.createdAt,
          })),
        })),
      };
    } else if (type === "PARONYM") {
      // Получаем пары паронимов из личного словарика
      const personalParonyms = await ctx.prisma.personalParonym.findMany({
        where: {
          userId: ctx.me.id,
        },
        include: {
          paronymPair: {
            include: {
              words: true,
            },
          },
        },
      });

      return {
        paronyms: personalParonyms.map((entry) => ({
          id: entry.paronymPair.id,
          group: entry.paronymPair.words.map((word) => word.word),
          paronyms: entry.paronymPair.words.map((word) => ({
            id: word.id,
            word: word.word,
            explanation: word.description || "",
          })),
        })),
      };
    }

    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Неподдерживаемый тип словарика",
    });
  });
</file>

<file path="backend/src/router/Dictionary/GetPersonalDictionary/input.ts">
import { z } from "zod";

export const zGetPersonalDictionary = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalParonym } from "./input";

export const TogglePersonalParonymTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalParonym)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { paronymPairId, isPersonal } = input;

    // Проверяем существование пары паронимов
    const paronymPair = await ctx.prisma.paronymPair.findUnique({
      where: { id: paronymPairId },
    });

    if (!paronymPair) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "Пара паронимов не найдена",
      });
    }

    // Проверяем, есть ли уже эта пара в личном словарике
    const existingEntry = await ctx.prisma.personalParonym.findUnique({
      where: {
        userId_paronymPairId: {
          userId: ctx.me.id,
          paronymPairId: paronymPairId,
        },
      },
    });

    if (isPersonal) {
      // Если нужно добавить в словарик и записи еще нет
      if (!existingEntry) {
        await ctx.prisma.personalParonym.create({
          data: {
            userId: ctx.me.id,
            paronymPairId: paronymPairId,
          },
        });
      }
    } else {
      // Если нужно удалить из словарика и запись существует
      if (existingEntry) {
        await ctx.prisma.personalParonym.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, paronymPair };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalParonym/input.ts">
import { z } from "zod";

export const zTogglePersonalParonym = z.object({
  paronymPairId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/index.ts">
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zTogglePersonalWord } from "./input";

export const TogglePersonalWordTrpcRoute = trpcLoggedProcedure
  .input(zTogglePersonalWord)
  .mutation(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { wordId, isPersonal } = input;

    // Проверяем существование слова
    const word = await ctx.prisma.word.findUnique({
      where: { id: wordId },
    });

    if (!word) {
      throw new TRPCError({
        code: "NOT_FOUND",
        message: "Слово не найдено",
      });
    }

    // Проверяем, есть ли уже это слово в личном словарике
    const existingEntry = await ctx.prisma.personalWord.findUnique({
      where: {
        userId_wordId: {
          userId: ctx.me.id,
          wordId: wordId,
        },
      },
    });

    if (isPersonal) {
      // Если нужно добавить в словарик и записи еще нет
      if (!existingEntry) {
        await ctx.prisma.personalWord.create({
          data: {
            userId: ctx.me.id,
            wordId: wordId,
          },
        });
      }
    } else {
      // Если нужно удалить из словарика и запись существует
      if (existingEntry) {
        await ctx.prisma.personalWord.delete({
          where: {
            id: existingEntry.id,
          },
        });
      }
    }

    return { success: true, word };
  });
</file>

<file path="backend/src/router/Dictionary/TogglePersonalWord/input.ts">
import { z } from "zod";

export const zTogglePersonalWord = z.object({
  wordId: z.number(),
  isPersonal: z.boolean(),
});
</file>

<file path="backend/src/router/Practice/GetParonyms/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";

export const GetParonymsTrpcRoute = trpcLoggedProcedure
  .query(async ({ ctx }) => {
    // Получаем все пары паронимов из базы данных
    const paronymPairs = await ctx.prisma.paronymPair.findMany({
      include: {
        words: true,
      },
    });

    // Преобразуем данные в формат, удобный для фронтенда
    const paronyms = paronymPairs.map(pair => {
      return {
        id: pair.id,
        group: pair.words.map(word => word.word),
        paronyms: pair.words.map(word => ({
          id: word.id,
          word: word.word,
          explanation: word.description || "", // Используем индивидуальное описание слова
        })),
      };
    });

    return { paronyms };
  });
</file>

<file path="backend/src/router/Practice/RecordPractice/input.ts">
import {z} from "zod"

export const zRecordPractice = z.object({
  // Общие поля
  correct: z.boolean(),
  
  wordId: z.number().optional(),
  
  paronymPairId: z.number().optional(),
  selectedWordId: z.number().optional(),
  correctWordId: z.number().optional(),
  
  type: z.enum(["STRESS", "PARONYM"]).optional(),
});
</file>

<file path="backend/src/routes/stats.ts">
export const UserStatsParams = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  period: z.number().optional(), // период в днях (7, 30, etc.)
});

export const GetUserStats = publicProcedure
  .input(UserStatsParams)
  .query(async ({ input, ctx }) => {
    const { user } = ctx;
    
    if (!user) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }
    
    const { type, period } = input;
    const periodDate = period ? subDays(new Date(), period) : undefined;
    
    try {
      // Общая статистика в зависимости от типа практики
      if (type === "STRESS") {
        // Получаем статистику по ударениям
        const practiceQuery = {
          userId: user.id,
          word: {
            type: "STRESS",
          },
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.practice.count({
          where: practiceQuery,
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.practice.count({
          where: {
            userId: user.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.practice.count({
          where: {
            userId: user.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getDailyStats(ctx.prisma, user.id, "STRESS", period);
        
        // Проблемные слова
        const problemWords = await getProblemWords(ctx.prisma, user.id, "STRESS");
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords,
        };
      } 
      else if (type === "PARONYM") {
        // Получаем статистику по паронимам
        const practiceQuery = {
          userId: user.id,
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.paronymPractice.count({
          where: practiceQuery,
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            ...practiceQuery,
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: user.id,
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: user.id,
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getParonymDailyStats(ctx.prisma, user.id, period);
        
        // Проблемные пары паронимов
        const problemParonyms = await getProblemParonyms(ctx.prisma, user.id);
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords: problemParonyms, // Используем тот же формат для совместимости
        };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Неподдерживаемый тип практики",
      });
    } catch (error) {
      console.error("Error fetching user stats:", error);
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Не удалось получить статистику",
      });
    }
  });

// Вспомогательная функция для получения ежедневной статистики по паронимам
async function getParonymDailyStats(prisma: PrismaClient, userId: number, period?: number) {
  const periodDays = period || 30; // По умолчанию 30 дней
  const startDate = subDays(new Date(), periodDays);
  
  // Получаем все попытки за указанный период
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // Группируем по дням
  const dailyMap = new Map();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date);
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Вспомогательная функция для получения проблемных пар паронимов
async function getProblemParonyms(prisma: PrismaClient, userId: number) {
  // Получаем статистику по парам паронимов
  const paronymStats = await prisma.paronymPractice.groupBy({
    by: ['paronymPairId'],
    where: {
      userId,
    },
    _count: {
      _all: true,
    },
    _sum: {
      correct: true,
    },
    having: {
      _count: {
        _all: {
          gte: 3, // Минимум 3 попытки
        },
      },
    },
    orderBy: {
      _sum: {
        correct: 'asc', // Сортируем по возрастанию правильных ответов
      },
    },
    take: 5, // Топ-5 проблемных пар
  });
  
  // Получаем информацию о парах паронимов
  const problemPairs = await Promise.all(
    paronymStats.map(async (stat) => {
      const pair = await prisma.paronymPair.findUnique({
        where: { id: stat.paronymPairId },
        include: {
          words: true,
        },
      });
      
      if (!pair) return null;
      
      // Формируем строку с паронимами через "/"
      const wordString = pair.words.map(w => w.word).join(' / ');
      
      return {
        id: pair.id,
        word: wordString,
        total: stat._count._all,
        correct: stat._sum.correct || 0,
      };
    })
  );
  
  return problemPairs.filter(Boolean);
}
</file>

<file path="backend/src/scripts/importParonyms.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import paronymData from "../data/paronyms";
import { logger } from "../utils/logger";

async function importParonyms() {
  const prisma = new PrismaClient();
  logger.info("presetDB", "starting paronyms import...");
  
  try {
    // Для каждой группы паронимов
    for (const group of paronymData) {
      logger.info("presetDB", `Обрабатываем группу: ${group.group.join(", ")}`);
      
      // Создаем или находим слова для каждого паронима
      const wordRecords = [];
      
      for (const paronym of group.paronyms) {
        // Ищем слово в базе данных
        let word = await prisma.word.findFirst({
          where: {
            word: paronym.word,
          },
        });
        
        // Если слово не найдено, создаем его
        if (!word) {
          word = await prisma.word.create({
            data: {
              word: paronym.word,
              stress: 0, // Для паронимов позиция ударения не важна
              type: PracticeType.PARONYM,
              description: paronym.explanation // Сохраняем индивидуальное описание
            },
          });
          logger.info("presetDB", `Created new word: ${word.word} with explanation: ${paronym.explanation}`);
        } else {
          // Обновляем тип слова и описание, если оно уже существует
          word = await prisma.word.update({
            where: { id: word.id },
            data: { 
              type: PracticeType.PARONYM,
              description: paronym.explanation
            }
          });
        }
        
        wordRecords.push(word);
      }
      
      // Создаем пару паронимов и связываем с словами
      const paronymPair = await prisma.paronymPair.create({
        data: {
          words: {
            connect: wordRecords.map(word => ({ id: word.id }))
          }
        }
      });
      
      logger.info("presetDB", `Created paronym pair with ID: ${paronymPair.id}`);
    }
    
    logger.info("presetDB", "Paronyms import completed successfully");
  } catch(error) {
    logger.error("presetDB", "Error during database preset", error as any);
  } finally {
    await prisma.$disconnect();
  }
}

// Вызываем функцию импорта
if (require.main === module) {
  importParonyms()
    .then(() => {
      logger.info("presetDB", "Import script finished");
      process.exit(0);
    })
    .catch(error => {
      logger.error("presetDB", "Import script failed", error);
      process.exit(1);
    });
}

export default importParonyms;
</file>

<file path="frontend/src/components/PersonalDictionaryButton/index.tsx">
import React, { useState, useEffect } from 'react';
import { BookmarkIcon as BookmarkOutlineIcon } from '@heroicons/react/24/outline';
import { BookmarkIcon as BookmarkSolidIcon } from '@heroicons/react/24/solid';
import trpc from '../../utils/trpc';

interface PersonalDictionaryButtonProps {
  type: 'STRESS' | 'PARONYM';
  id: number | undefined;
  initialIsPersonal?: boolean;
  onToggle?: (isPersonal: boolean) => void;
}

const PersonalDictionaryButton: React.FC<PersonalDictionaryButtonProps> = ({
  type,
  id,
  initialIsPersonal,
  onToggle,
}) => {
  const [isPersonal, setIsPersonal] = useState(initialIsPersonal || false);
  
  // Проверяем, находится ли элемент в личном словарике
  const { data: checkResult } = trpc.CheckPersonalItem.useQuery(
    { type, id: id! },
    { enabled: id !== undefined && initialIsPersonal === undefined }
  );
  
  // Обновляем состояние, когда получаем результат проверки
  useEffect(() => {
    if (checkResult) {
      setIsPersonal(checkResult.isPersonal);
    }
  }, [checkResult]);
  
  // Мутации для добавления/удаления из личного словарика
  const togglePersonalWord = trpc.TogglePersonalWord.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // Инвалидируем кеш для обновления списка личного словарика
      trpc.useContext().GetPersonalDictionary.invalidate();
      trpc.useContext().CheckPersonalItem.invalidate();
    },
  });

  const togglePersonalParonym = trpc.TogglePersonalParonym.useMutation({
    onSuccess: () => {
      setIsPersonal(!isPersonal);
      if (onToggle) {
        onToggle(!isPersonal);
      }
      // Инвалидируем кеш для обновления списка личного словарика
      trpc.useContext().GetPersonalDictionary.invalidate();
      trpc.useContext().CheckPersonalItem.invalidate();
    },
  });

  const handleToggle = () => {
    if (!id) return;
    if (type === 'STRESS') {
      togglePersonalWord.mutate({
        wordId: id,
        isPersonal: !isPersonal,
      });
    } else if (type === 'PARONYM') {
      togglePersonalParonym.mutate({
        paronymPairId: id,
        isPersonal: !isPersonal,
      });
    }
  };

  return (
    <button
      onClick={handleToggle}
      className="p-2 rounded-full hover:bg-slate-100 transition-colors"
      title={isPersonal ? "Удалить из личного словарика" : "Добавить в личный словарик"}
    >
      {isPersonal ? (
        <BookmarkSolidIcon className="h-5 w-5 text-indigo-600" />
      ) : (
        <BookmarkOutlineIcon className="h-5 w-5 text-slate-500" />
      )}
    </button>
  );
};

export default PersonalDictionaryButton;
</file>

<file path="frontend/src/components/PracticeStats/index.tsx">
import React from 'react';
import { Loader } from '../Loader';
import { PracticeType } from '../../types/practice';
import trpc from '../../utils/trpc';

// Типы для пропсов компонента
interface PracticeStatsProps {
  type: "STRESS" | "PARONYM";
  period?: number;
  onPeriodChange?: (period?: number) => void;
}

// Типы для данных статистики
interface StatsData {
  summary: {
    totalAttempts: number;
    correctAttempts: number;
    correctRate: number;
    recentStats?: {
      totalAttempts: number;
      correctAttempts: number;
      correctRate: number;
    };
  };
  dailyStats: Array<{
    date: string;
    total: number;
    correct: number;
    rate: number;
  }>;
  problemWords: Array<{
    id: number;
    word: string;
    total: number;
    correct: number;
  }>;
}

// Хук для получения статистики
export const useUserStats = (params: { type: "STRESS" | "PARONYM"; period?: number }) => {
  const { data, isLoading, error, refetch } = trpc.GetUserStats.useQuery(params, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
    onError: (error) => {
      console.error("Failed to fetch user stats:", error);
    }
  });

  return {
    stats: data as StatsData | undefined,
    isLoading,
    error,
    refetch
  };
};

const PracticeStats: React.FC<PracticeStatsProps> = ({ type, period, onPeriodChange }) => {
  // Получаем статистику с помощью хука
  const { stats, isLoading } = useUserStats({ type, period });

  // Функция для изменения периода
  const handlePeriodChange = (newPeriod?: number) => {
    if (onPeriodChange) {
      onPeriodChange(newPeriod);
    }
  };

  return (
    <div>
      {/* Заголовок статистики */}
      <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">
        Статистика
      </h2>

      {/* Селектор периода */}
      <div className="mb-4 flex space-x-2">
        <button
          onClick={() => handlePeriodChange(undefined)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === undefined ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          Все время
        </button>
        <button
          onClick={() => handlePeriodChange(7)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 7 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          7 дней
        </button>
        <button
          onClick={() => handlePeriodChange(30)}
          className={`px-3 py-1 rounded-md text-sm ${
            period === 30 ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-700'
          }`}
        >
          30 дней
        </button>
      </div>

      {isLoading ? (
        // Показываем индикатор загрузки, пока данные загружаются
        <div className="flex justify-center py-8">
          <Loader />
        </div>
      ) : stats ? (
        // Показываем статистику, когда данные загружены
        <>
          {/* Основная статистика */}
          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Всего попыток</p>
                <p className="text-xl font-semibold text-slate-800">
                  {stats.summary.totalAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Правильных</p>
                <p className="text-xl font-semibold text-emerald-600">
                  {stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Неправильных</p>
                <p className="text-xl font-semibold text-amber-600">
                  {stats.summary.totalAttempts - stats.summary.correctAttempts}
                </p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Точность</p>
                <p className="text-xl font-semibold text-indigo-600">
                  {Math.round(stats.summary.correctRate * 100)}%
                </p>
              </div>
            </div>
          </div>
          
          {/* Прогресс-бар точности */}
          <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
            <h3 className="text-md font-semibold mb-2 text-slate-700">Точность ответов</h3>
            <div className="w-full bg-slate-100 rounded-full h-4">
              <div 
                className="bg-emerald-500 h-4 rounded-full" 
                style={{ width: `${Math.round(stats.summary.correctRate * 100)}%` }}
              ></div>
            </div>
            <p className="text-right text-sm text-slate-600 mt-1">
              {Math.round(stats.summary.correctRate * 100)}%
            </p>
          </div>
          
          {/* Статистика за последние 7 дней (если доступна) */}
          {stats.summary.recentStats && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">Последние 7 дней</h3>
              <div className="grid grid-cols-2 gap-3">
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">Попыток</p>
                  <p className="text-lg font-semibold text-slate-800">
                    {stats.summary.recentStats.totalAttempts}
                  </p>
                </div>
                <div className="bg-slate-50 p-2 rounded-lg">
                  <p className="text-sm text-slate-500 mb-1">Правильных</p>
                  <p className="text-lg font-semibold text-emerald-600">
                    {stats.summary.recentStats.correctAttempts}
                  </p>
                </div>
              </div>
              <div className="mt-2 w-full bg-slate-100 rounded-full h-3">
                <div 
                  className="bg-indigo-500 h-3 rounded-full" 
                  style={{ 
                    width: `${stats.summary.recentStats.totalAttempts > 0 
                      ? Math.round((stats.summary.recentStats.correctAttempts / stats.summary.recentStats.totalAttempts) * 100) 
                      : 0}%` 
                  }}
                ></div>
              </div>
            </div>
          )}
          
          {/* Ежедневная статистика (последние 7 дней) */}
          {stats.dailyStats.length > 0 && (
            <div className="mb-6 bg-white p-4 rounded-xl shadow-sm">
              <h3 className="text-md font-semibold mb-3 text-slate-700">Ежедневная статистика</h3>
              <div className="space-y-2">
                {stats.dailyStats
                  .slice(0, 7) // Показываем только последние 7 дней
                  .map((day, i) => (
                    <div key={i} className="flex items-center">
                      <span className="text-xs text-slate-500 w-20">{new Date(day.date).toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit' })}</span>
                      <div className="flex-1 ml-2">
                        <div className="w-full bg-slate-100 rounded-full h-3">
                          <div 
                            className="bg-emerald-500 h-3 rounded-full" 
                            style={{ width: `${Math.round(day.rate * 100)}%` }}
                          ></div>
                        </div>
                      </div>
                      <span className="text-xs font-medium ml-2 w-12 text-right">
                        {day.correct}/{day.total}
                      </span>
                    </div>
                  ))}
              </div>
            </div>
          )}
          
          {/* Проблемные слова */}
          {stats.problemWords.length > 0 && (
            <div className="mb-6">
              <h3 className="text-md font-semibold mb-2 text-slate-700">Сложные слова</h3>
              <ul className="bg-white rounded-xl shadow-sm divide-y divide-slate-100">
                {stats.problemWords.map((word, i) => (
                  <li key={i} className="py-2 px-3 flex justify-between items-center">
                    <span className="text-slate-700">{word.word}</span>
                    <div className="flex items-center">
                      <span className="text-xs text-slate-500 mr-2">
                        {word.correct}/{word.total}
                      </span>
                      <span className="px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-700">
                        {Math.round((word.correct / word.total) * 100)}%
                      </span>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </>
      ) : (
        // Если данных нет
        <div className="text-center py-8 text-slate-500">
          Нет данных о практике
        </div>
      )}
    </div>
  );
};

export default PracticeStats;
</file>

<file path="frontend/src/pages/ParonymsPage/ParonymsInterface.tsx">
import React, { useState, useEffect } from "react";
import { shuffleArray } from "../../utils/utils";
import { Paronym, ParonymGroup } from "../../types/nodes";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface ParonymsInterfaceProps {
  paronymGroups: ParonymGroup[];
  isLoading: boolean;
  statsPeriod: number | undefined;
  setStatsPeriod: (period?: number) => void;
  recordPractice: (paronymId: number, selectedWord: string, correct: boolean) => void;
  isPersonalDictionary: boolean;
}

export default function ParonymsInterface({
  paronymGroups,
  isLoading,
  statsPeriod,
  setStatsPeriod,
  recordPractice,
  isPersonalDictionary,
}: ParonymsInterfaceProps) {
  // Получаем состояние видимости статистики
  const { isStatsVisible } = useStats();

  // State for the current paronym group being practiced
  const [currentParonymGroup, setCurrentParonymGroup] = useState<ParonymGroup | null>(null);

  // State to track the user's selected paronym
  const [selectedParonym, setSelectedParonym] = useState<string | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to track if all paronyms are completed
  const [allCompleted, setAllCompleted] = useState(false);

  // Load a random paronym group
  const loadRandomParonymGroup = () => {
    if (paronymGroups.length === 0) {
      setCurrentParonymGroup(null);
      setAllCompleted(true);
      return;
    }

    // Get a random paronym group
    const randomIndex = Math.floor(Math.random() * paronymGroups.length);
    const randomGroup = paronymGroups[randomIndex];

    // Shuffle the paronyms in the group
    const shuffledParonyms = shuffleArray([...randomGroup.paronyms]);
    
    setCurrentParonymGroup({
      ...randomGroup,
      paronyms: shuffledParonyms,
    });
    
    setSelectedParonym(null);
    setFeedback("");
  };

  // Handle user selecting a paronym
  const handleSelect = (paronym: Paronym) => {
    // Only allow selection if no feedback is currently shown
    if (feedback) return;

    // Guard against no current paronym group
    if (!currentParonymGroup) return;

    setSelectedParonym(paronym.word);

    // Check if the selected paronym is correct
    const isCorrect = paronym.isCorrect;

    // Record practice attempt to backend
    if (currentParonymGroup.id) {
      recordPractice(currentParonymGroup.id, paronym.word, isCorrect);
    }

    if (isCorrect) {
      setFeedback("✅ Правильно! " + paronym.explanation);
    } else {
      // Find the correct paronym for the explanation
      const correctParonym = currentParonymGroup.paronyms.find(p => p.isCorrect);
      setFeedback(`❌ Неправильно. Правильный ответ: ${correctParonym?.word}. ${correctParonym?.explanation}`);
    }
  };

  // Load initial paronym group
  useEffect(() => {
    if (paronymGroups.length > 0 && !currentParonymGroup) {
      loadRandomParonymGroup();
    } else if (paronymGroups.length === 0 && !isLoading) {
      setAllCompleted(true);
    }
  }, [paronymGroups, isLoading]);

  // Если на мобильном устройстве открыта статистика, не показываем основной контент
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for stats - только для десктопов */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="PARONYM"
          period={statsPeriod}
          onPeriodChange={setStatsPeriod}
        />
        
        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            Вы практикуете паронимы из личного словаря
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            Тренажер паронимов
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : allCompleted ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {paronymGroups.length === 0 
                  ? (isPersonalDictionary 
                    ? "В вашем словаре нет паронимов для практики" 
                    : "Список паронимов для практики пуст")
                  : "Поздравляем!"}
              </h2>
              {paronymGroups.length === 0 ? (
                <p className="text-slate-600 mb-6">
                  {isPersonalDictionary
                    ? "Добавьте паронимы в личный словарь во время обычной практики"
                    : "Пожалуйста, обратитесь к администратору для добавления паронимов"}
                </p>
              ) : (
                <>
                  <p className="text-slate-600 mb-6">
                    Вы прошли все доступные паронимы. Хотите продолжить практику?
                  </p>
                  <button
                    onClick={loadRandomParonymGroup}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Практиковаться еще
                  </button>
                </>
              )}
            </div>
          ) : currentParonymGroup ? (
            <>
              <div className="bg-white p-4 sm:p-6 md:p-8 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* Кнопка для личного словаря (только в обычном режиме) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.PARONYM}
                      id={currentParonymGroup.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  {currentParonymGroup.context}
                </h2>
                
                {/* Варианты паронимов */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                  {currentParonymGroup.paronyms.map((paronym) => (
                    <button
                      key={paronym.word}
                      onClick={() => handleSelect(paronym)}
                      disabled={!!feedback}
                      className={`
                        p-4 rounded-xl text-lg font-medium transition-all duration-200
                        ${!feedback ? 'hover:bg-indigo-50 hover:border-indigo-200 active:bg-indigo-100' : ''}
                        ${selectedParonym === paronym.word && paronym.isCorrect ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        ${selectedParonym === paronym.word && !paronym.isCorrect ? 'bg-rose-100 border-rose-300 text-rose-800' : ''}
                        ${!selectedParonym ? 'bg-white border-slate-200 text-slate-700' : ''}
                        ${feedback && paronym.isCorrect && selectedParonym !== paronym.word ? 'bg-emerald-100 border-emerald-300 text-emerald-800' : ''}
                        border-2
                      `}
                    >
                      {paronym.word}
                    </button>
                  ))}
                </div>
                
                {/* Сообщение с обратной связью */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 p-4 rounded-xl mx-auto
                    ${feedback.includes('Правильно') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg mb-2">
                      {feedback.split('.')[0]}
                    </p>
                    <p className="text-sm sm:text-base">
                      {feedback.split('.').slice(1).join('.')}
                    </p>
                  </div>
                )}
                
                {/* Кнопка для перехода к следующему паронимы */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadRandomParonymGroup}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Следующий пароним
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/PersonalDictionaryPage/index.tsx">
import React, { useState } from 'react';
import { Tab } from '@headlessui/react';
import trpc from '../../utils/trpc';
import { Loader } from '../../components/Loader';
import PersonalDictionaryButton from '../../components/PersonalDictionaryButton';
import { PracticeType, PersonalDictionaryWord, PersonalDictionaryParonym } from '../../types/practice';
import { useMe } from '../../utils/ctx';
import { Link } from 'react-router-dom';
import { GetStressPractice, GetParonymsPractice } from '../../utils/routes';

const PersonalDictionaryPage: React.FC = () => {
  const [selectedTab, setSelectedTab] = useState(0);
  const me = useMe();
  
  // Получаем слова с ударениями из личного словарика
  const { 
    data: stressData, 
    isLoading: isLoadingStress,
    refetch: refetchStressData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.STRESS },
    { 
      enabled: selectedTab === 0 && !!me,
      onError: (error) => {
        console.error("Ошибка при загрузке слов:", error);
      }
    }
  );
  
  // Получаем паронимы из личного словарика
  const { 
    data: paronymsData, 
    isLoading: isLoadingParonyms,
    refetch: refetchParonymsData
  } = trpc.GetPersonalDictionary.useQuery(
    { type: PracticeType.PARONYM },
    { 
      enabled: selectedTab === 1 && !!me,
      onError: (error) => {
        console.error("Ошибка при загрузке паронимов:", error);
      }
    }
  );
  
  // Обработчик удаления элемента из словаря
  const handleToggle = (isPersonal: boolean) => {
    if (selectedTab === 0) {
      refetchStressData();
    } else {
      refetchParonymsData();
    }
  };
  
  // Функция для отображения слова с ударением
  const renderWordWithStress = (word: string, accentIdx: number) => {
    return (
      <>
        {word.substring(0, accentIdx)}
        <span className="text-indigo-600 font-bold">
          {word.charAt(accentIdx)}
        </span>
        {word.substring(accentIdx + 1)}
      </>
    );
  };
  
  // Если пользователь не авторизован
  if (!me) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
        <div className="max-w-4xl mx-auto text-center py-12 bg-white rounded-xl shadow-sm">
          <h1 className="text-3xl font-bold mb-6 text-slate-800">
            Личный словарик
          </h1>
          <p className="text-slate-500 mb-6">
            Для доступа к личному словарику необходимо авторизоваться.
          </p>
          <button
            className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
            onClick={() => window.location.href = "/auth/login"}
          >
            Войти
          </button>
        </div>
      </div>
    );
  }
  
  // Функция для создания URL с параметром source=dictionary
  const getPracticeUrlWithDictionarySource = (baseUrl: string) => {
    return `${baseUrl}?source=dictionary`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-6">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-3xl font-bold mb-6 text-slate-800">
          Личный словарик
        </h1>
        
        <Tab.Group onChange={setSelectedTab}>
          <Tab.List className="flex space-x-1 rounded-xl bg-white p-1 mb-6 shadow-sm">
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Ударения
            </Tab>
            <Tab
              className={({ selected }) =>
                `w-full rounded-lg py-2.5 text-sm font-medium leading-5 
                ${
                  selected
                    ? 'bg-indigo-100 text-indigo-700'
                    : 'text-slate-700 hover:bg-slate-100'
                }`
              }
            >
              Паронимы
            </Tab>
          </Tab.List>
          
          <Tab.Panels>
            {/* Панель с ударениями */}
            <Tab.Panel>
              {isLoadingStress ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : stressData?.words && stressData.words.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetStressPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Практиковать слова из словаря
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {stressData.words.map((word) => (
                        <li key={word.id} className="p-4 flex justify-between items-center">
                          <div>
                            <p className="text-lg font-medium text-slate-800">
                              {renderWordWithStress(word.word, word.accentIdx)}
                            </p>
                            {word.history.length > 0 && (
                              <p className="text-xs text-slate-500 mt-1">
                                Последняя практика: {new Date(word.history[0].date).toLocaleDateString()}
                                {word.history[0].correct ? ' ✓' : ' ✗'}
                              </p>
                            )}
                          </div>
                          <PersonalDictionaryButton
                            type={PracticeType.STRESS}
                            id={word.id}
                            initialIsPersonal={true}
                            onToggle={handleToggle}
                          />
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    В вашем личном словарике пока нет слов с ударениями.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    Добавьте слова из практики, нажав на иконку закладки.
                  </p>
                  <Link 
                    to={GetStressPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Перейти к практике ударений
                  </Link>
                </div>
              )}
            </Tab.Panel>
            
            {/* Панель с паронимами */}
            <Tab.Panel>
              {isLoadingParonyms ? (
                <div className="flex justify-center py-12">
                  <Loader />
                </div>
              ) : paronymsData?.paronyms && paronymsData.paronyms.length > 0 ? (
                <div>
                  <div className="mb-4 flex justify-end">
                    <Link 
                      to={getPracticeUrlWithDictionarySource(GetParonymsPractice())}
                      className="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Практиковать паронимы из словаря
                    </Link>
                  </div>
                  <div className="bg-white rounded-xl shadow-sm overflow-hidden">
                    <ul className="divide-y divide-slate-100">
                      {paronymsData.paronyms.map((pair) => (
                        <li key={pair.id} className="p-4">
                          <div className="flex justify-between items-start">
                            <div>
                              <p className="text-lg font-medium text-slate-800">
                                {pair.group.join(' / ')}
                              </p>
                            </div>
                            <PersonalDictionaryButton
                              type={PracticeType.PARONYM}
                              id={pair.id}
                              initialIsPersonal={true}
                              onToggle={handleToggle}
                            />
                          </div>
                          <div className="mt-3 grid grid-cols-1 md:grid-cols-2 gap-3">
                            {pair.paronyms.map((paronym) => (
                              <div key={paronym.id} className="bg-slate-50 p-3 rounded-lg">
                                <p className="font-medium text-indigo-700">{paronym.word}</p>
                                <p className="text-sm text-slate-600 mt-1">{paronym.explanation}</p>
                              </div>
                            ))}
                          </div>
                        </li>
                      ))}
                    </ul>
                  </div>
                </div>
              ) : (
                <div className="text-center py-12 bg-white rounded-xl shadow-sm">
                  <p className="text-slate-500">
                    В вашем личном словарике пока нет паронимов.
                  </p>
                  <p className="text-slate-500 mt-2 mb-6">
                    Добавьте паронимы из практики, нажав на иконку закладки.
                  </p>
                  <Link 
                    to={GetParonymsPractice()}
                    className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                  >
                    Перейти к практике паронимов
                  </Link>
                </div>
              )}
            </Tab.Panel>
          </Tab.Panels>
        </Tab.Group>
      </div>
    </div>
  );
};

export default PersonalDictionaryPage;
</file>

<file path="frontend/src/pages/StressPracticePage/StressPracticeInterface.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
} from "../../utils/utils";
import { Loader } from "../../components/Loader";
import PracticeStats from "../../components/PracticeStats";
import { PracticeType } from "../../types/practice";
import PersonalDictionaryButton from "../../components/PersonalDictionaryButton";
import { useStats } from "../../utils/statsContext";

interface StressPracticeInterfaceProps {
  words: Word[];
  isLoading: boolean;
  statsParams: UserStatsParams;
  changeStatsPeriod: (period?: number) => void;
  recordPractice: (wordId: number, correct: boolean) => void;
  isPersonalDictionary: boolean;
  stats?: UserStats;
  isStatsLoading: boolean;
  vowels: string[];
  today: Date;
  setWords?: (updater: (prevWords: Word[]) => Word[]) => void;
}

export default function StressPracticeInterface({
  words,
  isLoading,
  statsParams,
  changeStatsPeriod,
  recordPractice,
  isPersonalDictionary,
  stats,
  isStatsLoading,
  vowels,
  today,
  setWords,
}: StressPracticeInterfaceProps) {
  // Получаем состояние видимости статистики
  const { isStatsVisible } = useStats();

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState<Word | null>(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState<number | null>(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState("");

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);
  const [isInitialWordLoadPending, setIsInitialWordLoadPending] =
    useState(false);

  // Добавим новое состояние для отслеживания пустого списка слов
  const [emptyWordsList, setEmptyWordsList] = useState(false);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter((w) => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split("") : [];

  // Load the next word to practice
  const loadNextWord = (): void => {
    const due = getDueWords(words, today);
    console.log(
      "Loading next word. Due words:",
      due.length,
      "Total words:",
      words.length
    );

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else if (words.length > 0) {
      // Если есть слова, но нет доступных для практики сегодня
      setCurrentWord(null);
      setAllLearned(true);
    } else {
      // Если список слов пуст
      setCurrentWord(null);
      setAllLearned(false);
    }

    setSelected(null);
    setFeedback("");
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx: number): void => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // Проверяем ответ
    const isCorrect = idx === currentWord.accentIdx;

    // Record practice attempt to backend
    if (currentWord.id) {
      recordPractice(currentWord.id, isCorrect);
    }

    if (isCorrect) {
      // Правильный ответ - показываем успех
      setFeedback("✅ Правильно!");

      // Update the word's learning metadata locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak += 1;

            // If streak reaches 4, retire the word
            if (word.correctStreak >= 4) {
              word.retired = true;
            } else {
              // Otherwise, schedule next review based on streak
              word.nextReview = computeNextReview(word.correctStreak, today);
            }
          });
        });
      }
    } else {
      // Неправильный ответ
      setFeedback("❌ Неправильно. Правильный ответ выделен.");

      // Reset the word's streak locally
      if (setWords) {
        setWords((prevWords: Word[]) => {
          return updateWord(prevWords, currentWord, (word: Word) => {
            word.correctStreak = 0;
            word.wrongCount += 1;
            word.nextReview = addDays(today, 1); // Review again tomorrow
          });
        });
      }
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = (): void => {
    setShowAllWords((prev) => !prev);
  };

  // Load initial word when words are loaded
  useEffect(() => {
    if (words.length > 0 && !currentWord) {
      loadNextWord();
      setEmptyWordsList(false);
    } else if (words.length === 0 && !isLoading) {
      // Если список слов пуст, устанавливаем соответствующий флаг
      setEmptyWordsList(true);
      setAllLearned(false);
    }
  }, [words, isLoading]);

  // Если на мобильном устройстве открыта статистика, не показываем основной контент
  if (isStatsVisible && window.innerWidth < 768) {
    return null;
  }

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats - только для десктопов */}
      <div className="hidden md:block w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <PracticeStats
          type="STRESS"
          period={statsParams.period}
          onPeriodChange={changeStatsPeriod}
        />

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-4 px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? "Показать изучаемые" : "Показать все слова"}
        </button>

        {/* Source indicator */}
        {isPersonalDictionary && (
          <div className="mt-4 p-3 bg-yellow-50 text-yellow-800 rounded-xl text-sm">
            Вы практикуете слова из личного словаря
          </div>
        )}
      </div>

      {/* Main content area */}
      <div className="w-full md:w-3/4 p-4 md:p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-2xl md:text-3xl font-bold mb-6 md:mb-8 text-center text-slate-800">
            Тренажер ударений
          </h1>

          {isLoading ? (
            <div className="flex justify-center py-12">
              <Loader />
            </div>
          ) : emptyWordsList ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                {isPersonalDictionary
                  ? "В вашем словаре нет слов для практики"
                  : "Список слов для практики пуст"}
              </h2>
              <p className="text-slate-600 mb-6">
                {isPersonalDictionary
                  ? "Добавьте слова в личный словарь во время обычной практики"
                  : "Пожалуйста, обратитесь к администратору для добавления слов"}
              </p>
            </div>
          ) : allLearned ? (
            <div className="bg-white p-6 md:p-8 rounded-xl shadow-sm text-center">
              <h2 className="text-xl md:text-2xl font-bold mb-4 text-slate-800">
                Поздравляем!
              </h2>
              <p className="text-slate-600 mb-6">
                Вы повторили все слова на сегодня. Возвращайтесь завтра для
                новой практики!
              </p>
              <button
                onClick={() => setAllLearned(false)}
                className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
              >
                Практиковаться еще
              </button>
            </div>
          ) : currentWord ? (
            <>
              <div className="bg-white p-4 sm:p-6 md:p-8 rounded-2xl shadow-lg mb-4 sm:mb-6 relative">
                {/* Кнопка для личного словаря (только в обычном режиме) */}
                {!isPersonalDictionary && (
                  <div className="absolute top-3 right-3 sm:top-4 sm:right-4">
                    <PersonalDictionaryButton
                      type={PracticeType.STRESS}
                      id={currentWord.id}
                    />
                  </div>
                )}

                <h2 className="text-xl sm:text-2xl font-bold text-center mb-4 sm:mb-6">
                  Выберите ударный слог
                </h2>
                
                {/* Адаптивный интерфейс для отображения слова */}
                <div className="w-full overflow-x-auto mb-6 sm:mb-8 py-2">
                  <div className="flex justify-center items-center space-x-1 sm:space-x-2 text-3xl sm:text-4xl md:text-5xl min-w-min mx-auto">
                    {letters.map((letter, idx) => {
                      const isVowel = vowels.includes(letter.toLowerCase());
                      const isCorrect = idx === currentWord?.accentIdx;
                      const isSelected = selected === idx;
                      const showCorrect = feedback && isCorrect;

                      return (
                        <span
                          key={idx}
                          onClick={() => handleSelect(idx)}
                          className={`
                            relative cursor-pointer px-1 sm:px-2 py-1 rounded-lg transition-all duration-200
                            ${isVowel ? 'hover:bg-slate-100 hover:transform hover:scale-110 active:bg-slate-200 active:scale-105' : 'cursor-default'}
                            ${isSelected && isCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                            ${isSelected && !isCorrect ? 'bg-rose-500 text-white' : ''}
                            ${showCorrect && !isSelected ? 'bg-emerald-500 text-white transform scale-110' : ''}
                          `}
                        >
                          {letter}
                          {isVowel && (
                            <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                          )}
                        </span>
                      );
                    })}
                  </div>
                </div>
                
                {/* Сообщение с обратной связью */}
                {feedback && (
                  <div className={`mt-4 sm:mt-6 text-center py-2 sm:py-3 px-3 sm:px-4 rounded-xl mx-auto max-w-md
                    ${feedback.includes('Правильно') 
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' 
                      : 'bg-rose-50 text-rose-700 border border-rose-200'}`}
                  >
                    <p className="text-base sm:text-lg flex items-center justify-center">
                      {feedback.includes('Правильно') ? (
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 sm:h-5 sm:w-5 mr-1 sm:mr-2 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                        </svg>
                      ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 sm:h-5 sm:w-5 mr-1 sm:mr-2 text-rose-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      )}
                      {feedback}
                    </p>
                  </div>
                )}
                
                {/* Кнопка для перехода к следующему слову */}
                {feedback && (
                  <div className="mt-6 text-center">
                    <button
                      onClick={loadNextWord}
                      className="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors"
                    >
                      Следующее слово
                    </button>
                  </div>
                )}
              </div>
            </>
          ) : null}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/types/practice.ts">
export enum PracticeType {
  STRESS = 'STRESS',
  PARONYM = 'PARONYM'
}

// Типы для личного словаря
export interface PersonalDictionaryWord {
  id: number;
  word: string;
  accentIdx: number;
  history: {
    correct: boolean;
    date: string;
  }[];
}

export interface PersonalDictionaryParonym {
  id: number;
  group: string[];
  paronyms: {
    id: number;
    word: string;
    explanation: string;
  }[];
}

export interface PersonalDictionaryResponse {
  words?: PersonalDictionaryWord[];
  paronyms?: PersonalDictionaryParonym[];
}
</file>

<file path="frontend/src/utils/statsContext.tsx">
import React, { createContext, useContext, useState, ReactNode } from 'react';

interface StatsContextType {
  isStatsVisible: boolean;
  toggleStats: () => void;
}

const StatsContext = createContext<StatsContextType | undefined>(undefined);

export function StatsProvider({ children }: { children: ReactNode }) {
  const [isStatsVisible, setIsStatsVisible] = useState(false);

  const toggleStats = () => {
    setIsStatsVisible(prev => !prev);
  };

  return (
    <StatsContext.Provider value={{ isStatsVisible, toggleStats }}>
      {children}
    </StatsContext.Provider>
  );
}

export function useStats() {
  const context = useContext(StatsContext);
  if (context === undefined) {
    throw new Error('useStats must be used within a StatsProvider');
  }
  return context;
}
</file>

<file path="repomix-output-bold.xml">
analyse the styles of repomix-output-bold.xml - it contains the design on StressPracticePage and ParonymPracticePage then make the styles of my oproject simillar


This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.envrc
.github/workflows/deploy.yml
index.html
package.json
postcss.config.js
public/index.js
public/phonetics.txt
public/vite.svg
README.md
src/App.jsx
src/components/Navigation.jsx
src/index.css
src/main.jsx
src/main.ts
src/paronyms.js
src/ParonymsPage.jsx
src/StressPracticePage.jsx
src/style.css
src/style.d.ts
src/utils.js
src/utils.test.js
src/words.js
tailwind.config.js
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".envrc">
use flake
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>

<file path="public/phonetics.txt">
аэропОрты
бАнты
бОроду
бухгАлтеров
вероисповЕдание
водопровОд
газопровОд
граждАнство
дефИс
дешевИзна
диспансЕр
договорЁнность
докумЕнт
досУг
еретИк
жалюзИ
знАчимость
Иксы
каталОг
квартАл
киломЕтр
кОнусов
корЫсть
крАны
кремЕнь; кремнЯ
лЕкторов
лОктя
лыжнЯ
мЕстностей
намЕрение
нарОст
нЕдруг
недУг
некролОг
нЕнависть
нефтепровОд
новостЕй
нОгтя
Отзыв
отзЫв
Отрочество
партЕр
портфЕль
пОручни
придАное
призЫв
свЁкла
сирОты
созЫв
сосредотОчение
срЕдства
стАтуя
столЯр
тамОжня
тОрты
тУфля
цемЕнт
цЕнтнер
цепОчка
шАрфы
шофЁр
экспЕрт
вернА
знАчимый
красИвее; красИвейший
кУхонный
ловкА
мозаИчный
оптОвый
прозорлИвый; прозорлИва
слИвовый
бралА
бралАсь
взялА
взялАсь
влилАсь
ворвалАсь
воспринЯть; воспринялА
воссоздалА
вручИт
гналА
гналАсь
добралА
добралАсь
дождалАсь
дозвонИтся
дозИровать
ждалА
жилОсь
закУпорить
занЯть
заперлА
запломбировАть
защемИт
звалА
звонИт
кАшлянуть
клАла
клЕить
крАлась
кровоточИть
лгалА
лилА
лилАсь
навралА
наделИт
надорвалАсь
назвалАсь
накренИтся
налилА
нарвалА
начАть
обзвонИт
облегчИть; облегчИт
облилАсь
обнялАсь
обогналА
ободралА
ободрИть; ободрИт
ободрИться; ободрИтся
обострИть
одолжИть; одолжИт
озлОбить
оклЕить
окружИт
опОшлить
освЕдомиться; освЕдомится
отбылА
отдалА
откУпорить
отозвалА
отозвалАсь
перезвонИт
перелилА
плодоносИть
пломбировАть
повторИт
позвалА
позвонИть
полилА
положИть
понЯть; понялА
послАла
прибЫть; прИбыл, прибылА, прИбыли
принЯть; прИнял, принялА, прИняли
рвалА
сверлИт
снялА
совралА
создалА
сорвалА
сорИт
убралА
углубИть
укрепИт
чЕрпать
щемИт
щЁлкать
довезЁнный
зАгнутый
зАнятый; занятА
зАпертый
заселЁнный; заселенА
кормЯщий
кровоточАщий
нажИвший
налИвший
нанЯвшийся
начАвший
нАчатый
низведЁнный
облегчЁнный
ободрЁнный
обострЁнный
отключЁнный
повторЁнный
поделЁнный
понЯвший
прИнятый; принятА
приручЁнный
прожИвший
снятА
сОгнутый
углублЁнный
закУпорив
начАв
начАвшись
отдАв
поднЯв
понЯв
прибЫв
создАв
вОвремя
дОверху
донЕльзя
дОнизу
дОсуха
зАсветло
зАтемно
красИвее
надОлго
ненадОлго
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="src/paronyms.js">
// Data structure for paronyms
const paronymData = [
    {
        group: ["АДРЕСАТ", "АДРЕСАНТ"],
        paronyms: [
            { word: "АДРЕСАТ", explanation: "получатель" },
            { word: "АДРЕСАНТ", explanation: "отправитель" }
        ]
    },
    {
        group: ["АРТИСТИЧНЫЙ", "АРТИСТИЧЕСКАЯ"],
        paronyms: [
            { word: "АРТИСТИЧНЫЙ", explanation: "человек, исполнение" },
            { word: "АРТИСТИЧЕСКАЯ", explanation: "внешность, среда, подъезд, карьера, способности, артистическая натура" }
        ]
    },
    {
        group: ["АКАДЕМИЧЕСКИЙ", "АКАДЕМИЧНЫЙ"],
        paronyms: [
            { word: "АКАДЕМИЧЕСКИЙ", explanation: "оркестр" },
            { word: "АКАДЕМИЧНЫЙ", explanation: "подход" }
        ]
    },
    {
        group: ["АВТОРИТАРНЫЙ", "АВТОРИТЕТНЫЙ"],
        paronyms: [
            { word: "АВТОРИТАРНЫЙ", explanation: "основанный на диктатуре" },
            { word: "АВТОРИТЕТНЫЙ", explanation: "уважаемый" }
        ]
    },
    {
        group: ["БЕДНАЯ", "БЕДСТВЕННОЕ"],
        paronyms: [
            { word: "БЕДНАЯ", explanation: "девушка. Жил в БЕДНОСТИ." },
            { word: "БЕДСТВЕННОЕ", explanation: "положение" }
        ]
    },
    {
        group: ["БЕЗОТВЕТНАЯ", "БЕЗОТВЕТСТВЕННОЕ"],
        paronyms: [
            { word: "БЕЗОТВЕТНАЯ", explanation: "любовь" },
            { word: "БЕЗОТВЕТСТВЕННОЕ", explanation: "отношение, человек" }
        ]
    },
    {
        group: ["БУДНИЙ", "БУДНИЧНЫЙ"],
        paronyms: [
            { word: "БУДНИЙ", explanation: "день" },
            { word: "БУДНИЧНЫЙ", explanation: "(обыденный): дело, событие, заботы, платье, костюм; а также: однообразный, беспросветный, серый, безрадостный: голос, атмосфера, ответ, жизнь" }
        ]
    },
    // Add more paronym groups here...
    {
        group: ["БОЛОТИСТАЯ", "БОЛОТНАЯ"],
        paronyms: [
            { word: "БОЛОТИСТАЯ", explanation: "почва" },
            { word: "БОЛОТНАЯ", explanation: "птица, грязь" }
        ]
    },
    {
        group: ["БЛАГОДАРНЫЙ", "БЛАГОДАРСТВЕННЫЙ"],
        paronyms: [
            { word: "БЛАГОДАРНЫЙ", explanation: "человек, занятие" },
            { word: "БЛАГОДАРСТВЕННЫЙ", explanation: "молебен, письмо" }
        ]
    },
    {
        group: ["BЛАГОТВОРИТЕЛЬНЫЙ", "БЛАГОТВОРНОЕ"],
        paronyms: [
            { word: "БЛАГОТВОРИТЕЛЬНЫЙ", explanation: "фонд" },
            { word: "БЛАГОТВОРНОЕ", explanation: "влияние" }
        ]
    }
];

export default paronymData;
</file>

<file path="src/style.css">
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background-color: #f4f4f4;
    margin: 0;
}

.container {
    background-color: #fff;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    text-align: center;
    max-width: 500px;
    width: 90%;
}

h1 {
    color: #333;
    margin-bottom: 25px;
}

.word-display {
    font-size: 2.5em; /* Make word prominent */
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    min-height: 60px; /* Ensure space even when loading */
    letter-spacing: 2px; /* Easier clicking on letters */
    user-select: none; /* Prevent text selection interfering */
}

.word-display span.vowel {
    cursor: pointer;
    padding: 0 2px; /* Add slight padding for easier clicking */
    border-radius: 3px;
    transition: background-color 0.2s ease;
}

.word-display span.vowel:hover {
    background-color: #e0e0e0;
}

/* Class added after an answer is given */
.word-display.answered span.vowel:hover {
    background-color: transparent; /* Disable hover effect after answer */
    cursor: default;
}

.feedback {
    min-height: 50px; /* Reserve space for feedback */
    margin-bottom: 20px;
    font-size: 1.1em;
    font-weight: bold;
}

.feedback.correct {
    color: #28a745; /* Green */
}

.feedback.incorrect {
    color: #dc3545; /* Red */
}

/* Style for highlighting the correct stress after feedback */
.word-display span.correct-stress {
    color: #28a745; /* Green */
    font-weight: bold;
    /* Optional: Add subtle background or underline */
    /* background-color: #d4edda; */
}

/* Style for highlighting the incorrect guess (optional) */
.word-display span.incorrect-guess {
    text-decoration: line-through;
    color: #dc3545; /* Red */
}

.controls button {
    padding: 10px 20px;
    font-size: 1em;
    cursor: pointer;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    transition: background-color 0.2s ease;
}

.controls button:hover {
    background-color: #0056b3;
}

.controls button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.stats {
    margin-top: 20px;
    color: #555;
    font-size: 0.9em;
}
</file>

<file path="src/style.d.ts">
declare module '*.css' {
  const content: Record<string, string>;
  export default content;
}
</file>

<file path="src/utils.js">
// Date utility functions
export function addDays(d, n) {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak, today = new Date()) {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords) {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: null,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words, targetWord, updateFn) {
  return words.map(word => {
    if (word.word === targetWord.word) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review
export function getDueWords(words, today = new Date()) {
  return words
    .filter(w => !w.retired && w.nextReview <= today)
    .sort(() => Math.random() - 0.5); // Simple shuffle
}
</file>

<file path="src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["тЕст", "примЕр"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("пример");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 },
      { word: "пример", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "тест1", nextReview: yesterday, retired: false },
      { word: "тест2", nextReview: today, retired: false },
      { word: "тест3", nextReview: tomorrow, retired: false },
      { word: "тест4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "тест1")).toBe(true);
    expect(result.some(w => w.word === "тест2")).toBe(true);
    expect(result.some(w => w.word === "тест3")).toBe(false);
    expect(result.some(w => w.word === "тест4")).toBe(false);
  });
});
</file>

<file path="src/words.js">
// Raw list with uppercase marking the stressed vowel
const rawWords = [
  "Августовский",
  "агЕнт",
  "алфавИт",
  "алкогОль",
  "аэропОрты",
  "аристокрАтия",
  "апострОф",
  "агронОмия",
  "асимметрИя",
  // Б
  "балОванный",
  "баловАть",
  "баловАться",
  "балУясь",
  "бАнты",
  "безУдержный",
  "бОроду",
  "бОчковый",
  "бухгАлтеров",
  "благоволИть",
  "блАговест",
  "бряцАть",
  "бУнгало",
  "брОня на билеты",
  "бронЯ у танка",
  "бюрокрАтия",
  "брюшкО",
  "бракОвщик",
  // В
  "вЕчеря",
  "вероисповЕдание",
  "взбешЕнный",
  "ворожеЯ",
  "вОзрастов",
  "втрИдешева",
  // Г
  "гЕнезис",
  "гЕрбовый",
  "граждАнство",
  "грУшевый",
  "граффИти",
  "гастронОмия",
  "грАблями",
  // Д
  "давнИшний",
  "дефИс",
  "деньгАх",
  "дешевИзна",
  "дозИровать",
  "долбЯщий",
  "докраснА",
  "донЕльзя",
  "дОнизу",
  "досУг",
  "дОсуха",
  "доЯр",
  "духовнИк",
  "домОвая книга",
  // Е
  "еретИк",
  // Ж
  "жалюзИ",
  "жилОсь",
  "жерлОз",
  // З
  "завсегдАтай",
  "завИдно",
  "зАгодя",
  "закУпорив",
  "зАтемно",
  "знАчимый",
  "зимОвщик",
  "зубчАтый",
  "знАмение",
  // И
  "ирИс",
  "Ирис",
  "искрА зажигания",
  "Иконопись",
  "Исподволь",
  "избалОванный",
  "издрЕвле",
  "Иксы с Иксом",
  "исключИт",
  "Исстари",
  "исчЕрпав",
  "исчЕрпать",
  // К
  "каталОг",
  "кАмбала",
  "крапИва",
  "кАшлянуть",
  "квартАл",
  "киломЕтр",
  "клАла",
  "кремЕнь",
  "кремнЯ",
  "крЕмы",
  "костюмирОванный",
  "кулинАрия",
  "коклЮш",
  "красИвее",
  "крАны",
  "корЫсть",
  "кровоточИть",
  "кровоточАщий",
  "кУхонный",
  "кладовАя",
  "опОшлят",
  "оптОвый",
  "освЕдомиться",
  "отзЫв",
  "откУпорил",
  "отрочество",
  "oполОснутый",
  "озвУчение",
  "одновремЕнно",
  "крАдучись",
  "куркУма",
  "кичИться",
  "кедрОвый",
  // Л
  "лЕкторов",
  "ловкА",
  "лососЕвый",
  "лыжнЯ",
  // М
  "мастерскИ",
  "мЕстностей",
  "мозаИчный",
  "мещанИн",
  "молЯщий",
  "мусоропровОд",
  "мытАрство",
  "мЕльком",
  // Н
  "наделИт",
  "надОлго",
  "намЕрение",
  "нарОст",
  "насорИт",
  "нЕдруг",
  "недУг",
  "насквОзь",
  "назвАный брат",
  "наговОр",
  "ненадОлго",
  "низведЕн",
  "нОвости",
  "новостЕй",
  "нОгтя",
  "нормировАть",
  // О
  "обеспЕчение",
  "ободрИть",
  "ободренА",
  "одолжИт",
  "озлОбить",
  "окружИт",
  "опломбировАть",
  // П
  "партЕр",
  "пАмятуя",
  "пЕрчит",
  "плЕсневеть",
  "плодоносИть",
  "пОручни",
  "послАла",
  "прИбыл",
  "придАное",
  "принУдить",
  "прИнятый",
  "принялсЯ",
  "прозорлИва",
  "прожОрлива",
  "подчАс",
  "тОтчас",
  "пЕтля",
  "пЕтелька",
  "пЕня",
  "простынЯ",
  "пУрпур",
  "платО",
  "прИкус",
  "пулОвер",
  "поутрУ",
  "пригУбить",
  "плешИна",
  // Р
  "ржавЕть",
  "расклЕшенный",
  // С
  "свЕкла",
  "сверлИт",
  "сверлИшь",
  "серА",
  "сЕры",
  "сЕтчатый",
  "сирОты",
  "слИвовый",
  "сОгнутый",
  "созЫв",
  "сорИт",
  "срЕдства",
  "срЕдствами",
  "стАтуя",
  "столЯр",
  "сосредотОчение",
  "скулА",
  "скобА",
  "страхОвщик",
  // Т
  "тЕплится",
  "тОрты",
  "тОтчас",
  "танцОвщица",
  "толИка",
  "тУфля",
  // У
  "убыстрИть",
  "углубИть",
  "украИнский",
  "укрепИт",
  "умЕрший",
  "усугубИт",
  "упрОчение",
  // Ф
  "фенОмен",
  "фОрзац",
  "фетИш",
  "факсИмиле",
  // Х
  "ходАтайствовать",
  "христианИн",
  "хозЯева",
  "хОленный",
  // Ц
  "цемЕнт",
  "цЕнтнер",
  "цепОчка",
  "цыгАн",
  // Ч
  "чЕлюстей",
  "чЕрпать",
  // Ш
  "шАрфы",
  "шофЕр",
  "шпрИцы",
  // Щ
  "щавЕль",
  "щемИт",
  "щЕлкать",
  "щепА",
  // Э
  "экспЕрт",
  "эпилОг"
];

export default rawWords;
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="src/components/Navigation.jsx">
import React from 'react';
import { Link, useLocation } from 'react-router-dom';

export default function Navigation() {
  const location = useLocation();

  return (
    <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10">
      <div className="container mx-auto flex justify-between items-center">
        <div className="text-xl font-bold text-indigo-600 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
          </svg>
          Русский язык: Тренажеры
        </div>
        <div className="flex space-x-2">
          <Link
            to="/"
            className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
              location.pathname === '/'
                ? 'bg-indigo-100 text-indigo-700 shadow-sm'
                : 'text-slate-600 hover:bg-slate-100 hover:text-indigo-600'
            }`}
          >
            <div className="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
              </svg>
              Ударения
            </div>
          </Link>
          <Link
            to="/paronyms"
            className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
              location.pathname === '/paronyms'
                ? 'bg-indigo-100 text-indigo-700 shadow-sm'
                : 'text-slate-600 hover:bg-slate-100 hover:text-indigo-600'
            }`}
          >
            <div className="flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
              </svg>
              Паронимы
            </div>
          </Link>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="src/ParonymsPage.jsx">
import React, { useState, useEffect } from 'react';
import paronymData from './paronyms';

export default function ParonymsPage() {
    const [currentParonymGroup, setCurrentParonymGroup] = useState(null);
    const [correctAnswer, setCorrectAnswer] = useState(null);
    const [score, setScore] = useState(0);
    const [showFeedback, setShowFeedback] = useState(false);
    const [isCorrect, setIsCorrect] = useState(false);
    const [selectedAnswer, setSelectedAnswer] = useState(null);
    const [showExplanation, setShowExplanation] = useState(false);

    // Function to shuffle an array
    const shuffleArray = (array) => {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; // Swap elements
        }
        return newArray;
    };

    // Function to display a new question
    const displayNewQuestion = () => {
        // Clear previous feedback and explanations
        setShowFeedback(false);
        setShowExplanation(false);
        setSelectedAnswer(null);

        // Select a random paronym group
        const randomGroup = paronymData[Math.floor(Math.random() * paronymData.length)];
        setCurrentParonymGroup(randomGroup);

        // Select a random paronym from the group as the correct answer
        const correctParonymObject = randomGroup.paronyms[Math.floor(Math.random() * randomGroup.paronyms.length)];
        setCorrectAnswer(correctParonymObject.word);
    };

    // Function to handle user's answer
    const handleAnswer = (answer) => {
        setSelectedAnswer(answer);
        setShowFeedback(true);

        if (answer === correctAnswer) {
            setIsCorrect(true);
            setScore(score + 1);
        } else {
            setIsCorrect(false);
        }

        setShowExplanation(true);
    };

    // Initialize with a question on component mount
    useEffect(() => {
        displayNewQuestion();
    }, []);

    if (!currentParonymGroup) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
                <div className="bg-white p-8 rounded-2xl shadow-lg max-w-md w-full mx-auto text-center">
                    <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500 mx-auto mb-4"></div>
                    <p className="text-slate-700 text-lg">Загрузка паронимов...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex justify-center items-center p-6">
            <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg max-w-2xl w-full mx-auto my-auto overflow-hidden">
                <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">Тренажер паронимов</h1>

                <div className="flex flex-col items-center">
                    {currentParonymGroup && correctAnswer && (
                        <>
                            <div className="bg-slate-50 p-5 rounded-xl mb-6 w-full">
                                <p className="text-lg text-center text-slate-700 leading-relaxed">
                                    Выберите подходящее слово, соответствующее значению:
                                    <span className="font-medium block mt-2 text-indigo-700">
                                        "{currentParonymGroup.paronyms.find(p => p.word === correctAnswer)?.explanation}"
                                    </span>
                                </p>
                            </div>

                            <div className="flex flex-wrap justify-center gap-3 mb-6 w-full">
                                {shuffleArray(currentParonymGroup.paronyms).map((paronym) => (
                                    <button
                                        key={paronym.word}
                                        onClick={() => handleAnswer(paronym.word)}
                                        disabled={showFeedback}
                                        className={`
                                            py-3 px-6 rounded-xl font-medium text-lg transition-all duration-200 break-words max-w-full
                                            ${showFeedback && paronym.word === correctAnswer
                                                ? 'bg-emerald-500 text-white shadow-md transform scale-105'
                                                : ''}
                                            ${showFeedback && paronym.word === selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-rose-500 text-white'
                                                : ''}
                                            ${!showFeedback
                                                ? 'bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 hover:border-indigo-300 hover:text-indigo-600 hover:shadow-md hover:transform hover:scale-105 active:bg-indigo-50'
                                                : ''}
                                            ${showFeedback && paronym.word !== selectedAnswer && paronym.word !== correctAnswer
                                                ? 'bg-slate-100 text-slate-400 border border-slate-200'
                                                : ''}
                                            focus:outline-none focus:ring-0
                                        `}
                                    >
                                        {paronym.word}
                                    </button>
                                ))}
                            </div>
                        </>
                    )}

                    {/* Feedback message - always reserve space for it */}
                    <div className={`text-center font-medium text-lg mb-6 py-4 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[80px] flex items-center justify-center
                        ${!showFeedback ? 'opacity-0' : ''}
                        ${showFeedback && isCorrect
                            ? 'bg-emerald-50 text-emerald-700 border border-emerald-200'
                            : showFeedback ? 'bg-rose-50 text-rose-700 border border-rose-200' : ''}`}>
                        {showFeedback ? (
                            isCorrect
                                ? (
                                    <div className="flex items-center justify-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        Правильно!
                                    </div>
                                )
                                : (
                                    <div>
                                        <div className="flex items-center justify-center mb-1">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-2 text-rose-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
                                            </svg>
                                            Неправильно
                                        </div>
                                        <div className="text-sm mt-1">
                                            Правильный ответ: <span className="font-semibold">{correctAnswer}</span>
                                        </div>
                                    </div>
                                )
                        ) : (
                            <span className="invisible">Placeholder for feedback</span>
                        )}
                    </div>

                    {/* Explanation section - always reserve space with min-height */}
                    <div className={`mt-6 border-t border-slate-100 pt-6 w-full transition-opacity duration-300 ${!showExplanation ? 'opacity-0 h-0 overflow-hidden' : ''}`}>
                        <h3 className="text-xl font-semibold mb-4 text-slate-700 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            Объяснения:
                        </h3>
                        <div className="bg-slate-50 rounded-xl p-4 divide-y divide-slate-200">
                            {currentParonymGroup?.paronyms.map((paronym) => (
                                <div key={paronym.word} className="py-3 first:pt-0 last:pb-0">
                                    <p className="text-slate-700">
                                        <span className="font-semibold text-indigo-700">{paronym.word}:</span> {paronym.explanation}
                                    </p>
                                </div>
                            ))}
                        </div>
                    </div>

                    {showFeedback && (
                        <div className="flex justify-center w-full mt-8">
                            <button
                                onClick={displayNewQuestion}
                                className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                            >
                                Следующее слово
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
</file>

<file path="src/StressPracticePage.jsx">
import React, { useState, useEffect, useMemo } from 'react';
import { initializeWords, updateWord, getDueWords, computeNextReview, addDays } from './utils';
import rawWords from './words';

// List of Russian vowels
const vowels = ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я'];

export default function StressPracticePage() {
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState(() => initializeWords(rawWords));

  // State for the current word being practiced
  const [currentWord, setCurrentWord] = useState(null);

  // State to track if we need a retry on the current word
  const [requireRetry, setRequireRetry] = useState(false);

  // State to track the user's selected letter index
  const [selected, setSelected] = useState(null);

  // State to store feedback message
  const [feedback, setFeedback] = useState('');

  // State to track the number of incorrect answers
  const [incorrectCount, setIncorrectCount] = useState(0);

  // State to determine if we're showing all words or just due words
  const [showAllWords, setShowAllWords] = useState(false);

  // State to track if all words are learned
  const [allLearned, setAllLearned] = useState(false);

  // Get due words and set the first one as current on mount
  useEffect(() => {
    loadNextWord();
  }, []);

  // Get words that are due for review
  const dueWords = useMemo(() => {
    return getDueWords(words, today);
  }, [words, today]);

  // Get retired words (for stats)
  const retiredWords = useMemo(() => {
    return words.filter(w => w.retired);
  }, [words]);

  // Split the current word into an array of letters
  const letters = currentWord?.word ? currentWord.word.split('') : [];

  // Load the next word to practice
  const loadNextWord = () => {
    const due = getDueWords(words, today);

    if (due.length > 0) {
      setCurrentWord(due[0]);
      setAllLearned(false);
    } else {
      setCurrentWord(null);
      setAllLearned(true);
    }

    setSelected(null);
    setFeedback('');
    setRequireRetry(false);
  };

  // Handle first correct answer
  const handleFirstCorrect = () => {
    setFeedback('✅ Правильно! Попробуй ещё раз.');
    setRequireRetry(true);
    // Don't reset selected state here - we want to show the green highlight
  };

  // Handle first wrong answer
  const handleFirstWrong = (selectedIdx) => {
    setFeedback('❌ Неправильно. Попробуй ещё раз.');
    setRequireRetry(true);
    setIncorrectCount(prev => prev + 1);
  };

  // Handle the retry attempt
  const finalizeRetry = (selectedIdx) => {
    if (selectedIdx === currentWord.accentIdx) {
      // Correct on retry
      setFeedback('✅ Правильно!');

      // Update the word's learning metadata
      setWords(prevWords => {
        return updateWord(prevWords, currentWord, (word) => {
          word.correctStreak += 1;

          // If streak reaches 4, retire the word
          if (word.correctStreak >= 4) {
            word.retired = true;
          } else {
            // Otherwise, schedule next review based on streak
            word.nextReview = computeNextReview(word.correctStreak, today);
          }
        });
      });
    } else {
      // Wrong on retry
      setFeedback('❌ Неправильно. Правильный ответ выделен.');

      // Reset the word's streak
      setWords(prevWords => {
        return updateWord(prevWords, currentWord, (word) => {
          word.correctStreak = 0;
          word.wrongCount += 1;
          word.nextReview = addDays(today, 1); // Review again tomorrow
        });
      });

      setIncorrectCount(prev => prev + 1);
    }

    // No longer require retry
    setRequireRetry(false);
  };

  // Handle user clicking on a letter
  const handleSelect = (idx) => {
    // Only allow selection if no feedback is currently shown (prevents multiple clicks)
    if (feedback && !requireRetry) return;

    // Guard against no current word
    if (!currentWord) return;

    const clickedLetter = letters[idx].toLowerCase();

    // Only proceed if the clicked letter is a vowel
    if (!vowels.includes(clickedLetter)) {
      return; // Do nothing if it's not a vowel
    }

    // Set the selected letter index
    setSelected(idx);

    // Handle based on whether this is first attempt or retry
    if (!requireRetry) {
      // First attempt
      if (idx === currentWord.accentIdx) {
        handleFirstCorrect();
      } else {
        handleFirstWrong(idx);
      }
    } else {
      // Retry attempt
      finalizeRetry(idx);
    }
  };

  // Toggle between showing all words or just due words
  const toggleWordDisplay = () => {
    setShowAllWords(prev => !prev);
  };

  return (
    // Main container with flex layout for sidebar and main content
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex">
      {/* Sidebar for word stats */}
      <div className="w-1/4 bg-white p-6 overflow-y-auto border-r border-slate-200 shadow-sm flex flex-col">
        <div> {/* Container for the stats */}
          <h2 className="text-2xl font-bold mb-6 text-slate-800 border-b pb-2 border-slate-100">Статистика</h2>

          <div className="mb-6 bg-slate-50 p-4 rounded-xl shadow-sm">
            <div className="grid grid-cols-2 gap-3">
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Всего слов</p>
                <p className="text-xl font-semibold text-slate-800">{words.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Выучено</p>
                <p className="text-xl font-semibold text-emerald-600">{retiredWords.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Осталось</p>
                <p className="text-xl font-semibold text-indigo-600">{words.length - retiredWords.length}</p>
              </div>
              <div className="bg-white p-3 rounded-lg shadow-sm">
                <p className="text-sm text-slate-500 mb-1">Ошибок</p>
                <p className="text-xl font-semibold text-amber-600">{incorrectCount}</p>
              </div>
            </div>
          </div>

          <h3 className="text-lg font-semibold mb-3 text-slate-700 flex items-center">
            <span className="mr-2">{showAllWords ? 'Все слова' : 'Слова на изучении'}</span>
            <span className="text-xs px-2 py-1 bg-slate-100 rounded-full text-slate-600">
              {(showAllWords ? words : words.filter(w => !w.retired)).length}
            </span>
          </h3>

          <ul className="max-h-96 overflow-y-auto mb-4 bg-white rounded-xl shadow-sm divide-y divide-slate-100">
            {(showAllWords ? words : words.filter(w => !w.retired)).map((wordObj, i) => (
              <li key={i} className="py-2 px-3 flex justify-between items-center hover:bg-slate-50 transition-colors">
                <span className="text-slate-700">{wordObj.word}</span>
                <span className={`px-2 py-1 rounded-full text-xs font-medium ${wordObj.retired ? 'bg-emerald-100 text-emerald-700' : 'bg-indigo-100 text-indigo-700'}`}>
                  {wordObj.retired ? '✓' : `${wordObj.correctStreak}/4`}
                </span>
              </li>
            ))}
          </ul>
        </div>

        {/* Toggle button */}
        <button
          onClick={toggleWordDisplay}
          className="mt-auto px-4 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-sm hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out text-sm w-full focus:outline-none focus:ring-0"
        >
          {showAllWords ? 'Показать изучаемые' : 'Показать все слова'}
        </button>
      </div>

      {/* Main content area */}
      <div className="w-3/4 p-8 flex flex-col items-center justify-center">
        <div className="w-full max-w-2xl mx-auto my-auto">
          <h1 className="text-3xl font-bold mb-8 text-center text-slate-800">Тренажер ударений</h1>

          {allLearned ? (
            // Show congratulations message when all words are learned
            <div className="text-center py-12 px-8 bg-white rounded-2xl shadow-lg">
              <div className="w-20 h-20 bg-emerald-100 rounded-full flex items-center justify-center mx-auto mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-10 w-10 text-emerald-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
              </div>
              <h2 className="text-2xl font-bold text-emerald-600 mb-4">Поздравляем!</h2>
              <p className="text-lg mb-4 text-slate-700">Вы выучили все слова на сегодня.</p>
              <p className="text-md text-slate-500">Приходите завтра для повторения.</p>
            </div>
          ) : (
            // Regular practice UI
            <>
              {/* Progress display */}
              <div className="mb-6 flex justify-between text-slate-600 bg-white px-4 py-3 rounded-xl shadow-sm">
                <span className="flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-emerald-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Выучено: <span className="font-semibold ml-1">{retiredWords.length}/{words.length}</span>
                </span>
                <span className="flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-indigo-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                  Осталось сегодня: <span className="font-semibold ml-1">{dueWords.length}</span>
                </span>
              </div>

              {/* Word display */}
                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-lg mb-4 flex flex-col items-center w-full max-w-full">
                  {/* Word display with overflow handling */}
                  <div className="w-full overflow-x-auto mb-8 py-2">
                    <div className="flex justify-center items-center space-x-2 text-4xl md:text-5xl min-w-min mx-auto">
                      {letters.map((letter, idx) => {
                        const isVowel = vowels.includes(letter.toLowerCase());
                        const isCorrect = idx === currentWord?.accentIdx;
                        const isSelected = selected === idx;
                        const showCorrect = requireRetry === false && feedback && isCorrect;

                        return (
                          <span
                            key={idx}
                            onClick={() => handleSelect(idx)}
                            className={`
                            relative cursor-pointer px-2 py-1 rounded-lg transition-all duration-200
                            ${isVowel ? 'hover:bg-slate-100 hover:transform hover:scale-110' : ''}
                            ${isSelected && isCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                            ${isSelected && !isCorrect ? 'bg-rose-500 text-white' : ''}
                            ${showCorrect ? 'bg-emerald-500 text-white transform scale-110' : ''}
                          `}
                          >
                            {letter}
                            {isVowel && (
                              <span className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-1 h-1 bg-slate-300 rounded-full"></span>
                            )}
                          </span>
                        );
                      })}
                    </div>
                  </div>

                  {/* Feedback message - always reserve space for it */}
                  <div className={`text-center my-6 text-lg font-medium py-3 px-6 rounded-xl w-full max-w-md mx-auto transform transition-all duration-300 ease-in-out min-h-[60px] flex items-center justify-center
                  ${!feedback ? 'opacity-0' : ''}
                  ${feedback && feedback.includes('Правильно')
                      ? 'bg-emerald-50 text-emerald-700 border border-emerald-200'
                      : feedback ? 'bg-rose-50 text-rose-700 border border-rose-200' : ''}`}>
                    {feedback || 'Placeholder for feedback'}
                  </div>

                {/* Next word button - changes text based on retry state */}
                <div className="flex justify-center w-full mt-6">
                  {requireRetry ? (
                    <button
                      onClick={() => {
                        // Clear feedback and reset selected state to prepare for retry
                        setFeedback('');
                        setSelected(null);
                      }}
                        className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                    >
                      Попробуй ещё раз
                    </button>
                  ) : (
                    <button
                      onClick={loadNextWord}
                          className="px-8 py-3 bg-indigo-600 text-white font-medium rounded-xl shadow-md hover:bg-indigo-700 active:bg-indigo-800 transition-all duration-200 ease-in-out mx-auto focus:outline-none focus:ring-0 transform hover:scale-105"
                      disabled={feedback !== '' && requireRetry}
                    >
                      Следующее слово
                    </button>
                  )}
                </div>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="package.json">
{
  "name": "russian-stress-practice",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1997.5 2000" style="enable-background:new 0 0 1997.5 2000" xml:space="preserve"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="498.781" y1="2229.557" x2="1666.593" y2="643.575" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#41d1ff"/><stop offset="1" style="stop-color:#bd34fe"/></linearGradient><path d="m1990.9 296-938.3 1677.9c-19.4 34.6-69.1 34.8-88.8.4L6.8 296.2c-21.4-37.6 10.7-83.1 53.3-75.5l939.3 167.9c6 1.1 12.1 1.1 18.1 0L1937.2 221c42.4-7.8 74.7 37.4 53.7 75z" style="fill:url(#a)"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="1049.466" y1="1988.58" x2="1260.718" y2="539.417" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#ffea83"/><stop offset=".083" style="stop-color:#ffdd35"/><stop offset="1" style="stop-color:#ffa800"/></linearGradient><path d="M1446.9.5 752.5 136.6c-11.4 2.2-19.9 11.9-20.6 23.5l-42.7 721.4c-1 17 14.6 30.2 31.2 26.4l193.3-44.6c18.1-4.2 34.4 11.8 30.7 30L887 1174.4c-3.9 18.9 13.9 35.1 32.4 29.5l119.4-36.3c18.5-5.6 36.3 10.6 32.4 29.6L979.9 1639c-5.7 27.6 31 42.7 46.4 19l10.2-15.8L1602.4 513c9.5-18.9-6.9-40.5-27.6-36.5l-199 38.4c-18.7 3.6-34.6-13.8-29.3-32.1l129.9-450.3c5.2-18.2-10.8-35.7-29.5-32z" style="fill:url(#b)"/></svg>
</file>

<file path="src/App.jsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './StressPracticePage';
import ParonymsPage from './ParonymsPage';
import Navigation from './components/Navigation';

export default function App() {
  return (
    <Router basename="/russian-stress-practice">
      <div className="flex flex-col min-h-screen">
        <Navigation />
        <div className="flex-grow">
          <Routes>
            <Route path="/" element={<StressPracticePage />} />
            <Route path="/paronyms" element={<ParonymsPage />} />
          </Routes>
        </div>
      </div>
    </Router>
  );
}
</file>

<file path="README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"вОвремя"` (stress on the first 'о')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="src/main.ts">
import "./style.css";

// Add global declaration for the appLoaded flag
declare global {
    interface Window {
        appLoaded: boolean;
    }
}

interface WordData {
    word: string;
    stressedIndex: number;
    stressedWord: string;
}

// Set flag to indicate the script has successfully loaded
window.appLoaded = true;

document.addEventListener("DOMContentLoaded", () => {
    const wordDisplay = document.getElementById(
        "word-display",
    ) as HTMLDivElement;
    const feedback = document.getElementById("feedback") as HTMLDivElement;
    const nextButton = document.getElementById(
        "next-button",
    ) as HTMLButtonElement;
    const scoreDisplay = document.getElementById("score") as HTMLSpanElement;
    const attemptsDisplay = document.getElementById(
        "attempts",
    ) as HTMLSpanElement;

    const VOWELS: string = "аеёиоуыэюя";
    let wordsData: WordData[] = [];
    let currentWordIndex: number = -1;
    let score: number = 0;
    let attempts: number = 0;
    let isAnswered: boolean = false;

    async function loadWords(): Promise<void> {
        try {
            // Use the base URL from Vite environment
            const basePath = (import.meta as any).env.BASE_URL || '/';
            const response: Response = await fetch(`${basePath}phonetics.txt`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text: string = await response.text();
            parseAndStoreWords(text);
            if (wordsData.length > 0) {
                shuffleArray(wordsData);
                displayNextWord();
            } else {
                wordDisplay.textContent = "No words found in file.";
                nextButton.disabled = true;
            }
        } catch (error) {
            console.error("Error loading or parsing words file:", error);
            wordDisplay.textContent = "Error loading words.";
            feedback.textContent =
                "Could not load phonetics.txt. Please check the file and console.";
            feedback.className = "feedback incorrect";
            nextButton.disabled = true;
        }
    }

    function parseAndStoreWords(text: string): void {
        // First split by lines, then process each line
        const lines = text
            .trim()
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0);

        // Process each line, handling semicolon-separated forms
        const processedWords: WordData[] = [];

        for (const line of lines) {
            // Split by semicolon to handle multiple forms
            const wordForms = line.split(";").map((form) => form.trim());

            for (const stressedWord of wordForms) {
                // Skip empty forms
                if (stressedWord.length === 0) continue;

                // Process comma-separated forms (like "прИбыл, прибылА, прИбыли")
                const commaSeparatedForms = stressedWord
                    .split(",")
                    .map((form) => form.trim());

                for (const form of commaSeparatedForms) {
                    if (form.length === 0) continue;

                    const wordLower: string = form.toLowerCase();
                    let stressedIndex: number = -1;

                    for (let i: number = 0; i < form.length; i++) {
                        if (
                            form[i] !== wordLower[i] &&
                            VOWELS.includes(wordLower[i])
                        ) {
                            stressedIndex = i;
                            break;
                        }
                    }

                    if (stressedIndex === -1) {
                        console.warn(
                            `Could not find stressed vowel in: "${form}"`,
                        );
                        continue;
                    }

                    processedWords.push({
                        word: wordLower,
                        stressedIndex: stressedIndex,
                        stressedWord: form,
                    });
                }
            }
        }

        wordsData = processedWords;
    }

    function displayNextWord(): void {
        if (wordsData.length === 0) return;

        isAnswered = false;
        currentWordIndex = (currentWordIndex + 1) % wordsData.length;
        const currentWord: WordData = wordsData[currentWordIndex];

        wordDisplay.innerHTML = "";
        wordDisplay.classList.remove("answered");
        feedback.textContent = "";
        feedback.className = "feedback";
        nextButton.disabled = true;

        currentWord.word.split("").forEach((char: string, index: number) => {
            const span: HTMLSpanElement = document.createElement("span");
            span.textContent = char;
            if (VOWELS.includes(char.toLowerCase())) {
                span.classList.add("vowel");
                span.dataset.index = index.toString(); // Store as string
                span.addEventListener("click", handleVowelClick);
            }
            wordDisplay.appendChild(span);
        });
    }

    function handleVowelClick(event: Event): void {
        if (isAnswered) return;

        isAnswered = true;
        wordDisplay.classList.add("answered");
        const target = event.target as HTMLSpanElement; // Type assertion
        const clickedIndex: number = parseInt(target.dataset.index || "", 10); // Handle potential null
        const correctIndex: number = wordsData[currentWordIndex].stressedIndex;
        const correctWord: string = wordsData[currentWordIndex].stressedWord;

        attempts++;
        attemptsDisplay.textContent = attempts.toString();

        // Remove click listeners from all vowels after answering
        wordDisplay.querySelectorAll("span.vowel").forEach((vowelSpan) => {
            // Clone and replace to remove listeners cleanly
            const newSpan = vowelSpan.cloneNode(true) as HTMLSpanElement;
            vowelSpan.parentNode?.replaceChild(newSpan, vowelSpan);
        });

        // Find the span elements again after replacement
        const vowelSpans = Array.from(
            wordDisplay.querySelectorAll("span"),
        ) as HTMLSpanElement[];

        if (clickedIndex === correctIndex) {
            score++;
            scoreDisplay.textContent = score.toString();
            feedback.textContent = "Correct!";
            feedback.className = "feedback correct";

            const correctSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === correctIndex,
            );
            if (correctSpan) {
                correctSpan.classList.add("correct-stress");
            }
        } else {
            feedback.textContent = `Incorrect. Correct: ${correctWord}`;
            feedback.className = "feedback incorrect";

            const correctSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === correctIndex,
            );
            const incorrectSpan = vowelSpans.find(
                (span) =>
                    parseInt(span.dataset.index || "", 10) === clickedIndex,
            );

            if (correctSpan) {
                correctSpan.classList.add("correct-stress");
            }
            if (incorrectSpan) {
                incorrectSpan.classList.add("incorrect-guess");
            }
        }

        nextButton.disabled = false;
    }

    function shuffleArray<T>(array: T[]): void {
        for (let i: number = array.length - 1; i > 0; i--) {
            const j: number = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    nextButton.addEventListener("click", displayNextWord);
    nextButton.disabled = true;
    loadWords();
});
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
        outDir: "dist",
        emptyOutDir: true,
        rollupOptions: {
            input: "./index.html",
            output: {
                entryFileNames: `assets/[name].[hash].js`,
                chunkFileNames: `assets/[name].[hash].js`,
                assetFileNames: `assets/[name].[hash].[ext]`
            }
        }
    },
    publicDir: "public",
    server: {
        open: true
    }
});
</file>

<file path="index.html">
<!doctype html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <link rel="icon" type="image/svg+xml" href="./vite.svg" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Russian Stress Practice</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="./src/main.jsx"></script>
    </body>
</html>
</file>

</files>
</file>

<file path=".lintstagedrc.yml">
'*.{ts,js,json,yml}': 'prettier --loglevel warn --cache --write'
</file>

<file path="backend/.gitignore">
node-modules
dist
.DS_Store
.env
</file>

<file path="backend/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix"
  - "prettier --loglevel warn --cache --write"
"*.{json,yml,scss}": "prettier --loglevel warn --cache --write"
</file>

<file path="backend/eslint.config.mjs">
import { defineConfig } from "eslint/config";
import path from 'path';
import tsParser from '@typescript-eslint/parser';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import importPlugin from 'eslint-plugin-import';

export default defineConfig([{
    files: ['**/*.ts', '**/*.tsx', '**/*.js'],
    ignores: ['jest.config.js'],
    plugins: {
        '@typescript-eslint': tsPlugin,
        'import': importPlugin
      },
    languageOptions: {
        ecmaVersion: 5,
        sourceType: "script",
        parser: tsParser,
        parserOptions: {
            project: "./tsconfig.json",
        },
    },

    settings: {
        "import/resolver": {
            node: {
                extensions: [".js", ".ts", ".tsx"],
            },
        },
    },

    rules: {
        "no-console": "error",

        "no-restricted-imports": ["error", {
        patterns: [{
          group: [
            path.join(process.cwd(), "src/test/**"),
            `!${path.join(process.cwd(), "src/**/*.integration.test.ts")}`
          ],
          message: "Import from test dir is only allowed in integration test files",
        }]
      }],

      "import/order": ["error", {
            groups: ["builtin", "external", "parent", "sibling", "index"],

            pathGroups: [{
                pattern: "{.,..}/**/env\n",
                group: "builtin",
                position: "before",
            }, {
                pattern: "{.,..}/**/test/integration\n",
                group: "builtin",
                position: "before",
            }],

            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],
    },
}]);
</file>

<file path="backend/jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.cjs'),
  }
</file>

<file path="backend/src/data/words.js">
// Raw list with uppercase marking the stressed vowel
const rawWords = [
  "Августовский",
  "агЕнт",
  "алфавИт",
  "алкогОль",
  "аэропОрты",
  "аристокрАтия",
  "апострОф",
  "агронОмия",
  "асимметрИя",
  // Б
  "балОванный",
  "баловАть",
  "баловАться",
  "балУясь",
  "бАнты",
  "безУдержный",
  "бОроду",
  "бОчковый",
  "бухгАлтеров",
  "благоволИть",
  "блАговест",
  "бряцАть",
  "бУнгало",
  "брОня на билеты",
  "бронЯ у танка",
  "бюрокрАтия",
  "брюшкО",
  "бракОвщик",
  // В
  "вЕчеря",
  "вероисповЕдание",
  "взбешЕнный",
  "ворожеЯ",
  "вОзрастов",
  "втрИдешева",
  // Г
  "гЕнезис",
  "гЕрбовый",
  "граждАнство",
  "грУшевый",
  "граффИти",
  "гастронОмия",
  "грАблями",
  // Д
  "давнИшний",
  "дефИс",
  "деньгАх",
  "дешевИзна",
  "дозИровать",
  "долбЯщий",
  "докраснА",
  "донЕльзя",
  "дОнизу",
  "досУг",
  "дОсуха",
  "доЯр",
  "духовнИк",
  "домОвая книга",
  // Е
  "еретИк",
  // Ж
  "жалюзИ",
  "жилОсь",
  "жерлОз",
  // З
  "завсегдАтай",
  "завИдно",
  "зАгодя",
  "закУпорив",
  "зАтемно",
  "знАчимый",
  "зимОвщик",
  "зубчАтый",
  "знАмение",
  // И
  "ирИс",
  "Ирис",
  "искрА зажигания",
  "Иконопись",
  "Исподволь",
  "избалОванный",
  "издрЕвле",
  "Иксы с Иксом",
  "исключИт",
  "Исстари",
  "исчЕрпав",
  "исчЕрпать",
  // К
  "каталОг",
  "кАмбала",
  "крапИва",
  "кАшлянуть",
  "квартАл",
  "киломЕтр",
  "клАла",
  "кремЕнь",
  "кремнЯ",
  "крЕмы",
  "костюмирОванный",
  "кулинАрия",
  "коклЮш",
  "красИвее",
  "крАны",
  "корЫсть",
  "кровоточИть",
  "кровоточАщий",
  "кУхонный",
  "кладовАя",
  "опОшлят",
  "оптОвый",
  "освЕдомиться",
  "отзЫв",
  "откУпорил",
  "отрочество",
  "oполОснутый",
  "озвУчение",
  "одновремЕнно",
  "крАдучись",
  "куркУма",
  "кичИться",
  "кедрОвый",
  // Л
  "лЕкторов",
  "ловкА",
  "лососЕвый",
  "лыжнЯ",
  // М
  "мастерскИ",
  "мЕстностей",
  "мозаИчный",
  "мещанИн",
  "молЯщий",
  "мусоропровОд",
  "мытАрство",
  "мЕльком",
  // Н
  "наделИт",
  "надОлго",
  "намЕрение",
  "нарОст",
  "насорИт",
  "нЕдруг",
  "недУг",
  "насквОзь",
  "назвАный брат",
  "наговОр",
  "ненадОлго",
  "низведЕн",
  "нОвости",
  "новостЕй",
  "нОгтя",
  "нормировАть",
  // О
  "обеспЕчение",
  "ободрИть",
  "ободренА",
  "одолжИт",
  "озлОбить",
  "окружИт",
  "опломбировАть",
  // П
  "партЕр",
  "пАмятуя",
  "пЕрчит",
  "плЕсневеть",
  "плодоносИть",
  "пОручни",
  "послАла",
  "прИбыл",
  "придАное",
  "принУдить",
  "прИнятый",
  "принялсЯ",
  "прозорлИва",
  "прожОрлива",
  "подчАс",
  "тОтчас",
  "пЕтля",
  "пЕтелька",
  "пЕня",
  "простынЯ",
  "пУрпур",
  "платО",
  "прИкус",
  "пулОвер",
  "поутрУ",
  "пригУбить",
  "плешИна",
  // Р
  "ржавЕть",
  "расклЕшенный",
  // С
  "свЕкла",
  "сверлИт",
  "сверлИшь",
  "серА",
  "сЕры",
  "сЕтчатый",
  "сирОты",
  "слИвовый",
  "сОгнутый",
  "созЫв",
  "сорИт",
  "срЕдства",
  "срЕдствами",
  "стАтуя",
  "столЯр",
  "сосредотОчение",
  "скулА",
  "скобА",
  "страхОвщик",
  // Т
  "тЕплится",
  "тОрты",
  "тОтчас",
  "танцОвщица",
  "толИка",
  "тУфля",
  // У
  "убыстрИть",
  "углубИть",
  "украИнский",
  "укрепИт",
  "умЕрший",
  "усугубИт",
  "упрОчение",
  // Ф
  "фенОмен",
  "фОрзац",
  "фетИш",
  "факсИмиле",
  // Х
  "ходАтайствовать",
  "христианИн",
  "хозЯева",
  "хОленный",
  // Ц
  "цемЕнт",
  "цЕнтнер",
  "цепОчка",
  "цыгАн",
  // Ч
  "чЕлюстей",
  "чЕрпать",
  // Ш
  "шАрфы",
  "шофЕр",
  "шпрИцы",
  // Щ
  "щавЕль",
  "щемИт",
  "щЕлкать",
  "щепА",
  // Э
  "экспЕрт",
  "эпилОг"
];

export default rawWords;
</file>

<file path="backend/src/index.ts">
import { env } from "./utils/env";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import cors from "cors";
import express from "express";
import { AppContext, createAppContext } from "./lib/ctx";
import { applyPassportToExpressApp } from "./lib/passport";
import { ApplyTrpcToExpressApp, getCreateTrpcContext } from "./lib/trpc";
import { trpcRouter } from "./router";
import { logger } from "./utils/logger";

void (async () => {
  let ctx: AppContext | null = null;
  try {
    const app = express();
    ctx = createAppContext();
    
    app.use(
      cors({
        origin: ["http://localhost:5173"], // Explicitly allow your frontend origin
        credentials: true,
        methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowedHeaders: [
          "Content-Type",
          "Authorization",
          "x-trpc-source",
          "Access-Control-Allow-Origin",
          "Access-Control-Allow-Credentials",
        ],
      })
    );
    
    // Важно: применяем Passport до TRPC middleware
    applyPassportToExpressApp(app, ctx);
    
    await ApplyTrpcToExpressApp(app, ctx, trpcRouter);
    
    app.options("*", cors());
    app.get("/ping", (req, res) => {
      res.send("pong");
    });
    
    app.use(
      (
        error: unknown,
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        logger.error("express", error);
        if (res.headersSent) {
          next(error);
          return;
        }
        res.status(500).send("Internal server error");
      }
    );

    app.listen(env.PORT, () => {
      logger.info("app", `listening on http://localhost:${env.PORT}`);
    });
  } catch (error) {
    logger.error("app", error);
    await ctx?.stop();
  }
})();
</file>

<file path="backend/src/lib/ctx.ts">
import { createPrismaClient } from "./prisma";

export const createAppContext = () => {
  const prisma = createPrismaClient();
  return {
    prisma,
    stop: async () => {
      await prisma.$disconnect();
    },
  };
};

export type AppContext = ReturnType<typeof createAppContext>;
</file>

<file path="backend/src/lib/passport.ts">
import { env } from "../utils/env";
import { Express } from "express";
import { Passport } from "passport";
import { ExtractJwt, Strategy as JWTStrategy } from "passport-jwt";
import { logger } from "../utils/logger";
import { AppContext } from "./ctx";

export const applyPassportToExpressApp = (expressApp: Express, ctx: AppContext): void => {
  const passport = new Passport();

  // Стандартный payload: { sub: user.id, … }
  passport.use(
    new JWTStrategy(
      {
        secretOrKey: env.JWT_SECRET,
        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      },
      async (jwtPayload: any, done) => {
        try {
          logger.info("passport:jwt", "JWT payload received", { payload: jwtPayload });
          const userId = parseInt(jwtPayload.sub, 10);
          logger.info("passport:jwt", "Looking for user with ID", { userId });
          
          const user = await ctx.prisma.user.findUnique({ where: { id: userId } });
          
          if (!user) {
            logger.info("passport:jwt", "User not found", { userId });
            return done(null, false);
          }
          
          logger.info("passport:jwt", "User authenticated successfully", { userId });
          return done(null, user);
        } catch (error) {
          logger.error("passport:jwt", error);
          return done(error, false);
        }
      }
    )
  );

  expressApp.use((req, res, next) => {
    // если нет заголовка – пропускаем дальше
    if (!req.headers.authorization) {
      logger.info("passport:middleware", "No authorization header");
      return next();
    }

    logger.info("passport:middleware", "Authorization header found", { 
      header: req.headers.authorization.substring(0, 20) + '...' 
    });

    passport.authenticate("jwt", { session: false }, (err: any, user: any) => {
      if (err) {
        logger.error("passport:middleware", err);
      }
      
      req.user = user ?? undefined;
      logger.info("passport:middleware", user ? "User attached to request" : "No user attached to request", {
        userId: user?.id
      });
      
      next();
    })(req, res, next);
  });
};
</file>

<file path="backend/src/lib/prisma.ts">
import { env } from "../utils/env";
import { PrismaClient } from "@prisma/client";
import { logger } from "../utils/logger";

export const createPrismaClient = () => {
  const prisma = new PrismaClient({
    log: [
      {
        emit: "event",
        level: "query",
      },
      {
        emit: "event",
        level: "info",
      },
    ],
  });

  prisma.$on("query", (e) => {
    logger.info("prisma:low:query", "Successfull request", {
      query: e.query,
      duration: e.duration,
      params: env.HOST_ENV === "local" ? e.params : "***",
    });
  });

  prisma.$on("info", (e) => {
    logger.info("prisma:low:info", e.message);
  });

  const extendedPrisma = prisma.$extends({
    client: {},
    query: {
      $allModels: {
        $allOperations: async ({ model, operation, args, query }) => {
          const start = Date.now();
          try {
            const result = await query(args);
            const durationMs = Date.now() - start;
            logger.info("prisma:high", "Successfull request", {
              model,
              operation,
              args,
              durationMs,
            });
            return result;
          } catch (error) {
            const durationMs = Date.now() - start;
            logger.error("prisma:high", error, {
              model,
              operation,
              args,
              durationMs,
            });
            throw error;
          }
        },
      },
    },
  });

  return extendedPrisma;
};
</file>

<file path="backend/src/lib/trpc.ts">
import { inferAsyncReturnType, initTRPC } from "@trpc/server";
import * as trpcExpress from "@trpc/server/adapters/express";
import { type Express } from "express";
import { SuperJSON } from "superjson";
import { expressHandler } from "trpc-playground/handlers/express";
import { TrpcRouter, type trpcRouter } from "../router";
// import { AppContext } from "./ctx";
import { ExpectedError } from "../utils/error";
import { logger } from "../utils/logger";
import { ExpressRequest } from "../utils/types";
import { AppContext } from "./ctx";

export const getTrpcContext = ({ appContext, req }: {appContext: AppContext, req: ExpressRequest}) => ({
  ...appContext,
  me: (req as ExpressRequest).user || null,
})


export const getCreateTrpcContext =
  (appContext: AppContext) =>
  ({ req }: trpcExpress.CreateExpressContextOptions) =>
    getTrpcContext({ appContext, req: req as ExpressRequest })

type TrpcContext = inferAsyncReturnType<
  ReturnType<typeof getCreateTrpcContext>
>;

const trpc = initTRPC.context<TrpcContext>().create({
  transformer: SuperJSON,
  errorFormatter: ({shape, error}) => {
    const orginalError = error.cause as Error
    const expected = orginalError instanceof ExpectedError
    return {
      ...shape,
      data: {
        ...shape.data,
        expected
      }
    }
  }
});

export const createTrpcRouter = trpc.router

export const trpcLoggedProcedure = trpc.procedure.use(
  trpc.middleware(async ({ path, type, next, ctx, rawInput }) => {
    const start = Date.now()
    const result = await next()
    const durationMs = Date.now() - start
    const meta = {
      path,
      type,
      userId: ctx.me?.id || null,
      durationMs,
      rawInput: rawInput || null,
    }
    if (result.ok) {
      logger.info(`trpc:${type}:success`, 'Successfull request', { ...meta, output: result.data })
    } else {
      logger.error(`trpc:${type}:error`, result.error)
    }
    return result
  })
)

export const ApplyTrpcToExpressApp = async (
  app: Express,
  ctx: AppContext,
  trpcRouter: TrpcRouter,
) => {
  app.use(
    "/trpc",
    trpcExpress.createExpressMiddleware({
      router: trpcRouter,
      createContext: getCreateTrpcContext(ctx),
    }),
  );

  app.use(
    "/trpc-playground",
    await expressHandler({
      trpcApiEndpoint: "/trpc",
      playgroundEndpoint: "/trpc-playground",
      router: trpcRouter,
      request: {
        superjson: true,
      },
    }),
  );
};
</file>

<file path="backend/src/prisma/migrations/20250427152613_initial/migration.sql">
-- CreateEnum
CREATE TYPE "Provider" AS ENUM ('GOOGLE', 'YANDEX');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "score" INTEGER NOT NULL DEFAULT 0,
    "provider" "Provider" NOT NULL,
    "providerId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "tokenExpires" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Word" (
    "id" SERIAL NOT NULL,
    "word" TEXT NOT NULL,
    "stress" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Word_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Practice" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "wordId" INTEGER NOT NULL,
    "correct" BOOLEAN NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Practice_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "User_provider_providerId_key" ON "User"("provider", "providerId");

-- CreateIndex
CREATE INDEX "Practice_userId_idx" ON "Practice"("userId");

-- CreateIndex
CREATE INDEX "Practice_wordId_idx" ON "Practice"("wordId");

-- AddForeignKey
ALTER TABLE "Practice" ADD CONSTRAINT "Practice_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Practice" ADD CONSTRAINT "Practice_wordId_fkey" FOREIGN KEY ("wordId") REFERENCES "Word"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="backend/src/prisma/migrations/20250507174003_added_new_practice_type_and_updated_word/migration.sql">
-- CreateEnum
CREATE TYPE "PracticeType" AS ENUM ('STRESS', 'PARONYM');

-- AlterTable
ALTER TABLE "Word" ADD COLUMN     "type" "PracticeType" NOT NULL DEFAULT 'STRESS';
</file>

<file path="backend/src/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="backend/src/router/auth/GetAuth/index.ts">
import { Provider } from "@prisma/client";
import jwt from "jsonwebtoken"
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { env } from "../../../utils/env";
import { ExpectedError } from "../../../utils/error";
import { zOAuthLogin } from "./input";

export const GetAuthTrpcRoute = trpcLoggedProcedure
  .input(zOAuthLogin)
  .mutation(async ({ ctx, input }) => {
    const { provider, credentials } = input;

    try {
      // Try to find existing user
      const existingUser = await ctx.prisma.user.findUnique({
        where: {
          provider_providerId: {
            provider: provider as Provider,
            providerId: credentials.providerId,
          },
        },
      });

      let newOrUpdatedUser;
      
      if (existingUser) {
        // Update existing user's tokens
        newOrUpdatedUser = await ctx.prisma.user.update({
          where: { id: existingUser.id },
          data: {
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
            name: credentials.name || existingUser.name,
          },
        });
      } else {
        // Create new user
        newOrUpdatedUser = await ctx.prisma.user.create({
          data: {
            email: credentials.email,
            name: credentials.name,
            provider: provider as Provider,
            providerId: credentials.providerId,
            accessToken: credentials.accessToken,
            refreshToken: credentials.refreshToken,
            tokenExpires: credentials.tokenExpires,
          },
        });
      }
      
      const appToken = jwt.sign(
        { sub: newOrUpdatedUser.id },
        env.JWT_SECRET,
        { expiresIn: "7d" }
      );
      
      return { user: newOrUpdatedUser, token: appToken };
    } catch (error) {
      throw new ExpectedError("Failed to process authentication");
    }
  });
</file>

<file path="backend/src/router/auth/GetAuth/input.ts">
import { z } from "zod";

export const zOAuthCredentials = z.object({
  email: z.string().email(),
  name: z.string().optional(),
  providerId: z.string(),
  accessToken: z.string(),
  refreshToken: z.string().optional(),
  tokenExpires: z.string().optional().transform(val => val ? new Date(val) : undefined),
});

export const zOAuthLogin = z.object({
  provider: z.enum(['GOOGLE', 'YANDEX']),
  credentials: zOAuthCredentials,
});
</file>

<file path="backend/src/router/auth/GetMe/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { toClientMe } from "../../../utils/models";

export const GetMeTrpcRoute = trpcLoggedProcedure.query(({ ctx }) => {
  return { me: toClientMe(ctx.me) };
});
</file>

<file path="backend/src/router/index.ts">
import { inferRouterInputs, inferRouterOutputs } from "@trpc/server";
import { createTrpcRouter } from "../lib/trpc";
// @index('./**/index.ts', f => `import { ${f.path.split('/').slice(0, -1).pop()}TrpcRoute } from '${f.path.split('/').slice(0, -1).join('/')}'`)
import { CheckPersonalItemTrpcRoute } from './Dictionary/CheckPersonalItem'
import { GetPersonalDictionaryTrpcRoute } from './Dictionary/GetPersonalDictionary'
import { TogglePersonalParonymTrpcRoute } from './Dictionary/TogglePersonalParonym'
import { TogglePersonalWordTrpcRoute } from './Dictionary/TogglePersonalWord'
import { GetParonymsTrpcRoute } from './Practice/GetParonyms'
import { GetPracticeWordsTrpcRoute } from './Practice/GetPracticeWords'
import { GetUserStatsTrpcRoute } from './Practice/GetUserStats'
import { RecordPracticeTrpcRoute } from './Practice/RecordPractice'
import { GetAuthTrpcRoute } from './auth/GetAuth'
import { GetMeTrpcRoute } from './auth/GetMe'
// @endindex


export const trpcRouter = createTrpcRouter({
    // @index('./**/index.ts', f => `${f.path.split('/').slice(0, -1).pop()}: ${f.path.split('/').slice(0, -1).pop()}TrpcRoute,`)
    GetAuth: GetAuthTrpcRoute,
    GetMe: GetMeTrpcRoute,
    CheckPersonalItem: CheckPersonalItemTrpcRoute,
    GetPersonalDictionary: GetPersonalDictionaryTrpcRoute,
    TogglePersonalParonym: TogglePersonalParonymTrpcRoute,
    TogglePersonalWord: TogglePersonalWordTrpcRoute,
    GetParonyms: GetParonymsTrpcRoute,
    GetPracticeWords: GetPracticeWordsTrpcRoute,
    GetUserStats: GetUserStatsTrpcRoute,
    RecordPractice: RecordPracticeTrpcRoute,
    // @endindex
})


export type TrpcRouter = typeof trpcRouter;
export type TrpcRouterInput = inferRouterInputs<TrpcRouter>;
export type TrpcRouterOutput = inferRouterOutputs<TrpcRouter>;
</file>

<file path="backend/src/router/Practice/GetPracticeWords/index.ts">
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetPracticeWords } from "./input";

export const GetPracticeWordsTrpcRoute = trpcLoggedProcedure
    .input(zGetPracticeWords)
    .query(async ({ ctx, input }) => {
        const words = await ctx.prisma.word.findMany({
            where: {
                type: input.type
            },
            select: {
                id: true,
                word: true,
                stress: true,
                practices: {
                    where: {
                        userId: ctx.me?.id
                    },
                    orderBy: {
                        createdAt: 'desc'
                    },
                    take: 10
                }
            }
        });
        
        return {
            words: words.map(word => ({
                id: word.id,
                word: word.word,
                accentIdx: word.stress,
                history: word.practices.map(practice => ({
                    correct: practice.correct,
                    date: practice.createdAt
                }))
            }))
        };
    });
</file>

<file path="backend/src/router/Practice/GetPracticeWords/input.ts">
import {z} from 'zod'

export const zGetPracticeWords = z.object({
    type: z.enum(['STRESS', 'PARONYM'])
})
</file>

<file path="backend/src/router/Practice/GetUserStats/index.ts">
import { PrismaClient, PracticeType } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { format, subDays } from "date-fns";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zGetUserStats } from "./input";

export const GetUserStatsTrpcRoute = trpcLoggedProcedure
  .input(zGetUserStats)
  .query(async ({ ctx, input }) => {
    if (!ctx.me) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }

    const { type, period } = input;
    
    // Определяем период для фильтрации
    const periodDate = period 
      ? new Date(Date.now() - period * 24 * 60 * 60 * 1000)
      : undefined;

    try {
      // Общая статистика в зависимости от типа практики
      if (type === "STRESS") {
        // Получаем статистику по ударениям
        const practiceQuery = {
          userId: ctx.me.id,
          word: {
            type: "STRESS",
          },
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
          },
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.practice.count({
          where: {
            ...practiceQuery,
            word: {
              type: PracticeType.STRESS,
            },
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.practice.count({
          where: {
            userId: ctx.me.id,
            word: {
              type: "STRESS",
            },
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getDailyStats(ctx.prisma as any, ctx.me.id, "STRESS", period);
        
        // Проблемные слова
        const problemWords = await getProblemWords(ctx.prisma as any, ctx.me.id, "STRESS");
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords,
        };
      } 
      else if (type === "PARONYM") {
        // Получаем статистику по паронимам
        const practiceQuery = {
          userId: ctx.me.id,
          ...(periodDate && { createdAt: { gte: periodDate } }),
        };
        
        // Общее количество попыток
        const totalAttempts = await ctx.prisma.paronymPractice.count({
          where: practiceQuery,
        });
        
        // Количество правильных попыток
        const correctAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            ...practiceQuery,
            correct: true,
          },
        });
        
        // Статистика за последние 7 дней (независимо от выбранного периода)
        const recentDate = subDays(new Date(), 7);
        const recentTotalAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
          },
        });
        
        const recentCorrectAttempts = await ctx.prisma.paronymPractice.count({
          where: {
            userId: ctx.me.id,
            createdAt: { gte: recentDate },
            correct: true,
          },
        });
        
        // Ежедневная статистика
        const dailyStats = await getParonymDailyStats(ctx.prisma as any, ctx.me.id, period);
        
        // Проблемные пары паронимов
        const problemParonyms = await getProblemParonyms(ctx.prisma as any, ctx.me.id);
        
        return {
          summary: {
            totalAttempts,
            correctAttempts,
            correctRate: totalAttempts > 0 ? correctAttempts / totalAttempts : 0,
            recentStats: {
              totalAttempts: recentTotalAttempts,
              correctAttempts: recentCorrectAttempts,
              correctRate: recentTotalAttempts > 0 ? recentCorrectAttempts / recentTotalAttempts : 0,
            },
          },
          dailyStats,
          problemWords: problemParonyms, // Используем тот же формат для совместимости
        };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Неподдерживаемый тип практики",
      });
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("Error fetching user stats:", error);
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Не удалось получить статистику",
        cause: error,
      });
    }
  });

// Типы для статистики
type DailyStats = {
  date: string;
  total: number;
  correct: number;
  rate: number;
};

type ProblemWord = {
  id: number;
  word: string;
  total: number;
  correct: number;
};

// Вспомогательная функция для получения ежедневной статистики по ударениям
async function getDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // По умолчанию 30 дней
  const startDate = subDays(new Date(), periodDays);
  
  // Получаем все попытки за указанный период
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // Группируем по дням
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Вспомогательная функция для получения проблемных слов
async function getProblemWords(
  prisma: PrismaClient, 
  userId: number, 
  type: PracticeType
): Promise<ProblemWord[]> {
  // Получаем все попытки пользователя для данного типа практики
  const practices = await prisma.practice.findMany({
    where: {
      userId,
      word: {
        type,
      },
    },
    include: {
      word: true,
    },
  });
  
  // Группируем по словам и считаем статистику
  const wordStats = new Map<number, { word: string, total: number, correct: number }>();
  
  practices.forEach(practice => {
    const wordId = practice.wordId;
    
    if (!wordStats.has(wordId)) {
      wordStats.set(wordId, { 
        word: practice.word.word, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = wordStats.get(wordId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив и фильтруем слова с минимум 3 попытками
  const result = Array.from(wordStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.word,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(word => word.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // Сортируем по проценту правильных ответов
  
  return result.slice(0, 5); // Возвращаем топ-5 проблемных слов
}

// Вспомогательная функция для получения ежедневной статистики по паронимам
async function getParonymDailyStats(
  prisma: PrismaClient, 
  userId: number, 
  period?: number
): Promise<DailyStats[]> {
  const periodDays = period || 30; // По умолчанию 30 дней
  const startDate = subDays(new Date(), periodDays);
  
  // Получаем все попытки за указанный период
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
      createdAt: { gte: startDate },
    },
    select: {
      correct: true,
      createdAt: true,
    },
    orderBy: {
      createdAt: 'asc',
    },
  });
  
  // Группируем по дням
  const dailyMap = new Map<string, { total: number; correct: number }>();
  
  practices.forEach(practice => {
    const date = format(practice.createdAt, 'yyyy-MM-dd');
    
    if (!dailyMap.has(date)) {
      dailyMap.set(date, { total: 0, correct: 0 });
    }
    
    const stats = dailyMap.get(date)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив
  const result = Array.from(dailyMap.entries()).map(([date, stats]) => ({
    date,
    total: stats.total,
    correct: stats.correct,
    rate: stats.total > 0 ? stats.correct / stats.total : 0,
  }));
  
  return result.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Вспомогательная функция для получения проблемных пар паронимов
async function getProblemParonyms(
  prisma: PrismaClient, 
  userId: number
): Promise<ProblemWord[]> {
  // Получаем все попытки пользователя для паронимов
  const practices = await prisma.paronymPractice.findMany({
    where: {
      userId,
    },
    include: {
      paronymPair: {
        include: {
          words: true,
        },
      },
    },
  });
  
  // Группируем по парам паронимов и считаем статистику
  const pairStats = new Map<number, { 
    words: string, 
    total: number, 
    correct: number 
  }>();
  
  practices.forEach(practice => {
    const pairId = practice.paronymPairId;
    
    if (!pairStats.has(pairId)) {
      // Формируем строку с паронимами через "/"
      const wordString = practice.paronymPair.words.map(w => w.word).join(' / ');
      
      pairStats.set(pairId, { 
        words: wordString, 
        total: 0, 
        correct: 0 
      });
    }
    
    const stats = pairStats.get(pairId)!;
    stats.total += 1;
    if (practice.correct) {
      stats.correct += 1;
    }
  });
  
  // Преобразуем в массив и фильтруем пары с минимум 3 попытками
  const result = Array.from(pairStats.entries())
    .map(([id, stats]) => ({
      id,
      word: stats.words,
      total: stats.total,
      correct: stats.correct,
    }))
    .filter(pair => pair.total >= 3)
    .sort((a, b) => (a.correct / a.total) - (b.correct / b.total)); // Сортируем по проценту правильных ответов
  
  return result.slice(0, 5); // Возвращаем топ-5 проблемных пар
}
</file>

<file path="backend/src/router/Practice/GetUserStats/input.ts">
import { z } from "zod";

export const zGetUserStats = z.object({
  type: z.enum(["STRESS", "PARONYM"]),
  period: z.number().optional(), // период в днях (7, 30, etc.)
});
</file>

<file path="backend/src/router/Practice/RecordPractice/index.ts">
import { PrismaClient, Practice, User } from "@prisma/client";
import { TRPCError } from "@trpc/server";
import { trpcLoggedProcedure } from "../../../lib/trpc";
import { zRecordPractice } from "./input";

// Определяем типы для результатов
type StressPracticeResult = {
  success: boolean;
  practice: Practice;
};

type ParonymPracticeResult = {
  success: boolean;
  paronymPractice: {
    id: number;
    userId: number;
    paronymPairId: number;
    selectedWordId: number;
    correctWordId: number;
    correct: boolean;
    createdAt: Date;
  };
};

type PracticeResult = StressPracticeResult | ParonymPracticeResult;

export const RecordPracticeTrpcRoute = trpcLoggedProcedure
  .input(zRecordPractice)
  .mutation(async ({ input, ctx }): Promise<PracticeResult> => {
    const user = ctx.me;
    
    if (!user) {
      throw new TRPCError({
        code: "UNAUTHORIZED",
        message: "Необходима авторизация",
      });
    }
    
    // Определяем тип практики по входным данным, если не указан явно
    const practiceType = input.type || 
      (input.wordId ? "STRESS" : input.paronymPairId ? "PARONYM" : undefined);
    
    if (!practiceType) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Не удалось определить тип практики",
      });
    }
    
    try {
      if (practiceType === "STRESS") {
        // Проверяем наличие необходимых полей для практики ударений
        if (!input.wordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Для практики ударений необходимо указать wordId",
          });
        }
        
        // Записываем результат практики ударений
        const practice = await ctx.prisma.practice.create({
          data: {
            userId: user.id,
            wordId: input.wordId,
            correct: input.correct,
          },
        });
        
        // Обновляем счет пользователя
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, practice };
      } 
      else if (practiceType === "PARONYM") {
        // Проверяем наличие необходимых полей для практики паронимов
        if (!input.paronymPairId || !input.selectedWordId || !input.correctWordId) {
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: "Для практики паронимов необходимо указать paronymPairId, selectedWordId и correctWordId",
          });
        }
        
        // Записываем результат практики паронимов
        const paronymPractice = await ctx.prisma.paronymPractice.create({
          data: {
            userId: user.id,
            paronymPairId: input.paronymPairId,
            selectedWordId: input.selectedWordId,
            correctWordId: input.correctWordId,
            correct: input.correct,
          },
        });
        
        // Обновляем счет пользователя
        await updateUserScore(ctx.prisma as any, user.id, input.correct);
        
        return { success: true, paronymPractice };
      }
      
      throw new TRPCError({
        code: "BAD_REQUEST",
        message: "Неподдерживаемый тип практики",
      });
    } catch (error) {
      
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Не удалось записать результат практики",
        cause: error,
      });
    }
  });

// Вспомогательная функция для обновления счета пользователя
async function updateUserScore(
  prisma: PrismaClient, 
  userId: number, 
  correct: boolean
): Promise<User> {
  return prisma.user.update({
    where: { id: userId },
    data: {
      score: {
        increment: correct ? 1 : 0,
      },
    },
  });
}
</file>

<file path="backend/src/scripts/presetDB.ts">
import { PrismaClient, PracticeType } from '@prisma/client';
import rawWords from '../data/words';
import { logger } from '../utils/logger';

const prisma = new PrismaClient();

// Функция для инициализации слов (адаптирована из utils.ts)
function processRawWords(rawWords: string[]): { word: string, accentIdx: number }[] {
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx || -1
    };
  });
}

async function presetDB() {
  logger.info("presetDB", "Starting database preset...");
  
  try {
    // Обработка слов из words.js
    const processedWords = processRawWords(rawWords);
    
    // Фильтрация слов с корректным ударением
    const validWords = processedWords.filter(word => word.accentIdx >= 0 && word.word.length > 0);
    
    logger.info("presetDB", `Processed ${validWords.length} valid words`);

    // Очистка существующих слов типа STRESS (опционально)
    await prisma.word.deleteMany({
      where: {
        type: PracticeType.STRESS
      }
    });
    
    logger.info("presetDB", "Deleted existing stress practice words");
    
    // Добавление слов в базу данных
    const createdWords = await prisma.word.createMany({
      data: validWords.map(word => ({
        word: word.word,
        stress: word.accentIdx,
        type: PracticeType.STRESS
      })),
      skipDuplicates: true
    });
    
    logger.info("presetDB", `Added ${createdWords.count} words to the database`);

    return { success: true, count: createdWords.count };
  } catch (error) {
    logger.error("presetDB", "Error during database preset", error as any);
    return { success: false, error };
  } finally {
    await prisma.$disconnect();
  }
}

// Запуск скрипта, если он вызван напрямую
if (require.main === module) {
  presetDB()
    .then(result => {
      if (result.success) {
        logger.info("presetDB", "Database preset completed successfully!");
        process.exit(0);
      } else {
        logger.error("presetDB", "Database preset failed!", result.error as any);
        process.exit(1);
      }
    })
    .catch(err => {
      logger.error("presetDB", "Unhandled error during database preset", err);   
      process.exit(1);
    });
}

export default presetDB;
</file>

<file path="backend/src/utils/deepMap.ts">
import _ from "lodash";

type ReplaceFn = ({
  path,
  key,
  value,
}: {
  path: string;
  key: string;
  value: Value;
}) => Value;
type Value =
  | Object
  | number
  | string
  | boolean
  | null
  | undefined
  | Function
  | Symbol
  | any[];

const recursion = ({
  input,
  replaceFn,
  seen,
  pathStartsWith,
  parentKey,
}: {
  input: Value;
  replaceFn: ReplaceFn;
  seen: WeakSet<any>;
  pathStartsWith: string;
  parentKey: string;
}): Value => {
  if (
    ["object", "function", "symbol"].includes(typeof input) &&
    input !== null
  ) {
    if (seen.has(input)) {
      return "!!!CIRCULAR!!!";
    } else {
      seen.add(input);
    }
  }
  const result = replaceFn({
    path: pathStartsWith.replace(/\.$/, ""),
    key: parentKey,
    value: input,
  });
  if (!result) {
    return result;
  }
  if (_.isArray(result)) {
    return result.map((item, index) =>
      recursion({
        input: item,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${index}.`,
        parentKey: index.toString(),
      }),
    );
  }
  if (_.isObject(result)) {
    const object: any = {};
    for (const [key, value] of Object.entries(result)) {
      object[key] = recursion({
        input: value,
        replaceFn,
        seen,
        pathStartsWith: `${pathStartsWith}${key}.`,
        parentKey: key,
      });
    }
    return object;
  }
  return result;
};

export const deepMap = <T = Value>(input: Value, replaceFn: ReplaceFn): T => {
  const seen = new WeakSet();
  const mappedObject = recursion({
    input,
    replaceFn,
    seen,
    pathStartsWith: "",
    parentKey: "",
  });
  const clonedMappedObject = _.cloneDeep(mappedObject);
  return clonedMappedObject as T;
};
</file>

<file path="backend/src/utils/env.ts">
import fs from 'fs';
import path from 'path';
import {zEnvNonemptyTrimmed} from '@russian-stress-practice/shared/src/zod'
import * as dotenv from "dotenv";
import { z } from "zod";

const findEnvFilePath = (dir: string): string | null => {
  const maybeEnvFilePath = path.join(dir, '.env')
  if (fs.existsSync(maybeEnvFilePath)) {
    return maybeEnvFilePath
  }
  if (dir === '/') {
    return null
  }
  return findEnvFilePath(path.dirname(dir))
}

const envFilePath = findEnvFilePath(__dirname)
if (envFilePath) {
  dotenv.config({ path: envFilePath })
  dotenv.config({ path: `${envFilePath}.${process.env.NODE_ENV}` })
}

const zEnv = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().min(1),
  HOST_ENV: z.enum(['local', 'production']).default('local'),
  DEBUG: z
  .string()
  .optional()
  .refine(
    (val) => process.env.HOST_ENV === 'local' || process.env.NODE_ENV !== 'production' || (!!val && val.length > 0),
    'Required on not local host on production'
  ),
  FRONTEND_URL: zEnvNonemptyTrimmed,
  JWT_SECRET: zEnvNonemptyTrimmed
});

export const env = zEnv.parse(process.env);
</file>

<file path="backend/src/utils/error.ts">
export class ExpectedError extends Error {
  isExpected = true as const;
}
</file>

<file path="backend/src/utils/logger.ts">
import { env } from "./env";
import { EOL } from "os";
import {omit} from "@russian-stress-practice/shared/src/omit"
import { TRPCError } from "@trpc/server";
import debug from "debug";
import _ from "lodash";
import pc from "picocolors";
import { serializeError } from "serialize-error";
import { MESSAGE } from "triple-beam";
import winston from "winston";
import * as yaml from "yaml";
import { deepMap } from "./deepMap";
import { ExpectedError } from "./error";
// import { sentryCaptureException } from "./sentry";

export const winstonLogger = winston.createLogger({
  level: "debug",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  ),
  defaultMeta: { service: "backend", hostEnv: env.HOST_ENV },
  transports: [
    new winston.transports.Console({
      format:
        env.HOST_ENV !== "local"
          ? winston.format.json()
          : winston.format((logData) => {
              const setColor = {
                info: (str: string) => pc.blue(str),
                error: (str: string) => pc.red(str),
                debug: (str: string) => pc.cyan(str),
              }[logData.level as "info" | "error" | "debug"];
              const levelAndType = `${logData.level} ${logData.logType}`;
              const timestamp =
                typeof logData.timestamp === "string" ? logData.timestamp : "";
              const topMessage = `[${setColor(levelAndType)}] ${pc.green(timestamp)}${EOL}${logData.message}`;

              const visibleMessageTags = omit(logData, [
                "level",
                "logType",
                "timestamp",
                "message",
                "service",
                "hostEnv",
              ]);

              const stringifyedLogData = _.trim(
                yaml.stringify(visibleMessageTags, (_k, v) =>
                  _.isFunction(v) ? "Function" : v,
                ),
              );

              const resultLogData = {
                ...logData,
                [MESSAGE]:
                  [
                    topMessage,
                    Object.keys(visibleMessageTags).length > 0
                      ? `${EOL}${stringifyedLogData}`
                      : "",
                  ]
                    .filter(Boolean)
                    .join("") + EOL,
              };

              return resultLogData;
            })(),
    }),
  ],
});

export type LoggerMetaData = Record<string, any> | undefined;
const prettifyMeta = (meta: LoggerMetaData): LoggerMetaData => {
  return deepMap(meta, ({ key, value }) => {
    if (
      [
        "email",
        "password",
        "newPassword",
        "oldPassword",
        "token",
        "text",
        "description",
      ].includes(key)
    ) {
      return "🙈";
    }
    return value;
  });
};

export const logger = {
  info: (logType: string, message: string, meta?: LoggerMetaData) => {
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    winstonLogger.info(message, { logType, ...prettifyMeta(meta) });
  },
  error: (logType: string, error: any, meta?: LoggerMetaData) => {
    // const isNativeExpectedError = error instanceof ExpectedError
    // const isTrpcExpectedError = error instanceof TRPCError && error.cause instanceof ExpectedError
    const prettifiedMetaData = prettifyMeta(meta)
    // if (!isNativeExpectedError && !isTrpcExpectedError) {
    //   sentryCaptureException(error, prettifiedMetaData)
    // }
    if (!debug.enabled(`russian-stress-practice:${logType}`)) {
      return;
    }
    const serializedError = serializeError(error);
    winstonLogger.error(serializedError.message || "Unknown error", {
      logType,
      error,
      errorStack: serializedError.stack,
      ...prettifiedMetaData,
    });
  },
};
</file>

<file path="backend/src/utils/models.ts">
import type { User } from "@prisma/client";
import {pick} from "@russian-stress-practice/shared/src/pick"

export const toClientMe = (user: User | null) => {
  return user && pick(user, ["id", "name", "email", "score", "provider", "providerId", "accessToken"]);
};
</file>

<file path="backend/src/utils/types.ts">
import { type User } from "@prisma/client";
import { type Request } from "express";

export type ExpressRequest = Request & {
  user: User | undefined;
};
</file>

<file path="backend/tsconfig.json">
{
  "ts-node": {
    "files": true,
    "transpile0nly": true
  },
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "downlevelIteration": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "strict": true,
    "sourceMap": true,
    "resolveJsonModule": true,
    "inlineSources": true,
    "isolatedModules": false,
    "lib": ["ES2021"],
    "module": "commonjs",
    "moduleResolution": "Node",
    "target": "ES2021",
  },
  "include": ["src"]
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import node from "eslint-plugin-node";
import jest from "eslint-plugin-jest";
import path from "node:path";
import { fileURLToPath } from "node:url";
import js from "@eslint/js";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const compat = new FlatCompat({
    baseDirectory: __dirname,
    recommendedConfig: js.configs.recommended,
    allConfig: js.configs.all
});

export default defineConfig([globalIgnores(["**/node_modules", "**/dist", "**/*.config.js"]), {
    extends: compat.extends("standard-with-typescript", "prettier", "plugin:jest/recommended"),

    plugins: {
        node,
        jest,
    },

    rules: {
        "no-new": "off",

        "import/order": ["error", {
            alphabetize: {
                order: "asc",
                caseInsensitive: false,
                orderImportKind: "asc",
            },
        }],

        "@typescript-eslint/consistent-type-definitions": ["error", "type"],
        "@typescript-eslint/strict-boolean-expressions": "off",
        "@typescript-eslint/prefer-nullish-coalescing": "off",
        "@typescript-eslint/explicit-function-return-type": "off",
        "@typescript-eslint/restrict-template-expressions": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/consistent-type-assertions": "off",
        "jsx-a11y/anchor-is-valid": "off",
        curly: ["error", "all"],

        "no-irregular-whitespace": ["error", {
            skipTemplates: true,
            skipStrings: true,
        }],

        "node/no-process-env": "error",

        "no-restricted-syntax": ["error", {
            selector: "[object.type=MetaProperty][property.name=env]",
            message: "Use instead import { env } from \"lib/env\"",
        }],
    },
}]);
</file>

<file path="frontend/.envrc">
use flake
</file>

<file path="frontend/.github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
    push:
        branches: ["main"]
    workflow_dispatch:

permissions:
    contents: read
    pages: write
    id-token: write

concurrency:
    group: "pages"
    cancel-in-progress: false

jobs:
    build:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Setup Node
              uses: actions/setup-node@v4
              with:
                  node-version: "20"
                  cache: "npm"

            - name: Install dependencies
              run: npm ci

            - name: Build
              run: npm run build

            - name: Setup Pages
              uses: actions/configure-pages@v4

            - name: Upload artifact
              uses: actions/upload-pages-artifact@v3
              with:
                  path: "./dist"

    deploy:
        environment:
            name: github-pages
            url: ${{ steps.deployment.outputs.page_url }}
        runs-on: ubuntu-latest
        needs: build
        steps:
            - name: Deploy to GitHub Pages
              id: deployment
              uses: actions/deploy-pages@v4
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="frontend/public/index.js">
// This is a fallback script in case the main bundle fails to load
console.log("Fallback script loaded - if you see this, the main bundle didn't load correctly");
document.addEventListener('DOMContentLoaded', () => {
  const container = document.querySelector('.container');
  if (container) {
    container.innerHTML += '<p style="color:red">Warning: Main application script failed to load properly.</p>';
  }
});
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1997.5 2000" style="enable-background:new 0 0 1997.5 2000" xml:space="preserve"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="498.781" y1="2229.557" x2="1666.593" y2="643.575" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#41d1ff"/><stop offset="1" style="stop-color:#bd34fe"/></linearGradient><path d="m1990.9 296-938.3 1677.9c-19.4 34.6-69.1 34.8-88.8.4L6.8 296.2c-21.4-37.6 10.7-83.1 53.3-75.5l939.3 167.9c6 1.1 12.1 1.1 18.1 0L1937.2 221c42.4-7.8 74.7 37.4 53.7 75z" style="fill:url(#a)"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="1049.466" y1="1988.58" x2="1260.718" y2="539.417" gradientTransform="matrix(1 0 0 -1 0 2010.858)"><stop offset="0" style="stop-color:#ffea83"/><stop offset=".083" style="stop-color:#ffdd35"/><stop offset="1" style="stop-color:#ffa800"/></linearGradient><path d="M1446.9.5 752.5 136.6c-11.4 2.2-19.9 11.9-20.6 23.5l-42.7 721.4c-1 17 14.6 30.2 31.2 26.4l193.3-44.6c18.1-4.2 34.4 11.8 30.7 30L887 1174.4c-3.9 18.9 13.9 35.1 32.4 29.5l119.4-36.3c18.5-5.6 36.3 10.6 32.4 29.6L979.9 1639c-5.7 27.6 31 42.7 46.4 19l10.2-15.8L1602.4 513c9.5-18.9-6.9-40.5-27.6-36.5l-199 38.4c-18.7 3.6-34.6-13.8-29.3-32.1l129.9-450.3c5.2-18.2-10.8-35.7-29.5-32z" style="fill:url(#b)"/></svg>
</file>

<file path="frontend/README.md">
# Russian Stress Practice

A web application to help learners practice Russian word stress. Correctly placing stress in Russian words is crucial for proper pronunciation and understanding.

## Live Demo

Visit the application at: [https://denissud.github.io/russian-stress-practice/](https://denissud.github.io/russian-stress-practice/)

## Features

- Interactive practice of Russian word stress patterns
- Words with stress patterns built into the application
- Immediate feedback on correct and incorrect answers
- Track incorrect words for focused practice
- Toggle between practicing all words or just mistakes
- Responsive design works on desktop and mobile devices

## How to Use

1. When a word appears, click on the vowel where you think the stress belongs
2. Get immediate feedback on your answer
3. See the correct stress pattern highlighted
4. Click "Next Word" to continue practicing
5. Use the sidebar to see your mistakes and switch practice modes

## Local Development

### Prerequisites

- Node.js (version 18 or higher)
- npm, yarn, or pnpm

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/DenisSud/russian-stress-practice.git
   cd russian-stress-practice
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Start the development server:
   ```bash
   npm run dev
   ```

4. Open your browser and navigate to `http://localhost:5173/russian-stress-practice/`

### Building for Production

```bash
npm run build
```

The built files will be in the `dist` directory.

## Deployment

This project is set up to deploy automatically to GitHub Pages using GitHub Actions.

When you push changes to the `main` branch, the GitHub Actions workflow will:
1. Build the application
2. Deploy it to GitHub Pages

The application will be available at: `https://denissud.github.io/russian-stress-practice/`

## Technologies Used

- React
- Vite
- Tailwind CSS
- GitHub Actions (for CI/CD)
- GitHub Pages (for hosting)

## Adding More Words

To add more Russian words to the practice set:

1. Edit the `src/App.jsx` file
2. Add new words to the `rawWords` array with uppercase letters indicating stress
   - Example: `"вОвремя"` (stress on the first 'о')
3. Save, build, and deploy

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgements

- Thanks to all contributors and users who help improve this tool
- Inspired by the need for better Russian pronunciation resources

---

Created by [DenisSud](https://github.com/DenisSud)
</file>

<file path="frontend/src/components/Loader/index.tsx">
import { Bouncy } from "ldrs/react";
import React from "react";
import "ldrs/react/Bouncy.css";
import { JellyTriangle } from 'ldrs/react'
import 'ldrs/react/JellyTriangle.css'


interface LoaderProps {
    size?: string
    speed?: string
    color?: string
}

export const Loader = ({size="45px", speed="1.2s", color="rgb(67, 73, 233)"}: LoaderProps) => {
  return (
    <>
      <JellyTriangle size={size} speed={speed} color={color} />
    </>
  );
};
</file>

<file path="frontend/src/components/Login/index.tsx">
import React, { useEffect } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { Fragment } from "react";
import { useGoogleAuth  } from "../../utils/googleAuth";

interface LoginProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function Login({ isOpen, onClose }: LoginProps) {
  const login = useGoogleAuth();
  const handleGoogleLoginClick = async () => {
    try {
      login();
      onClose();
    } catch (error) {
      console.error('Failed to login with Google:', error);
    }
  };

  const handleYandexLogin = async () => {
    // TODO: Implement Yandex OAuth
    console.log("Yandex login clicked");
  };

  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 backdrop-blur-sm" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <Dialog.Title
                  as="h3"
                  className="text-lg font-medium leading-6 text-gray-900 text-center mb-4"
                >
                  Войти в аккаунт
                </Dialog.Title>

                <div className="mt-4 space-y-3">
                  <button
                    onClick={handleGoogleLoginClick}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://www.google.com/favicon.ico"
                      alt="Google logo"
                    />
                    Войти через Google
                  </button>

                  <button
                    onClick={handleYandexLogin}
                    className="w-full flex items-center justify-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                  >
                    <img
                      className="h-5 w-5 mr-2"
                      src="https://yastatic.net/s3/home-static/_/7c/7ccf30cd11b00c2eb4f79f698da24aa2.png"
                      alt="Yandex logo"
                    />
                    Войти через Яндекс
                  </button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  );
}
</file>

<file path="frontend/src/components/Navigation.tsx">
import React, { useState, useEffect } from "react";
import { Link, useLocation } from "react-router-dom";
import Login from "./Login";
import {
  LogoutIcon,
  ParonymsLogo,
  SignInLogo,
  StressLogo,
  SymbolLogo,
} from "./svg/svgNative";
import { useMe } from "../utils/ctx";
import { useStats } from "../utils/statsContext";
import { GetLogOut, GetParonymsPractice, GetStressPractice, GetPersonalDictionary } from "../utils/routes";

export default function Navigation() {
  const location = useLocation();
  const [isLoginOpen, setIsLoginOpen] = useState(false);
  const me = useMe();
  const { toggleStats } = useStats();

  // Содержимое навигации, которое будет использоваться и вверху, и внизу
  const navigationContent = (
    <>
      <Link
        to={GetStressPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetStressPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <StressLogo />
          <span className="hidden md:inline">Ударения</span>
        </div>
      </Link>
      <Link
        to={GetParonymsPractice()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetParonymsPractice()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <ParonymsLogo />
          <span className="hidden md:inline">Паронимы</span>
        </div>
      </Link>
      <Link
        to={GetPersonalDictionary()}
        className={`px-4 py-2 rounded-lg transition-all duration-200 font-medium focus:outline-none ${
          location.pathname === GetPersonalDictionary()
            ? "bg-indigo-100 text-indigo-700 shadow-sm"
            : "text-slate-600 hover:bg-slate-100 hover:text-indigo-600"
        }`}
      >
        <div className="flex items-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            className="h-5 w-5 mr-2"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
          </svg>
          <span className="hidden md:inline">Личный словарь</span>
        </div>
      </Link>
    </>
  );

  return (
    <>
      {/* Верхняя навигация - видна только на десктопах */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-4 px-6 sticky top-0 z-10 hidden md:block">
        <div className="container mx-auto flex justify-between items-center">
          <div className="text-xl font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            Русский язык: Тренажеры
          </div>
          <div className="flex items-center space-x-2">
            {navigationContent}
            {me ? (
              <div className="flex items-center">
                <div className="px-4 py-2 rounded-lg bg-indigo-100 text-indigo-700 flex items-center">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-5 w-5 mr-2"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                  >
                    <path
                      fillRule="evenodd"
                      d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"
                      clipRule="evenodd"
                    />
                  </svg>
                  {me.name || me.email}
                  <div className="ml-3 p-1 bg-white rounded-lg">
                    <Link to={GetLogOut()}>
                      <button
                        className="px-3 py-1 rounded-md bg-red-100 text-red-700 hover:bg-red-200 transition-colors duration-200 flex items-center"
                      >
                        <LogoutIcon />
                      </button>
                    </Link>
                  </div>
                </div>
              </div>
            ) : (
              <div className="flex">
                <button
                  onClick={() => setIsLoginOpen(true)}
                  className="ml-4 px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition-colors duration-200 flex items-center"
                >
                  <SignInLogo />
                  Войти
                </button>
              </div>
            )}
          </div>
        </div>
      </nav>

      {/* Верхняя мини-навигация для мобильных - только заголовок и кнопка статистики */}
      <nav className="bg-white shadow-sm border-b border-slate-200 text-slate-700 py-3 px-4 sticky top-0 z-10 md:hidden">
        <div className="flex justify-between items-center">
          <div className="text-lg font-bold text-indigo-600 flex items-center">
            <SymbolLogo />
            <span className="ml-1">Тренажеры</span>
          </div>
          <button 
            id="stats-toggle-button"
            onClick={toggleStats}
            className="p-2 rounded-lg bg-slate-100 text-slate-700"
            aria-label="Показать статистику"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
            </svg>
          </button>
        </div>
      </nav>

      {/* Нижняя навигация - видна только на мобильных */}
      <nav className="bg-white shadow-lg border-t border-slate-200 text-slate-700 py-2 px-4 fixed bottom-0 left-0 right-0 z-10 md:hidden">
        <div className="flex justify-around items-center">
          {navigationContent}
          {me ? (
            <Link to={GetLogOut()} className="px-3 py-2 rounded-lg text-red-600">
              <LogoutIcon />
            </Link>
          ) : (
            <button
              onClick={() => setIsLoginOpen(true)}
              className="px-3 py-2 rounded-lg text-indigo-600"
            >
              <SignInLogo />
            </button>
          )}
        </div>
      </nav>

      <Login isOpen={isLoginOpen} onClose={() => setIsLoginOpen(false)} />
    </>
  );
}
</file>

<file path="frontend/src/components/svg/svgNative.tsx">
import React, { SVGProps } from "react";

export const SymbolLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-6 w-6 mr-2"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"
      />
    </svg>
  );
};

export const StressLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"
      />
    </svg>
  );
};

export const ParonymsLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
      />
    </svg>
  );
};

export const SignInLogo = () => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="h-5 w-5 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"
      />
    </svg>
  );
};


export function LogoutIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" {...props}>{/* Icon from Solar by 480 Design - https://creativecommons.org/licenses/by/4.0/ */}<path fill="currentColor" d="M14.945 1.25c-1.367 0-2.47 0-3.337.117c-.9.12-1.658.38-2.26.981c-.524.525-.79 1.17-.929 1.928c-.135.737-.161 1.638-.167 2.72a.75.75 0 0 0 1.5.008c.006-1.093.034-1.868.142-2.457c.105-.566.272-.895.515-1.138c.277-.277.666-.457 1.4-.556c.755-.101 1.756-.103 3.191-.103h1c1.436 0 2.437.002 3.192.103c.734.099 1.122.28 1.4.556c.276.277.456.665.555 1.4c.102.754.103 1.756.103 3.191v8c0 1.435-.001 2.436-.103 3.192c-.099.734-.279 1.122-.556 1.399s-.665.457-1.399.556c-.755.101-1.756.103-3.192.103h-1c-1.435 0-2.436-.002-3.192-.103c-.733-.099-1.122-.28-1.399-.556c-.243-.244-.41-.572-.515-1.138c-.108-.589-.136-1.364-.142-2.457a.75.75 0 1 0-1.5.008c.006 1.082.032 1.983.167 2.72c.14.758.405 1.403.93 1.928c.601.602 1.36.86 2.26.982c.866.116 1.969.116 3.336.116h1.11c1.368 0 2.47 0 3.337-.116c.9-.122 1.658-.38 2.26-.982s.86-1.36.982-2.26c.116-.867.116-1.97.116-3.337v-8.11c0-1.367 0-2.47-.116-3.337c-.121-.9-.38-1.658-.982-2.26s-1.36-.86-2.26-.981c-.867-.117-1.97-.117-3.337-.117z"></path><path fill="currentColor" d="M15 11.25a.75.75 0 0 1 0 1.5H4.027l1.961 1.68a.75.75 0 1 1-.976 1.14l-3.5-3a.75.75 0 0 1 0-1.14l3.5-3a.75.75 0 1 1 .976 1.14l-1.96 1.68z"></path></svg>
  )
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="frontend/src/pages/LogOutPage/index.tsx">
import Cookies from "js-cookie";
import { useEffect } from "react";
import { useNavigate } from "react-router-dom";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { GetStressPractice } from "../../utils/routes";
import React from "react";

export const LogOutPage = () => {
  const navigate = useNavigate();
  const trpcUtils = trpc.useContext();
  useEffect(() => {
    Cookies.remove("token");
    void trpcUtils.invalidate().then(() => {
      navigate(GetStressPractice());
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return <Loader size={"45"} speed={"0.7"} color={"blue"} />;
};
</file>

<file path="frontend/src/pages/ParonymsPage/index.tsx">
import React, { useEffect, useState } from "react";
import { useSearchParams } from "react-router-dom";
import ParonymsInterface from "./ParonymsInterface";
import { useStats } from "../../utils/statsContext";
import trpc from "../../utils/trpc";
import PracticeStats from "../../components/PracticeStats";

export default function ParonymsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const isPersonalDictionary = searchParams.get("personal") === "true";
  const [statsPeriod, setStatsPeriod] = useState<number | undefined>(undefined);
  
  // Получаем функции для управления видимостью статистики
  const { isStatsVisible, toggleStats } = useStats();

  // Получаем паронимы
  const { data: paronymsData, isLoading: isParonymsLoading } = trpc.GetParonyms.useQuery(
    undefined,
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // Получаем статистику
  const { data: statsData, isLoading: isStatsLoading, refetch: refetchStats } = trpc.GetUserStats.useQuery(
    { type: "PARONYM", period: statsPeriod },
    {
      refetchOnWindowFocus: false,
      staleTime: 5 * 60 * 1000,
    }
  );

  // Обработчик записи практики
  const recordPracticeMutation = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // Обновляем статистику после успешной записи практики
      refetchStats();
    },
  });

  // Обработчик ответа пользователя
  const handleRecordPractice = async (paronymId: number, selectedWord: string, isCorrect: boolean) => {
    try {
      await recordPracticeMutation.mutateAsync({
        type: "PARONYM",
        wordId: paronymId,
        correct: isCorrect,
      });
    } catch (error) {
      console.error("Failed to record practice:", error);
    }
  };

  // Обработчик изменения периода статистики
  const handlePeriodChange = (period?: number) => {
    setStatsPeriod(period);
  };

  // Обработчик переключения между личным словарем и общим списком
  const togglePersonalDictionary = () => {
    setSearchParams({ personal: (!isPersonalDictionary).toString() });
  };

  // Подключаем обработчик клика по кнопке статистики
  useEffect(() => {
    const statsButton = document.getElementById('stats-toggle-button');
    if (statsButton) {
      statsButton.addEventListener('click', toggleStats);
    }
    
    return () => {
      if (statsButton) {
        statsButton.removeEventListener('click', toggleStats);
      }
    };
  }, [toggleStats]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* Мобильная статистика - показывается только когда isStatsVisible=true */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">Статистика</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="PARONYM"
            period={statsPeriod}
            onPeriodChange={handlePeriodChange}
          />
        </div>
      )}
      
      {/* Main content - показывается всегда на десктопе и когда статистика скрыта на мобильных */}
      <div className={isStatsVisible ? 'hidden md:block' : ''}>
        <ParonymsInterface
          paronymGroups={paronymsData?.paronyms || []}
          isLoading={isParonymsLoading}
          statsPeriod={statsPeriod}
          setStatsPeriod={handlePeriodChange}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/StressPracticePage/index.tsx">
import React, { useState, useEffect, useMemo } from "react";
import { Word, UserStats, UserStatsParams } from "../../types/nodes";
import {
  initializeWords,
  updateWord,
  getDueWords,
  computeNextReview,
  addDays,
  shuffleArray,
} from "../../utils/utils";
import trpc from "../../utils/trpc";
import { Loader } from "../../components/Loader";
import { PracticeType } from '../../types/practice';
import { useLocation, useNavigate } from "react-router-dom";
import StressPracticeInterface from "./StressPracticeInterface";
import { useStats } from "../../utils/statsContext";
import PracticeStats from "../../components/PracticeStats";

const vowels = ["а", "е", "ё", "и", "о", "у", "ы", "э", "ю", "я"];

// Calculate streak from history
const calculateStreak = (history: { correct: boolean; date: Date }[]) => {
  let streak = 0;
  // Count consecutive correct answers from most recent
  for (let i = 0; i < history.length; i++) {
    if (history[i].correct) {
      streak++;
    } else {
      break;
    }
  }
  return streak;
};

// Calculate wrong count from history
const calculateWrongCount = (history: { correct: boolean; date: Date }[]) => {
  return history.filter(h => !h.correct).length;
};

export default function StressPracticePage() {
  const location = useLocation();
  const navigate = useNavigate();
  
  // Определяем, загружаем ли мы слова из личного словаря
  const params = new URLSearchParams(location.search);
  const isPersonalDictionary = params.get("source") === "dictionary";
  
  // Today's date for scheduling
  const today = useMemo(() => new Date(), []);

  // State for all words with learning metadata
  const [words, setWords] = useState<Word[]>([]);

  // Loading state
  const [isLoadingState, setisLoadingState] = useState(true);
  
  // Параметры для запроса статистики
  const [statsParams, setStatsParams] = useState<UserStatsParams>({
    type: "STRESS",
    period: undefined // По умолчанию без ограничения по времени
  });
  
  // Получаем функции для управления видимостью статистики
  const { isStatsVisible, toggleStats } = useStats();
  
  // Запрос статистики с бэкенда
  const { 
    data: stats, 
    isLoading: isStatsLoading, 
    refetch: refetchStats 
  } = trpc.GetUserStats.useQuery(statsParams, {
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000,
  });

  // Заменяем получение слов на запрос к бэкенду
  const { 
    data: fetchedWords, 
    isLoading: loadingWords 
  } = isPersonalDictionary
    ? trpc.GetPersonalDictionary.useQuery(
        { type: PracticeType.STRESS }, 
        { 
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch dictionary words:", error);
            setisLoadingState(false);
          }
        }
      )
    : trpc.GetPracticeWords.useQuery(
        { type: "STRESS" },
        {
          enabled: true,
          onError: (error) => {
            console.error("Failed to fetch practice words:", error);
            setisLoadingState(false);
          }
        }
      );

  // Record practice attempt
  const recordPractice = trpc.RecordPractice.useMutation({
    onSuccess: () => {
      // Обновляем статистику после успешной записи практики
      refetchStats();
    },
  });

  // Функция для изменения периода статистики
  const changeStatsPeriod = (period?: number) => {
    setStatsParams(prev => ({
      ...prev,
      period
    }));
  };

  // Обработчик записи практики
  const handleRecordPractice = (wordId: number, correct: boolean) => {
    recordPractice.mutate({
      type: "STRESS",
      wordId: wordId,
      correct: correct
    });
  };

  // Подключаем обработчик клика по кнопке статистики
  useEffect(() => {
    const statsButton = document.getElementById('stats-toggle-button');
    if (statsButton) {
      statsButton.addEventListener('click', toggleStats);
    }
    
    return () => {
      if (statsButton) {
        statsButton.removeEventListener('click', toggleStats);
      }
    };
  }, [toggleStats]);

  // Initialize words with learning metadata when fetched
  useEffect(() => {
    if (fetchedWords) {
      // Transform the fetched data to match the expected format
      const initializedWords = isPersonalDictionary
        ? (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }))
        : (fetchedWords.words ?? []).map(word => ({
            id: word.id,
            word: word.word,
            accentIdx: word.accentIdx,
            correctStreak: calculateStreak(word.history || []),
            wrongCount: calculateWrongCount(word.history || []),
            nextReview: word.history && word.history.length > 0 
              ? computeNextReview(calculateStreak(word.history), today)
              : today,
            retired: calculateStreak(word.history || []) >= 4,
          }));
      setWords(initializedWords);
      setisLoadingState(false);
    }
  }, [fetchedWords, today, isPersonalDictionary]);

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* Мобильная статистика - показывается только когда isStatsVisible=true на мобильных */}
      {isStatsVisible && (
        <div className="md:hidden w-full p-4 bg-white fixed top-0 left-0 right-0 bottom-0 z-50 overflow-y-auto">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold text-slate-800">Статистика</h2>
            <button 
              onClick={toggleStats}
              className="p-2 rounded-lg bg-slate-100 text-slate-700"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <PracticeStats
            type="STRESS"
            period={statsParams.period}
            onPeriodChange={changeStatsPeriod}
          />
        </div>
      )}
      
      {/* Main content - всегда показывается, но может быть перекрыт статистикой на мобильных */}
      <div>
        <StressPracticeInterface
          words={words}
          isLoading={isLoadingState || loadingWords}
          statsParams={statsParams}
          changeStatsPeriod={changeStatsPeriod}
          recordPractice={handleRecordPractice}
          isPersonalDictionary={isPersonalDictionary}
          stats={stats as unknown as UserStats}
          isStatsLoading={isStatsLoading}
          vowels={vowels}
          today={today}
          setWords={setWords}
        />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/types/nodes.ts">
export interface Word {
  id?: number;
  word: string;
  accentIdx: number;
  retired?: boolean;
  correctStreak: number;
  wrongCount: number;
  nextReview: Date;
}

export interface PracticeHistory {
  correct: boolean;
  date: Date;
}

export interface UserStatsSummary {
  totalAttempts: number;
  correctAttempts: number;
  correctRate: number;
  recentStats?: {
    totalAttempts: number;
    correctAttempts: number;
  };
}

export interface DailyStats {
  date: string;
  total: number;
  correct: number;
  rate: number;
}

export interface ProblemWord {
  word: string;
  total: number;
  correct: number;
  type: string;
}

export interface UserStats {
  summary: UserStatsSummary;
  dailyStats: DailyStats[];
  problemWords: ProblemWord[];
}

export interface UserStatsParams {
  type: 'STRESS' | 'PARONYM';
  period?: number;
}

export interface Paronym {
  word: string;
  explanation: string;
  id: number
}

export interface ParonymGroup {
  id: number;
  group: string[];
  paronyms: Paronym[];
}
</file>

<file path="frontend/src/types/types.d.ts">
declare module '*.css'
</file>

<file path="frontend/src/utils/ctx.tsx">
import type { TrpcRouterOutput } from "@russian-stress-practice/backend/src/router";
import React, { createContext, useContext } from "react";
import trpc from "./trpc";
import { Loader } from "../components/Loader";

export type AppContext = {
  me: TrpcRouterOutput["GetMe"]["me"];
};

const AppReactContext = createContext<AppContext>({
  me: null,
});

export const AppContextProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const { data, error, isLoading, isFetching, isError } = trpc.GetMe.useQuery();
  return (
    <AppReactContext.Provider
      value={{
        me: data?.me || null,
      }}
    >
      {isLoading || isFetching ? (
        <Loader size="45px" speed="1.2s" color="rgb(67, 73, 233)" />
      ) : isError ? (
        <p>Error: {error?.message}</p>
      ) : (
        children
      )}
    </AppReactContext.Provider>
  );
};

export const useAppContext = () => {
  return useContext(AppReactContext);
};

export const useMe = () => {
  const { me } = useAppContext();
  return me;
};
</file>

<file path="frontend/src/utils/env.ts">
import { z } from "zod";
import zEnvNonemptyTrimmed, {zEnvHost} from '@russian-stress-practice/shared/src/zod'
 
export const zEnv = z.object({
  VITE_BACKEND_TRPC_URL: zEnvNonemptyTrimmed,
  VITE_WEBAPP_URL: zEnvNonemptyTrimmed,
  HOST_ENV: zEnvHost,
  VITE_GOOGLE_CLIENT_ID: zEnvNonemptyTrimmed,
  VITE_GOOGLE_REDIRECT_URI: zEnvNonemptyTrimmed,
  NODE_ENV: z.enum(["development", "production"]),
});

// eslint-disable-next-line no-restricted-syntax
export const env = zEnv.parse(process.env);
</file>

<file path="frontend/src/utils/googleAuth.ts">
import { useGoogleLogin } from '@react-oauth/google';
import trpc from '../utils/trpc';
import { useQueryClient } from '@tanstack/react-query';
import Cookies from 'js-cookie';

interface GoogleCredentials {
  email: string;
  name?: string;
  providerId: string;
  accessToken: string;
  refreshToken?: string;
  tokenExpires?: string;
}

/**
 * Кастомный хук для Google OAuth: переводим хук мутации наружу
 */
export function useGoogleAuth() {
  const { mutateAsync } = trpc.GetAuth.useMutation();
  const queryClient = useQueryClient();

  return useGoogleLogin({
    flow: 'implicit',
    scope: 'openid email profile',
    onSuccess: async (tokenResponse) => {
      try {
        const userInfo = await fetch(
          'https://www.googleapis.com/oauth2/v3/userinfo',
          { 
            headers: { Authorization: `Bearer ${tokenResponse.access_token}` },
            mode: 'cors'
          }
        ).then(res => res.json());

        const creds: GoogleCredentials = {
          email: userInfo.email,
          name: userInfo.name,
          providerId: userInfo.sub,
          accessToken: tokenResponse.access_token,
          refreshToken: tokenResponse.access_token,
          tokenExpires: new Date(Date.now() + tokenResponse.expires_in * 1000).toISOString(),
        };

        const result = await mutateAsync({
          provider: 'GOOGLE',
          credentials: creds,
        });
        
        console.log('Authentication result:', result);
        
        // Сохраняем JWT токен, полученный от нашего бэкенда
        if (result.token) {
          Cookies.set('token', result.token);
          console.log('Token saved to cookies:', result.token.substring(0, 20) + '...');
        } else {
          console.error('No token received from backend');
        }
        
        queryClient.invalidateQueries(['GetMe']);
        window.location.reload()
      } catch (error) {
        console.error('Ошибка Google OAuth:', error);
      }
    },
    onError: (error) => {
      console.error('Не удалось войти через Google:', error);
    },
  });
}
</file>

<file path="frontend/src/utils/pumpGetRoute.ts">
import { useParams as useReactRouterParams } from "react-router-dom";

const baseUrl = process.env.VITE_WEBAPP_URL || process.env.WEBAPP_URL;

type PumpedGetRouteInputBase = {
  abs?: boolean;
};

function pumpGetRoute<T extends Record<string, boolean>>(
  routeParamsDefinition: T,
  getRoute: (routeParams: Record<keyof T, string>) => string,
): {
  (routeParams: Record<keyof T, string> & PumpedGetRouteInputBase): string;
  placeholders: Record<keyof T, string>;
  useParams: () => Record<keyof T, string>;
  definition: string;
};

function pumpGetRoute(getRoute: () => string): {
  (routeParams?: PumpedGetRouteInputBase): string;
  placeholders: {};
  useParams: () => {};
  definition: string;
};

function pumpGetRoute(routeParamsOrGetRoute?: any, maybeGetRoute?: any) {
  const routeParamsDefinition =
    typeof routeParamsOrGetRoute === "function" ? {} : routeParamsOrGetRoute;
  const getRoute =
    typeof routeParamsOrGetRoute === "function"
      ? routeParamsOrGetRoute
      : maybeGetRoute;
  const placeholders = Object.keys(routeParamsDefinition).reduce(
    (acc, key) => ({ ...acc, [key]: `:${key}` }),
    {},
  );
  const definition = getRoute(placeholders);
  const pumpedGetRoute = (routeParams?: PumpedGetRouteInputBase) => {
    const route = getRoute(routeParams);
    if (routeParams?.abs) {
      return `${baseUrl}${route}`;
    } else {
      return route;
    }
  };
  pumpedGetRoute.placeholders = placeholders;
  pumpedGetRoute.definition = definition;
  pumpedGetRoute.useParams = useReactRouterParams as any;
  return pumpedGetRoute;
}

export type RouteParams<T extends { placeholders: Record<string, string> }> =
  T["placeholders"];

export const pgr = pumpGetRoute;
</file>

<file path="frontend/src/utils/routes.ts">
import { pgr } from "./pumpGetRoute";

export const GetStressPractice = pgr(() => "/");
export const GetParonymsPractice = pgr(() => "/paronyms");
export const GetLogOut = pgr(() => "/logout");
export const GetPersonalDictionary = () => "/personal-dictionary";
</file>

<file path="frontend/src/utils/trpc.tsx">
import { env } from "./env";
import React from 'react'
import { createTRPCReact } from "@trpc/react-query";
import type { TrpcRouter } from "@russian-stress-practice/backend/src/router";
import Cookies from "js-cookie";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { httpBatchLink, loggerLink } from "@trpc/react-query";
import { SuperJSON } from "superjson";

const trpc = createTRPCReact<TrpcRouter>();

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: false,
    },
  },
});

const trpcClient = trpc.createClient({
  transformer: SuperJSON,
  links: [
    loggerLink({
      enabled: () => env.NODE_ENV === 'development'
    }),
    httpBatchLink({
      url: env.VITE_BACKEND_TRPC_URL,
      headers: () => {
        const token = Cookies.get('token');
        console.log('Using token for request:', token ? 'Token exists' : 'No token');
        return {
          ...(token && { Authorization: `Bearer ${token}` })
        };
      },
      fetch: (url, options) => {
        console.log('Making TRPC request to:', url);
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});

export const TrpcProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
};

export default trpc;
</file>

<file path="frontend/src/utils/utils.ts">
// Define interfaces for better type safety
import {Word} from "../types/nodes"

// Date utility functions
export function addDays(d: Date, n: number): Date {
  const newDate = new Date(d);
  newDate.setDate(d.getDate() + n);
  return newDate;
}

// Compute next review date based on streak
export function computeNextReview(streak: number, today: Date = new Date()): Date {
  if (streak <= 1) return addDays(today, 1);
  if (streak === 2) return addDays(today, 3);
  if (streak === 3) return addDays(today, 7);
  return addDays(today, 14);
}

// Initialize words with learning metadata
export function initializeWords(rawWords: string[]): Word[] {
  const today = new Date();
  
  return rawWords.map(raw => {
    let base = '';
    let accentIdx: number | null = null;
    
    if (typeof raw !== 'string') return { 
      word: '', 
      accentIdx: -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };

    for (let i = 0; i < raw.length; i++) {
      const char = raw[i];
      if (typeof char !== 'string') continue;

      if (char === char.toUpperCase() && char !== char.toLowerCase()) {
        accentIdx = base.length;
        base += char.toLowerCase();
      } else {
        base += char;
      }
    }
    
    return { 
      word: base, 
      accentIdx: accentIdx !== null ? accentIdx : -1,
      correctStreak: 0,
      wrongCount: 0,
      nextReview: today,
      retired: false
    };
  });
}

// Helper to update a specific word in the words array
export function updateWord(words: Word[], targetWord: Word, updateFn: (word: Word) => void): Word[] {
  console.log("Updating word:", targetWord.word);
  
  return words.map(word => {
    if (word.id === targetWord.id) {
      // Create a copy of the word
      const updatedWord = { ...word };
      // Apply the update function
      updateFn(updatedWord);
      console.log("Word updated:", updatedWord);
      return updatedWord;
    }
    return word;
  });
}

// Get words that are due for review today
export function getDueWords(words: Word[], today: Date): Word[] {
  console.log("Getting due words from", words.length, "total words");
  console.log("Today's date:", today);
  
  // Если список слов пуст, возвращаем пустой массив
  if (!words || words.length === 0) {
    console.log("Words list is empty");
    return [];
  }
  
  // Фильтруем слова, которые нужно повторить сегодня
  const dueWords = words.filter(word => {
    // Проверяем, что nextReview - это действительно дата
    if (!(word.nextReview instanceof Date)) {
      console.log("Invalid nextReview date for word:", word);
      return true; // Если дата некорректна, считаем слово доступным для практики
    }
    
    const isDue = !word.retired && word.nextReview <= today;
    if (!isDue) {
      console.log("Word not due:", word.word, "nextReview:", word.nextReview, "today:", today);
    }
    
    return isDue;
  });
  
  console.log("Found", dueWords.length, "due words");
  return dueWords;
}

export const shuffleArray = (array: any[]) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// Форматирование даты для отображения
export function formatDate(date: Date): string {
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(today.getDate() + 1);
  
  // Сравниваем только даты без времени
  const isToday = date.toDateString() === today.toDateString();
  const isTomorrow = date.toDateString() === tomorrow.toDateString();
  
  if (isToday) {
    return "Сегодня";
  } else if (isTomorrow) {
    return "Завтра";
  } else {
    // Форматируем дату как "ДД.ММ.ГГГГ"
    return date.toLocaleDateString('ru-RU', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    });
  }
}

// Форматирование короткой даты для графиков
export function formatShortDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('ru-RU', {
    day: 'numeric',
    month: 'numeric'
  });
}
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="jest.config.cjs">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    passWithNoTests: true,
    verbose: true,
    prettierPath: null,
  }
</file>

<file path="rupractice.session.sql">
SELECT * FROM "User"
</file>

<file path="russian-practice dev.session.sql">
SELECT * FROM "Word"
</file>

<file path="shared/.lintstagedrc.yml">
"*.{ts,tsx,js}":
  - eslint --cache --cache-location ./node_modules/.cache/.eslintcache --fix
  - prettier --loglevel warn --cache --write
"*.{json,yml,scss}": prettier --loglevel warn --cache --write
</file>

<file path="shared/jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    ...require('../jest.config.js'),
  }
</file>

<file path="shared/package.json">
{
  "name": "@russian-stress-practice/shared",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache --ext .ts .",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "test": "jest"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/lodash": "^4.17.15"
  }
}
</file>

<file path="shared/src/getKeysAsArray.ts">
import lodashKeys from 'lodash/keys'

// https://catchts.com/union-array
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never
type UnionToOvlds<U> = UnionToIntersection<U extends any ? (f: U) => void : never>
type PopUnion<U> = UnionToOvlds<U> extends (a: infer A) => void ? A : never
type IsUnion<T> = [T] extends [UnionToIntersection<T>] ? false : true
type UnionToArray<T, A extends unknown[] = []> = IsUnion<T> extends true
  ? UnionToArray<Exclude<T, PopUnion<T>>, [PopUnion<T>, ...A]>
  : [T, ...A]

export const getKeysAsArray = <T>(obj: T): UnionToArray<keyof T> => {
  return lodashKeys(obj) as UnionToArray<keyof T>
}
</file>

<file path="shared/src/omit.ts">
import lodashOmit from 'lodash/omit'

export const omit = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Omit<TObject, TKeys> => {
  return lodashOmit(obj, keys)
}
</file>

<file path="shared/src/pick.ts">
import lodashPick from 'lodash/pick'

export const pick = <TObject extends Object, TKeys extends keyof TObject>(
  obj: TObject,
  keys: TKeys[]
): Pick<TObject, TKeys> => {
  return lodashPick(obj, keys)
}
</file>

<file path="shared/src/tryCatch.ts">
type Success<T> = {
    data: T;
    error: null;
  };
  
  type Failure<E> = {
    data: null;
    error: E;
  };
  
  type Result<T, E = Error> = Success<T> | Failure<E>;
  
  export async function tryCatch<T, E = Error>(
    promise: Promise<T>,
  ): Promise<Result<T, E>> {
    try {
      const data = await promise;
      return { data, error: null };
    } catch (error) {
      return { data: null, error: error as E };
    }
}
</file>

<file path="shared/src/zod.ts">
import { z } from "zod";

export const zEnvNonemptyTrimmed = z.string().trim().min(1);
export default zEnvNonemptyTrimmed;
export const zEnvNonemptyTrimmedRequiredOnNotLocal = zEnvNonemptyTrimmed
  .optional()
  .refine(
    // eslint-disable-next-line node/no-process-env
    (val) => `${process.env.HOST_ENV}` === "local" || !!val,
    "Required on not local host",
  );
export const zEnvHost = z.enum(["local", "production"]);

export const zStringRequired = z
  .string({ required_error: "Please, fill it" })
  .min(1, "Please, fill it");
export const zStringOptional = z.string().optional();
export const zEmailRequired = zStringRequired.email();
export const zNickRequired = zStringRequired.regex(
  /^[a-z0-9-]+$/,
  "Nick may contain only lowercase letters, numbers and dashes",
);
export const zStringMin = (min: number) =>
  zStringRequired.min(min, `Text should be at least ${min} characters long`);
export const zPasswordsMustBeTheSame =
  (passwordFieldName: string, passwordAgainFieldName: string) =>
  (val: any, ctx: z.RefinementCtx) => {
    if (val[passwordFieldName] !== val[passwordAgainFieldName]) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Passwords must be the same",
        path: [passwordAgainFieldName],
      });
    }
  };
</file>

<file path="shared/tsconfig.json">
{
  "extends": "../backend/tsconfig.json",
  "include": ["src"]
}
</file>

<file path="backend/package.json">
{
  "name": "@russian-stress-practice/backend",
  "version": "0.0.0",
  "private": "true",
  "devDependencies": {
    "@sentry/cli": "^2.43.0",
    "@types/cors": "^2.8.17",
    "@types/debug": "^4.1.12",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/lodash": "^4.17.15",
    "@types/node": "^22.10.7",
    "@types/passport": "^1.0.17",
    "@types/passport-jwt": "^4.0.1",
    "@types/triple-beam": "^1.3.5",
    "@typescript-eslint/eslint-plugin": "^8.26.1",
    "@typescript-eslint/parser": "^8.26.1",
    "dotenv-cli": "^8.0.0",
    "eslint-plugin-import": "^2.31.0",
    "prisma": "^6.6.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0"
  },
  "scripts": {
    "dev": "ts-node-dev --rs --exit-child ./src/index.ts",
    "build-ts": "rimraf ./dist && tsc --build ./tsconfig.build.json",
    "build": "pnpm build-emails && pnpm build-ts && pnpm copy-emails",
    "start": "cross-env NODE_ENV=production node ./dist/backend/src/index.js",
    "types": "tsc --noEmit --project ./tsconfig.json",
    "lint": "eslint --cache --cache-location ./node_modules/.cache/.eslintcache .",
    "pmd": "prisma migrate dev",
    "pmt": "dotenv -e ./.env.test prisma migrate deploy",
    "pgc": "prisma generate",
    "test": "jest --runInBand",
    "prettify": "prettier --loglevel warn --cache --write '{src/**/*,*}.{ts,tsx,js,json,yml,scss}' '!**/{node_modules,dist}/**/*'",
    "prepare": "pnpm pgc && ts-patch install -s",
    "preset-db": "ts-node src/scripts/presetDB.ts",
    "preset-paronyms": "ts-node src/scripts/importParonyms.ts"
  },
  "prisma": {
    "schema": "./src/prisma/schema.prisma"
  },
  "dependencies": {
    "@prisma/client": "^6.6.0",
    "@russian-stress-practice/frontend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@trpc/server": "^10.45.2",
    "axios": "^1.8.4",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "cron": "^4.1.3",
    "date-fns": "^4.1.0",
    "debug": "^4.4.0",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "fast-glob": "^3.3.3",
    "handlebars": "^4.7.8",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "picocolors": "^1.1.1",
    "randomstring": "^1.3.1",
    "serialize-error": "^8.1.0",
    "superjson": "1.13.1",
    "triple-beam": "^1.4.1",
    "trpc-playground": "^1.0.4",
    "winston": "^3.17.0",
    "yaml": "^2.7.1",
    "zod": "^3.24.2"
  }
}
</file>

<file path="backend/src/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  name          String?
  score         Int       @default(0)
  provider      Provider  
  providerId    String    
  accessToken   String? 
  refreshToken  String?  
  tokenExpires  DateTime?
  practices     Practice[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  personalWords PersonalWord[] // Связь с личным словариком слов
  personalParonyms PersonalParonym[] // Связь с личным словариком паронимов

  @@unique([provider, providerId])
  ParonymPractice ParonymPractice[]
}

enum Provider {
  GOOGLE
  YANDEX
}

model Word {
  id          Int        @id @default(autoincrement())
  word        String
  stress      Int        // Позиция ударения
  description String?    // Описание слова (для паронимов)
  practices   Practice[]
  type        PracticeType @default(STRESS)
  paronymPairs ParonymPair[] @relation("ParonymWords")
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  personalWords PersonalWord[] // Связь с личным словариком
}

enum PracticeType {
  STRESS   
  PARONYM  
}

model Practice {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  correct   Boolean
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([wordId])
}

model ParonymPair {
  id          Int      @id @default(autoincrement())
  words       Word[]   @relation("ParonymWords")
  description String?  // Описание различия между паронимами
  practices   ParonymPractice[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  personalParonyms PersonalParonym[] // Связь с личным словариком
}

model ParonymPractice {
  id           Int         @id @default(autoincrement())
  user         User        @relation(fields: [userId], references: [id])
  userId       Int
  paronymPair  ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  selectedWordId Int       // ID выбранного слова
  correctWordId Int        // ID правильного слова
  correct      Boolean     // Правильно ли выбрано слово
  createdAt    DateTime    @default(now())

  @@index([userId])
  @@index([paronymPairId])
}

// Модель для личного словарика слов
model PersonalWord {
  id        Int      @id @default(autoincrement())
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  word      Word     @relation(fields: [wordId], references: [id])
  wordId    Int
  createdAt DateTime @default(now())

  @@unique([userId, wordId]) // Уникальный индекс для пары пользователь-слово
  @@index([userId])
  @@index([wordId])
}

// Модель для личного словарика паронимов
model PersonalParonym {
  id            Int         @id @default(autoincrement())
  user          User        @relation(fields: [userId], references: [id])
  userId        Int
  paronymPair   ParonymPair @relation(fields: [paronymPairId], references: [id])
  paronymPairId Int
  createdAt     DateTime    @default(now())

  @@unique([userId, paronymPairId]) // Уникальный индекс для пары пользователь-пароним
  @@index([userId])
  @@index([paronymPairId])
}
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Тренажер ударений</title>
    <meta
      http-equiv="Cross-Origin-Opener-Policy"
      content="same-origin-allow-popups"
    />
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none" />
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/App.tsx">
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import StressPracticePage from './pages/StressPracticePage';
import ParonymsPage from './pages/ParonymsPage';
import PersonalDictionaryPage from './pages/PersonalDictionaryPage';
import { TrpcProvider } from './utils/trpc';
import { AppContextProvider } from './utils/ctx';
import { StatsProvider } from './utils/statsContext';
import { GetLogOut, GetParonymsPractice, GetPersonalDictionary, GetStressPractice } from './utils/routes';
import { LogOutPage } from './pages/LogOutPage';
import Navigation from './components/Navigation';

export default function App() {
  return (
    <TrpcProvider>
      <AppContextProvider>
        <StatsProvider>
          <Router basename="/russian-stress-practice">
            <div className="flex flex-col min-h-screen">
              <Navigation />
              <div className="flex-grow pb-16 md:pb-0"> {/* Добавляем отступ снизу для мобильной навигации */}
                <Routes>
                  <Route path={GetStressPractice()} element={<StressPracticePage />} />
                  <Route path={GetParonymsPractice()} element={<ParonymsPage />} />
                  <Route path={GetPersonalDictionary()} element={<PersonalDictionaryPage />} />
                  <Route path={GetLogOut()} element={<LogOutPage />} />
                  <Route path="*" element={<div>404</div>} />
                </Routes>
              </div>
            </div>
          </Router>
        </StatsProvider>
      </AppContextProvider>
    </TrpcProvider>
  );
}
</file>

<file path="frontend/src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { GoogleOAuthProvider } from "@react-oauth/google";
import { env } from "./utils/env";
import "./index.css";

const rootElement = document.getElementById("root");
if (rootElement) {
  ReactDOM.createRoot(rootElement).render(
    <GoogleOAuthProvider clientId={env.VITE_GOOGLE_CLIENT_ID}>
      <React.StrictMode>
        <App />
      </React.StrictMode>
    </GoogleOAuthProvider>
  );
} else {
  console.error("Root element not found");
}
</file>

<file path="frontend/src/utils.test.js">
import { addDays, computeNextReview, initializeWords, updateWord, getDueWords } from './utils/utils';

// Test addDays function
describe('addDays', () => {
  test('adds the correct number of days to a date', () => {
    const baseDate = new Date(2023, 0, 1); // January 1, 2023
    
    // Add 1 day
    expect(addDays(baseDate, 1).getDate()).toBe(2);
    
    // Add 7 days
    expect(addDays(baseDate, 7).getDate()).toBe(8);
    
    // Add 30 days (crossing month boundary)
    expect(addDays(baseDate, 30).getDate()).toBe(31);
    expect(addDays(baseDate, 30).getMonth()).toBe(0); // Still January
    
    // Add 31 days (crossing month boundary)
    expect(addDays(baseDate, 31).getDate()).toBe(1);
    expect(addDays(baseDate, 31).getMonth()).toBe(1); // February
  });
});

// Test computeNextReview function
describe('computeNextReview', () => {
  test('returns correct intervals based on streak', () => {
    const today = new Date(2023, 0, 1); // January 1, 2023
    
    // Streak 0 or 1 -> next day
    expect(computeNextReview(0, today).getDate()).toBe(2); // Jan 2
    expect(computeNextReview(1, today).getDate()).toBe(2); // Jan 2
    
    // Streak 2 -> 3 days later
    expect(computeNextReview(2, today).getDate()).toBe(4); // Jan 4
    
    // Streak 3 -> 7 days later
    expect(computeNextReview(3, today).getDate()).toBe(8); // Jan 8
    
    // Streak 4+ -> 14 days later
    expect(computeNextReview(4, today).getDate()).toBe(15); // Jan 15
    expect(computeNextReview(5, today).getDate()).toBe(15); // Jan 15
  });
});

// Test initializeWords function
describe('initializeWords', () => {
  test('correctly initializes words with metadata', () => {
    const rawWords = ["тЕст", "примЕр"];
    const today = new Date();
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].accentIdx).toBe(1);
    expect(result[0].correctStreak).toBe(0);
    expect(result[0].wrongCount).toBe(0);
    expect(result[0].retired).toBe(false);
    expect(result[0].nextReview instanceof Date).toBe(true);
    
    expect(result[1].word).toBe("пример");
    expect(result[1].accentIdx).toBe(4);
  });
  
  test('handles invalid inputs', () => {
    const rawWords = [null, undefined, 123];
    
    const result = initializeWords(rawWords);
    
    expect(result.length).toBe(3);
    expect(result[0].word).toBe("");
    expect(result[0].accentIdx).toBe(null);
    expect(result[0].correctStreak).toBe(0);
  });
});

// Test updateWord function
describe('updateWord', () => {
  test('updates the correct word in the array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 },
      { word: "пример", accentIdx: 4, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(result.length).toBe(2);
    expect(result[0].word).toBe("тест");
    expect(result[0].correctStreak).toBe(1);
    expect(result[1].correctStreak).toBe(0);
  });
  
  test('does not modify the original array', () => {
    const words = [
      { word: "тест", accentIdx: 1, correctStreak: 0 }
    ];
    
    const targetWord = { word: "тест", accentIdx: 1 };
    
    const result = updateWord(words, targetWord, w => {
      w.correctStreak = 1;
    });
    
    expect(words[0].correctStreak).toBe(0);
    expect(result[0].correctStreak).toBe(1);
  });
});

// Test getDueWords function
describe('getDueWords', () => {
  test('returns only words that are due and not retired', () => {
    const today = new Date(2023, 0, 1);
    const yesterday = new Date(2022, 11, 31);
    const tomorrow = new Date(2023, 0, 2);
    
    const words = [
      { word: "тест1", nextReview: yesterday, retired: false },
      { word: "тест2", nextReview: today, retired: false },
      { word: "тест3", nextReview: tomorrow, retired: false },
      { word: "тест4", nextReview: yesterday, retired: true }
    ];
    
    const result = getDueWords(words, today);
    
    expect(result.length).toBe(2);
    expect(result.some(w => w.word === "тест1")).toBe(true);
    expect(result.some(w => w.word === "тест2")).toBe(true);
    expect(result.some(w => w.word === "тест3")).toBe(false);
    expect(result.some(w => w.word === "тест4")).toBe(false);
  });
});
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "jsx": "react",
    "allowJs": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "../shared/src/zod.ts"]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig, loadEnv } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), "");
  const publicEnv = Object.entries(env).reduce((acc, [key, value]) => {
    if (key.startsWith('VITE_') || ["HOST_ENV", "NODE_ENV"].includes(key) ) {
      return {
        ...acc,
        [key]: value,
      }
    }
    return acc
  }, {})

  return {
    base: "/russian-stress-practice/",
    plugins: [react()],
    build: {
      outDir: "dist",
      emptyOutDir: true,
      rollupOptions: {
        input: "./index.html",
        output: {
          entryFileNames: `assets/[name].[hash].js`,
          chunkFileNames: `assets/[name].[hash].js`,
          assetFileNames: `assets/[name].[hash].[ext]`
        }
      }
    },
    publicDir: "public",
    server: {
      open: true,
      port: +env.PORT,
    },
    preview: {
      port: +env.PORT,
    },
    define: {
      'process.env': publicEnv,
    },
  };
});
</file>

<file path="pnpm-workspace.yaml">
packages:
  - "frontend"
  - "backend"
  - "shared"
</file>

<file path="frontend/package.json">
{
  "name": "@russian-stress-practice/frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "types": "tsc --noEmit --project ./tsconfig.json && tsc --noEmit --project ./tsconfig.node.json"
  },
  "dependencies": {
    "@headlessui/react": "^2.2.2",
    "@heroicons/react": "^2.2.0",
    "@react-oauth/google": "^0.12.1",
    "@russian-stress-practice/backend": "workspace:*",
    "@russian-stress-practice/shared": "workspace:*",
    "@tanstack/react-query": "4.36.1",
    "@trpc/client": "^10.45.2",
    "@trpc/react-query": "^10.45.2",
    "@trpc/server": "^10.45.2",
    "classnames": "^2.5.1",
    "date-fns": "^4.1.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-react": "^7.37.5",
    "formik": "^2.4.6",
    "formik-validator-zod": "^2.2.0",
    "heroicons": "^2.2.0",
    "js-cookie": "^3.0.5",
    "ldrs": "^1.1.7",
    "lodash": "^4.17.21",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.5.2",
    "superjson": "1.13.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/js-cookie": "^3.0.6",
    "@types/react": "^18.2.15",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.31",
    "tailwindcss": "^3.3.5",
    "vite": "^6.3.1"
  }
}
</file>

<file path=".gitignore">
node_modules
.env
</file>

<file path="package.json">
{
    "name": "russian-stress-practice",
    "version": "0.0.0",
    "private": "true",
    "dependencies": {
      "@tanstack/react-query": "4",
      "@trpc/client": "^10.45.2",
      "@trpc/next": "^10.45.2",
      "@trpc/react": "^9.27.4",
      "@trpc/server": "^10.45.2",
      "cors": "^2.8.5",
      "eslint": "^9.20.1",
      "eslint-plugin-node": "^11.1.0",
      "express": "^4.21.2",
      "react-dom": "^18.3.1",
      "react-router-dom": "^7.1.5",
      "w": "^1.1.0"
    },
    "pnpm": {
      "overrides": {
        "@tanstack/react-query": "4.36.1"
      }
    },
    "scripts": {
      "b": "pnpm --filter @russian-stress-practice/backend",
      "w": "pnpm --filter @russian-stress-practice/frontend",
      "sh": "pnpm --filter @russian-stress-practice/shared",
      "dev": "pnpm -r --parallel dev",
      "types": "pnpm -r --parallel types",
      "test": "pnpm -r test",
      "prepare": "husky && husky install"
    },
    "devDependencies": {
      "@eslint/eslintrc": "^3.3.1",
      "@types/express": "^5.0.0",
      "@types/jest": "^29.5.14",
      "@types/node": "^22.10.7",
      "@typescript-eslint/eslint-plugin": "^8.24.0",
      "@typescript-eslint/parser": "^8.24.0",
      "eslint-config-prettier": "^10.0.1",
      "eslint-config-react-app": "^7.0.1",
      "eslint-config-standard-with-typescript": "^43.0.1",
      "eslint-plugin-import": "^2.31.0",
      "eslint-plugin-jest": "^28.11.0",
      "husky": "^8.0.0",
      "jest": "^29.7.0",
      "lint-staged": "^15.4.3",
      "node": "link:@types\\node",
      "rimraf": "^6.0.1",
      "ts-jest": "^29.3.1",
      "ts-patch": "^3.3.0",
      "typescript": "^5.7.3",
      "typescript-transform-paths": "^3.5.5"
    },
    "type": "module"
  }
</file>

</files>
